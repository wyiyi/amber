<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amber</title>
  
  <subtitle>一天进步一点</subtitle>
  <link href="https://wyiyi.github.io/amber/atom.xml" rel="self"/>
  
  <link href="https://wyiyi.github.io/amber/"/>
  <updated>2025-08-19T14:07:21.617Z</updated>
  <id>https://wyiyi.github.io/amber/</id>
  
  <author>
    <name>Amber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 8 到 Java 24 新特性一览</title>
    <link href="https://wyiyi.github.io/amber/2025/08/20/java8-24/"/>
    <id>https://wyiyi.github.io/amber/2025/08/20/java8-24/</id>
    <published>2025-08-20T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://alphahinex.github.io/contents/covers/new-features-of-java-versions.jpeg"></p><ul><li>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</li><li>本文链接：<a href="https://blog.csdn.net/weixin_53933896/article/details/147856986">https://blog.csdn.net/weixin_53933896/article/details/147856986</a></li></ul><h1 id="文章说明"><a href="#文章说明" class="headerlink" title="文章说明"></a>文章说明</h1><ol><li>本文整理了 Java 8 至 Java 24 各版本的新特性，内容包括每个版本的新增功能分类（如语法增强、性能优化、工具支持等）、详细的代码示例，并结合官方文档资料，分析每项特性的应用场景及优缺点。</li><li>Java 8 发布于 2014 年，此后 Java 进入快速迭代模式，每半年发布一个新版本。一路走来，Java 8 到 Java 24 带来了大量重要的新特性。</li><li>本文持续更新中…</li></ol><h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><p><strong>发行时间</strong>： 2014 年 3 月</p><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>Lambda 表达式与函数式接口</strong>：Java 8 引入了 <strong>Lambda 表达式</strong>，使我们能够将匿名函数作为一等公民传递和使用。例如，可以使用 <code>Comparator&lt;String&gt; cmp = (a, b) -&gt; a.length() - b.length();</code> 来实现字符串长度比较。这依赖于 <strong>函数式接口</strong>（只含单一抽象方法的接口），如 <code>Comparator</code> 或自定义接口，Lambda 会被推断成该接口的实现。有了 Lambda，代码变得更加简洁，可读性提高，尤其适用于集合的过滤、映射等操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用 Lambda 表达式对列表进行过滤和映射</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Ann&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = names.stream()</span><br><span class="line">                             .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">                             .map(s -&gt; s.toUpperCase())</span><br><span class="line">                             .collect(Collectors.toList());</span><br><span class="line">System.out.println(filtered); <span class="comment">// 输出: [ALICE, ANN]</span></span><br></pre></td></tr></table></figure></li><li><strong>方法引用</strong>：除了 Lambda，Java 8 还支持 <strong>方法引用</strong>，可以用 <code>Class::method</code> 简洁地引用已有方法或构造器。例如，<code>names.forEach(System.out::println)</code> 会打印列表中每个元素，相当于对每个元素执行 System.out.println。方法引用与 Lambda 一样，也必须对应一个函数式接口目标类型。</li><li><strong>接口默认方法和静态方法</strong>：接口现在可以包含带实现的 <strong>默认方法</strong>（<code>default</code>方法）和 <strong>静态方法</strong>。这使得在不破坏已有实现类的前提下向接口添加新方法成为可能。默认方法可被实现类继承或重写；静态方法则只能通过接口名调用，不能被子类重写。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 未重写 defaultMethod()，将继承接口的默认实现</span></span><br><span class="line">&#125;</span><br><span class="line">MyInterface.staticMethod();       <span class="comment">// 调用接口静态方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyClass</span>().defaultMethod();    <span class="comment">// 调用接口默认方法，实现类未重写则执行接口中的实现</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用场景</strong>： 默认方法解决了接口演化的问题，比如 Java 8 为 <code>Collection</code> 接口添加了 <code>stream()</code> 默认方法，从而所有实现类无需修改就自动拥有流操作能力。静态方法则方便在接口中组织工具函数。</p><ul><li><strong>重复注解（Repeatable Annotation）</strong>： 允许在同一声明或类型上多次应用同一个注解类型。Java 8 引入了 <code>@Repeatable</code> 元注解，通过定义“容器注解”类型来实现重复注解支持。应用场景如定义多个过滤器、多个权限注解等，使代码更直观。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Schedule(day=&quot;Mon&quot;)</span>, <span class="meta">@Schedule(day=&quot;Tue&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduledTask</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><strong>类型注解</strong>： Java 8 扩展了注解使用的场景，注解现在可以加在任何类型使用处（Type Use），如泛型类型参数、强制转换、实现声明等。结合 JSR 308，可用于开发更强的类型检查工具（如空指针分析）。</li></ul><h2 id="核心库新特性"><a href="#核心库新特性" class="headerlink" title="核心库新特性"></a>核心库新特性</h2><ul><li><strong>Stream API</strong>： Java 8 的 <strong>Stream API</strong> 为集合批量操作提供了声明式、链式的语法。开发者可以使用类似 SQL 风格的操作（<code>filter</code>, <code>map</code>, <code>reduce</code> 等）来处理数据流。<code>Stream</code> 的操作分为<strong>中间操作</strong>（惰性求值）和<strong>终止操作</strong>（触发计算）。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .filter(n -&gt; n % <span class="number">2</span> == <span class="number">1</span>)      <span class="comment">// 筛选奇数</span></span><br><span class="line">                 .mapToInt(n -&gt; n * n)         <span class="comment">// 平方映射</span></span><br><span class="line">                 .sum();                       <span class="comment">// 终止操作求和</span></span><br><span class="line">System.out.println(sum); <span class="comment">// 输出: 35（1^2 + 3^2 + 5^2）</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用场景</strong>： Stream API 大大简化了集合的复杂操作，避免了繁琐的迭代和临时集合管理。例如，可以轻松进行过滤、汇总统计、分组分区等操作。缺点是初学者需要学习 Lambda 表达式和流式思维，但一旦掌握，能编写出高可读性的流水线处理代码。</p><ul><li><strong>Optional 类</strong>： 引入了 <code>java.util.Optional&lt;T&gt;</code>，用于优雅地表示“可能为空”的值。Optional 提供了诸如 <code>isPresent()</code>, <code>ifPresent()</code>, <code>orElse()</code> 等方法，可以替代显式的空检查，减少空指针异常风险。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title function_">findUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">result</span> <span class="operator">=</span> ... <span class="comment">// 查找用户</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Optional避免显式null判断</span></span><br><span class="line">findUser(<span class="string">&quot;Alice&quot;</span>).ifPresent(user -&gt; System.out.println(user.getId()));</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> findUser(<span class="string">&quot;Bob&quot;</span>).orElse(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>)); <span class="comment">// 未找到则返回默认User</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用场景</strong>： Optional 常用于方法返回值，表示“可能没有结果”。这比返回 <code>null</code> 更具语义，也迫使调用方处理不存在的情况。需要注意不要滥用在域对象上，Optional设计主要用于返回值，而非序列化或字段类型。</p><ul><li><strong>全新的日期时间 API</strong>： Java 8 推出了 <code>java.time</code> 包（JSR 310），提供了不变且线程安全的日期时间类，包括 <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code> 等，以及用于周期和持续时间的 <code>Period</code>, <code>Duration</code>。新的 API 改进了旧版<code> java.util.Date</code> 和 <code>Calendar</code> 的诸多问题，提供了更加自然的时间操作接口。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birthday</span> <span class="operator">=</span> LocalDate.of(<span class="number">1990</span>, Month.APRIL, <span class="number">1</span>);</span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(birthday, today);</span><br><span class="line">System.out.printf(<span class="string">&quot;年龄: %d 年 %d 月 %d 日%n&quot;</span>, </span><br><span class="line">                  period.getYears(), period.getMonths(), period.getDays());</span><br></pre></td></tr></table></figure></li></ul><p><strong>应用场景</strong>： 新日期API提供了清晰的方法来操作日期时间，支持时区、夏令时、安全不变。此外还提供了格式化和解析（<code>DateTimeFormatter</code>），大幅简化日期处理，避免了旧 API 各种不一致和缺陷。</p><ul><li><strong>并发增强（CompletableFuture 等）</strong>： Java 8 在并发库方面增加了 <code>CompletableFuture</code>，支持以<strong>链式回调</strong>的方式处理异步结果，实现了Promise模式。例如可以组合多个异步计算、设置依赖和异常处理。此外，新增的并发工具包括并行数组排序（<code>Arrays.parallelSort</code>）、并发Accumulator、Adder等，改进了并行计算性能。</li><li><strong>其它常用库改进</strong>： 例如 <code>Map.computeIfAbsent</code> 等函数式风格的方法，方便地对 Map 执行条件更新；Base64 编码解码器（<code>java.util.Base64</code>）也在 Java 8 加入成为标准库。</li></ul><h2 id="JVM-与性能优化"><a href="#JVM-与性能优化" class="headerlink" title="JVM 与性能优化"></a>JVM 与性能优化</h2><ul><li><strong>永久代移除</strong>： Java 8 移除了 HotSpot VM 的永久代（PermGen），取而代之的是 <strong>元空间（Metaspace）</strong>。元空间在本地内存中分配且按需增长，大幅减少了因固定永久代空间不足导致的 <code>OutOfMemoryError</code> 情况，提高了内存管理的灵活性。开发者在升级时需要注意移除了永久代相关的 JVM 参数（如 <code>-XX:PermSize</code>）。</li><li><strong>垃圾回收优化</strong>： Java 8 中虽然默认垃圾回收器仍是 Parallel GC，但引入了一些改进。例如引入<strong>串行/并行 Full GC</strong> 等优化；此外为 G1 垃圾收集器（实验性）打下基础。虽然 G1 直到 Java 9 才成为默认 GC，但在 Java 8 已可通过 <code>-XX:+UseG1GC</code> 使用，其目标是低停顿，更适合大堆内存应用。</li><li><strong>HashMap 性能改进</strong>： 为了应对哈希碰撞，Java 8 改进了 <code>HashMap</code> 和 <code>ConcurrentHashMap</code> 的实现。当桶中链表长度超过阈值时，将链表转换为 <code>红黑树</code> 存储，从平均 O(n) 查找降为 O(log n)。这显著改善了哈希冲突严重时的性能 <strong>（优点），代价是结构更复杂（可能略增插入删除成本）</strong>。但总体而言，这让 HashMap 在最坏情况下性能更可控。</li></ul><h2 id="工具和其他"><a href="#工具和其他" class="headerlink" title="工具和其他"></a>工具和其他</h2><ul><li><strong>Nashorn JavaScript引擎</strong>： Java 8 内置了全新的 JavaScript 引擎 <strong>Nashorn</strong>，替代了原有的 Rhino 引擎。Nashorn 利用 InvokeDynamic 提高了 JS 运行性能，可通过 <code>jjs</code> 命令运行 .js 脚本，也能在Java程序中使用 <code>ScriptEngine</code> 执行JS代码。在需要在 JVM 中嵌入脚本、实现动态逻辑的场景下，Nashorn 提供了更高性能和ES5兼容性。不过需要注意 Nashorn 在后续 Java 15 已被移除，建议长期方案还是GraalVM多语言支持。</li><li><strong>增强的注解处理和反射</strong>： Java 8 对反射和注解处理也有一些改进，如引入 <code>Parameter</code> 类来支持获取方法参数名（需加 <code>-parameters</code> 编译），以及 <code>AnnotatedElement</code> 接口新增方法直接获取重复注解等。这些增强使框架开发者更方便地获取运行时信息，构建更丰富的注解驱动逻辑。</li></ul><p><strong>总结</strong>： Java 8 是一个里程碑版本，引入的 Lambda 和 Stream 等特性使Java正式进入函数式编程时代。默认方法等特性改善了接口演进能力。核心库的加强和全新时间API填补了多年痛点。在性能上，永久代的移除和集合优化提升了稳定性。Java 8 的诸多新功能为之后的Java版本奠定了基础，也是目前许多项目仍在使用的版本。</p><h1 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h1><p><strong>发行时间</strong>： 2017 年 9 月</p><h2 id="语言和语法增强"><a href="#语言和语法增强" class="headerlink" title="语言和语法增强"></a>语言和语法增强</h2><ul><li><strong>模块化系统（Project Jigsaw）</strong>： Java 9 最重要的变化是引入<strong>模块化系统</strong>。JDK 本身被重组为约 94 个模块，允许按需组合所需模块来构建定制的 Java 运行时（可使用下面提到的 jlink 工具）。开发者可以通过创建模块描述符 <code>module-info.java</code> 将应用拆分为模块。模块定义了所包含的包以及导出的内容和所需依赖，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-info.java 示例</span></span><br><span class="line"><span class="keyword">module</span> com.example.app &#123;</span><br><span class="line">    <span class="keyword">requires</span> com.example.utils;    <span class="comment">// 声明依赖模块</span></span><br><span class="line">    <span class="keyword">exports</span> com.example.app.api;   <span class="comment">// 导出包供其他模块使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>模块系统解决了 classpath 下包命名冲突和封装不严的问题，实现<strong>强封装</strong>。只有模块导出的包才能被外部访问，未导出的内部实现包将被严格封装。这样提高了代码的可维护性和安全性。<strong>应用场景</strong>： 大型应用可以通过模块划分更好地管理依赖关系，同时在部署时使用 jlink 剔除无关模块减小体积。不过模块化也带来了学习曲线，且现有项目迁移需要调整访问限制（可以通过 <code>--add-exports</code> 等选项做兼容）。</li><li><strong>接口私有方法</strong>： 除了 Java 8 的接口默认方法外，Java 9 支持接口定义 <strong>私有方法</strong> 来给多个默认方法复用业务逻辑。这提高了接口内部实现的封装性，避免默认方法之间代码重复。私有接口方法只能在接口内部被默认或静态方法调用，不会暴露给实现类。</li><li><strong>try-with-resources 改进</strong>： try-with-resources 语法在 Java 9 更加方便。现在如果已有实现 <code>AutoCloseable</code> 的资源对象(final或 effectively final)，可以直接在 try 语句中使用该变量，而不必再次声明。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8 及之前需要在 try 内新声明</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> Files.newBufferedReader(path)) &#123; ... &#125;</span><br><span class="line"><span class="comment">// Java 9 可以在 try 中直接使用已有的变量 br</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> Files.newBufferedReader(path);</span><br><span class="line"><span class="keyword">try</span> (br) &#123;</span><br><span class="line">    <span class="comment">// 使用 br 读取...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这减少了不必要的代码臃肿，让语法更简洁。</li></ul><h2 id="核心库增强"><a href="#核心库增强" class="headerlink" title="核心库增强"></a>核心库增强</h2><ul><li><strong>集合工厂方法</strong>： Java 9 为集合接口添加了方便创建不可变集合的静态工厂方法。例如：<code>List.of(1,2,3)</code>, <code>Set.of(&quot;a&quot;,&quot;b&quot;)</code>, <code>Map.of(&quot;key1&quot;,&quot;val1&quot;,&quot;key2&quot;,&quot;val2&quot;)</code> 等，可以快捷地创建包含固定元素的集合。这些集合是<strong>不可修改</strong>的（修改会抛异常）。相比手动创建集合然后 <code>Collections.unmodifiableX</code>，新方法更直观高效。应用场景： 用于快速创建常量集合、简化测试用例数据准备等。</li><li><strong>Stream API 改进</strong>： Java 9 为 Stream 增加了一些实用的新方法，如 <code>takeWhile</code>, <code>dropWhile</code> 和 <code>ofNullable</code> 等。其中 <code>takeWhile(predicate)</code> 会从 Stream 开头起连续获取满足条件的元素，直到遇到不满足条件者停止；<code>dropWhile(predicate)</code> 则丢弃开头连续满足条件的元素。还有 <code>Stream.iterate</code> 支持提供断言来结束迭代。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).takeWhile(n -&gt; n &lt; <span class="number">4</span>)  <span class="comment">// 得到 [1,2,3]</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).dropWhile(n -&gt; n &lt; <span class="number">4</span>)  <span class="comment">// 得到 [4,5]</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, x -&gt; x+<span class="number">1</span>).takeWhile(x -&gt; x&lt;=<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>此外，<code>Optional</code> 也增加了 <code>ifPresentOrElse</code>, <code>or</code> 等方法，提高 Optional 的易用性。这些改进让流操作和 Optional 更加完备，减少手动处理。</li><li><strong>进程 API</strong>： 新增 <code>ProcessHandle</code> 接口，提供了更现代的进程管理 API。通过 <code>ProcessHandle.current()</code> 可以获取当前进程信息，包括 PID 等；还能列出现有进程，观察进程树关系，设置监听等。相比以前只能通过 <code>Runtime.getRuntime().exec()</code> 启动进程、基本无反馈，新的 API 丰富了进程交互能力。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessHandle</span> <span class="variable">self</span> <span class="operator">=</span> ProcessHandle.current();</span><br><span class="line"><span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> self.pid();</span><br><span class="line">self.info().command().ifPresent(cmd -&gt; System.out.println(<span class="string">&quot;命令: &quot;</span> + cmd));</span><br></pre></td></tr></table></figure>这在需要监控或管理操作系统进程的应用中非常有用，如实现自定义的进程守护、获取子进程退出事件等。</li><li><strong>响应式流（Reactive Streams）</strong>： Java 9 在 <code>java.util.concurrent</code> 下引入了 <strong>发布-订阅框架</strong>：<code>Flow</code> API，包括 <code>Flow.Publisher</code>, <code>Subscriber</code>, <code>Subscription</code>, <code>Processor</code> 四个接口。这实际上与 Reactive Streams 标准兼容，为反应式编程提供背压（backpressure）支持。虽然Java 9没有提供具体实现，但像 RxJava、Akka Streams 等库可直接与这套接口集成。应用在需要异步数据流且要考虑消费速率的场景。</li><li><strong>HTTP/2 客户端（孵化）</strong>： Java 9 引入了一个新的 HTTP 客户端 API 的孵化版本（位于 <code>jdk.incubator.httpclient</code> 模块），支持 HTTP/2 和 WebSocket。虽然后来在 Java 11 才正式成为标准 API，这里值得一提。这新客户端支持异步非阻塞调用，比旧的 <code>HttpURLConnection</code> 更易用、性能更佳。</li></ul><h2 id="JVM-和性能"><a href="#JVM-和性能" class="headerlink" title="JVM 和性能"></a>JVM 和性能</h2><ul><li><strong>G1 成为默认 GC</strong>： Java 9 将 <strong>G1 垃圾收集器</strong> 设置为默认垃圾回收器，取代了之前的 Parallel Scavenge/Parallel Old 组合。G1（Garbage First）是一种低暂停收集器，擅长处理大堆内存，尽量避免了全堆的长时间停顿。在 Java 9 中，G1 的 Full GC 仍是单线程的，因此极端情况下可能出现长暂停。对此在 Java 10 又做了并行化改进。<strong>应用场景</strong>： 对延迟敏感的服务，可从默认使用G1中获益（前提是仔细调优以适应应用负载）。</li><li><strong>字符串存储优化</strong>： Java 9 引入了 <strong>Compact Strings</strong>，即在内部用 byte 数组存储字符串字符（Latin-1 和 UTF-16 动态选择），而不再总是用 char 数组。对于只包含ASCII的字符串，可节省一半内存。这个改动对开发者透明，但在字符串处理密集的应用中降低了内存占用，提高了CPU缓存利用率。</li><li><strong>AOT 编译（实验）</strong>： 新增了 <code>jaotc</code> 工具，允许将 Java 类提前编译为本地代码（Ahead-Of-Time）。AOT 编译器基于 Graal，可生成本地库，在应用启动时加载，从而加快启动速度。不过这是实验性功能，实际使用较少，在后续版本中也被移除。场景：需要极致优化启动时间的场合可以探索，但一般而言JIT已经足够。</li><li><strong>VarHandle 和内存栅栏</strong>： Java 9 提供了 <code>java.lang.invoke.VarHandle</code> 类，作为对 <code>sun.misc.Unsafe</code> 的更安全替代。VarHandle 可以视作特定变量的引用，支持原子操作和内存可见性控制，比如读取写入内存栅栏（类似于 C++ 中的 <code>std::atomic</code>）。这为开发并发框架、实现锁自由算法提供了标准化的工具。</li><li><strong>多版本 JAR</strong>： 支持 <strong>多版本 JAR</strong> 文件，即在一个 JAR 中根据不同Java版本包含不同的类实现（通过 META-INF/versions 目录）。运行时将选择匹配当前JVM版本的类，实现库对新旧版本的兼容发布。例如，你可以在 JAR 中同时包含 Java 8 的实现和利用Java 9特性的实现。这样第三方库可以渐进地利用新特性，同时不失对旧版本的支持。</li></ul><h2 id="工具与其他"><a href="#工具与其他" class="headerlink" title="工具与其他"></a>工具与其他</h2><ul><li><strong>JShell</strong>： Java 9 带来了官方的交互式 REPL 工具 <strong>JShell</strong>。开发者可以在不创建类和 main 方法的情况下，直接输入Java表达式或语句，即时查看执行结果。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">20</span></span><br><span class="line">x ==&gt; <span class="number">100</span></span><br><span class="line">jshell&gt; <span class="string">&quot;hello, &quot;</span> + <span class="string">&quot;jshell&quot;</span></span><br><span class="line">$<span class="number">2</span> ==&gt; <span class="string">&quot;hello, jshell&quot;</span></span><br></pre></td></tr></table></figure>JShell 极大地方便了试验性编程和学习。可以用它快速验证一段逻辑、探索API用法等，降低了写一个<code>Hello World</code>的门槛。对于教学、原型开发非常实用。</li><li><strong>jlink</strong>： Java 9 引入了 <code>jlink</code> 工具，可以根据模块依赖创建自定义的精简运行时镜像。开发者指定应用模块后，jlink 会打包只包含所需模块的最小化 JRE。这对于发布自包含的Java应用很有帮助，特别是在容器、物联网设备上，可减少体积并避免目标环境需要预装完整JDK。</li><li><strong>JUnit 5 等生态升级</strong>： 随着Java 9发布，测试框架JUnit 也升级到5，支持Java 8+特性如Lambda断言等。这虽不是JDK自带，但与语言新特性配套出现，标志着Java生态正拥抱新版本。</li></ul><p><strong>总结</strong>： Java 9 通过模块系统对Java平台进行了<strong>结构性革新</strong>。虽然社区对模块化褒贬不一，但不可否认它提高了代码封装和定制部署能力。除此之外，Java 9 在语法上小幅改进（私有接口方法、钻石操作符支持匿名类等<strong>未提及细节</strong>），在API和工具上为开发者提供了许多便捷，如JShell、集合工厂等。它为之后的版本铺平了道路，标志着Java进入了<strong>快速发布</strong>的新时代。</p><h1 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h1><p><strong>发行时间</strong>： 2018 年 3 月</p><h2 id="语言特性-1"><a href="#语言特性-1" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>局部变量类型推断（<code>var</code>）</strong>： Java 10 最引人注目的特性是引入了新的关键字 <code>var</code>，用于局部变量类型推断。开发者在定义局部变量时，可以用 <code>var</code> 代替具体类型，编译器会根据初始化表达式自动推断类型：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="type">var</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item : list) &#123;</span><br><span class="line">    <span class="comment">// 在循环中，item 的类型也会被推断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在上述代码中，编译器会推断出 <code>list</code> 的类型为<code> ArrayList&lt;String&gt;</code>，<code>sum</code> 的类型为 <code>int</code>。<strong>注意： <code>var</code> 不是</strong>动态类型或弱类型，Java 类型系统仍是静态的，只是让编译器替我们填写类型。因此，<code>var</code> 只能用于有初始化的局部变量、for循环索引等，不可用于成员变量、方法参数，也不可将 <code>null</code> 赋给 <code>var</code>（无法推断类型）。另外，使用 <code>var</code> 可能降低代码可读性，应该在<strong>类型明显</strong>或<strong>冗长</strong>的情况下使用，如复杂泛型类型。对于简单变量，直接写出类型可能更清晰。</li></ul><p><strong>应用场景</strong>： <code>var</code> 可减少样板代码，特别是当类型本身冗长（如泛型嵌套）时。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 使用 var 推断类型</span></span><br><span class="line"><span class="type">var</span> <span class="variable">dataMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Integer&gt;&gt;();</span><br></pre></td></tr></table></figure><p>这在一定程度上让Java具有了脚本语言的简洁性，但依然保留了静态类型检查的安全性。</p><h2 id="核心库增强-1"><a href="#核心库增强-1" class="headerlink" title="核心库增强"></a>核心库增强</h2><ul><li><strong>不可变集合拷贝</strong>： 在 Java 9 提供集合工厂方法基础上，Java 10 为集合增加了 <code>List.copyOf</code>, <code>Set.copyOf</code>, <code>Map.copyOf</code> 静态方法。这些方法会返回传入集合的<code>不可变拷贝</code>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; src = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">List&lt;String&gt; copy = List.copyOf(src);</span><br><span class="line">src.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(copy); <span class="comment">// 输出 [a, b]，copy 不受原列表修改影响</span></span><br><span class="line">copy.add(<span class="string">&quot;d&quot;</span>); <span class="comment">// UnsupportedOperationException，不可修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>应用场景</strong>： 当需要确保集合不被修改时，可以方便地获取其不可变版本，尤其在方法参数和返回值中传递集合时，使用 <code>copyOf</code> 能防止意外修改源集合。另外，Collectors 增加了 <code>Collectors.toUnmodifiableList()</code> 等方法，直接收集 Stream 元素为不可变集合。</p><ul><li><strong>Optional 增强</strong>： Java 10 为 <code>Optional</code> 新增了 <code>orElseThrow()</code> 方法，它等价于 <code>.orElseThrow(NoSuchElementException::new)</code>。虽然功能与 <code>get()</code> 相似，但命名更明确，语义更清晰（get() 在Optional语境下不直观）。此外还引入了 <code>Optional.or(() -&gt; alternativeOptional)</code> 来在当前Optional为空时提供另一个Optional。这些方法让Optional的链式操作更丰富，使用更加流畅。</li><li><strong>并行垃圾回收器接口</strong>： 引入 <code>java.lang.ref.Cleaner</code> 提供替代 <code>finalize()</code> 的清理机制。尽管不直接属于核心“库”，但Java 10重新整理了垃圾收集器的内部接口，将不同 GC 实现的共性提取出来。这对最终用户没有直接影响，但使得 HotSpot 更易于添加新GC。这体现了JDK内部代码的演进。</li></ul><h2 id="性能和-JVM-改进"><a href="#性能和-JVM-改进" class="headerlink" title="性能和 JVM 改进"></a>性能和 JVM 改进</h2><ul><li><strong>G1 并行 Full GC</strong>： 虽然 G1 在 Java 9 成为默认 GC，但它的 Full GC 仍是单线程。Java 10 通过 JEP 307 实现了 <strong>G1 Full GC 并行化</strong>。现在当 G1 不得不触发 Full GC 时，会使用多个线程并行标记清除，减少停顿时间。这提升了 G1 在高内存占用下的最坏情况表现，使其更接近预期的低延迟目标<strong>（优点）</strong>。对于内存非常紧张、可能触发Full GC的场景，这一改进能显著降低停顿时长。当然，在正常情况下，G1 仍会努力避免 Full GC 的发生。</li><li><strong>应用类数据共享（AppCDS）</strong>： 类数据共享（CDS）功能早在 JDK 5 就存在，用于将JDK的核心类预加载到共享归档，从而加快启动并减少内存占用。Java 10 通过 JEP 310 将 CDS 扩展到应用层面，允许<strong>应用类</strong>也加入共享归档。原理是先在一次运行中记录所加载的应用类列表，生成归档文件；下次启动时直接映射此归档，加速类加载并减少重复占用的元空间。<strong>应用场景</strong>： 对于多实例部署的相同应用，使用 AppCDS 可减少整体内存占用；对单实例应用也能略微提升启动性能。不过配置上有一定复杂度（需要一次试运行生成列表），Java 13 又引入了动态CDS归档以简化流程。</li><li><strong>线程局部握手（Thread Local Handshake）</strong>： Java 10 改进了 JVM 停止线程执行的机制。以前 Stop-The-World 操作通常需要全局安全点，在同一时刻挂起所有线程。引入线程本地握手后，JVM 可以在不停止全部线程的情况下，对单个线程执行小任务或检查。例如可以挂起单个线程以回收它的栈，其他线程不受影响<strong>（优点）</strong>。这一特性提升了调优GC和其他VM功能的灵活性，是 JVM 内部优化，但最终有助于降低停顿、提升并发性能。</li><li><strong>备用内存设备上的堆</strong>： 允许 JVM 将 Java 堆分配在非主内存设备上（如NVDIMM持久内存）。这对于使用特殊硬件（比如大容量的持久内存）的应用有意义，可以扩大有效堆容量或持久化堆数据。这属于非常专业的优化特性，普通场景用不到，但体现了Java对新硬件技术的支持。</li></ul><h2 id="工具和平台"><a href="#工具和平台" class="headerlink" title="工具和平台"></a>工具和平台</h2><ul><li><strong>实验性 Java JIT 编译器 - Graal</strong>： Java 10 将基于Java实现的 JIT 编译器 <code>Graal</code> 引入为实验性选项。启用参数为<code> -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code>，仅限Linux/macOS的64位环境。Graal 致力于更高级的优化和多语言支持，是后续GraаlVM的基础。尽管默认仍是C2编译器，但尝试者可以用Graal看看是否带来性能改进。这一特性表明了JIT实现也可以用Java自身来编写，利于未来的维护和演进。</li><li><strong>根证书开源</strong>： Oracle 将 JDK 内置的 root CA 证书库开源，替代以前Oracle JDK与OpenJDK差异的一部分。这意味着OpenJDK自带了可信证书库，使HTTPS通信开箱即用（以前OpenJDK默认缺少很多可信证书）。这对开发者是无感知的改进，但对于OpenJDK采用者是福音。</li></ul><p><strong>总结</strong>： 虽然 Java 10 属于非 LTS 的短期版本，但引入的 var 关键字极大地简化了日常编码。集合、Optional的小改进也增强了标准库的便利性。在性能方面，G1 并行Full GC、AppCDS 都是偏底层却意义重大的优化，让Java在大内存和大规模部署场景下表现更好。Java 10 还预示了未来的发展方向，如Graal编译器的引入为后续多语言支持铺路。作为承上启下的版本，Java 10 为后来Java 11的重大变化做好了准备。</p><h1 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h1><p><strong>发行时间</strong>： 2018 年 9 月 25 日 （LTS长期支持版）</p><h2 id="语言特性-2"><a href="#语言特性-2" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>Lambda 参数的局部变量语法</strong>： Java 11 允许在 Lambda 表达式的参数中使用局部变量语法，即可以用 <code>var</code> 来声明参数类型。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; cmp = (<span class="keyword">var</span> a, <span class="keyword">var</span> b) -&gt; Integer.compare(a.length(), b.length());</span><br></pre></td></tr></table></figure>这对Lambda本身功能没有变化，但允许我们添加参数注解时更方便（因为只能用显式类型才能加注解）。总体来说，这一特性用途有限，仅在某些需要注解lambda参数的场景下提供了语法便利。</li><li><strong>直接启动单文件程序</strong>： Java 11 可以直接运行单个Java源文件，命令如：<code>java Hello.java</code>。Java编译器会隐式地先编译这个源文件再执行。这使得<strong>脚本化</strong>使用Java成为可能，方便编写临时的小程序或教学演示。例如，新手可以直接写 <code>System.out.println(&quot;Hello&quot;);</code> 保存为 Hello.java，然后 <code>java Hello.java</code> 即可运行。需要注意的是：该源文件的所有依赖类都必须在同一文件中或者在类路径上。<br><strong>应用场景</strong>： 这一特性降低了Java的入门门槛和使用Java编写脚本的成本，可以拿来写简单的工具脚本、验证性程序等，提升了开发者体验。配合 JShell，Java 在快速试验和脚本方面的短板进一步缩小。</li></ul><h2 id="核心库增强-2"><a href="#核心库增强-2" class="headerlink" title="核心库增强"></a>核心库增强</h2><ul><li><strong>标准化 HTTP 客户端</strong>： Java 11 将新 HTTP 客户端 API 正式加入标准库（位于 <code>java.net.http</code> 包）。这个 API 支持 HTTP/1.1 和 HTTP/2，并提供了同步和异步（基于 CompletableFuture）两种调用方式。示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;https://api.github.com&quot;</span>))</span><br><span class="line">                                 .header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">                                 .GET().build();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br></pre></td></tr></table></figure>新客户端比旧的 <code>HttpURLConnection</code> 使用更简洁，功能更丰富（如内置 WebSocket 支持）。<strong>应用场景</strong>： 调用 REST 服务、执行HTTP请求等在企业开发中很常见，新API提高了开发效率，并发支持和HTTP/2多路复用也带来性能优势。</li><li><strong>字符串API增强</strong>： Java 11 对 <code>String</code> 添加了若干实用方法：</li><li><ul><li><code>isBlank()</code>：判断字符串是否为空白（空串或只含空白字符）。</li></ul></li><li><ul><li><code>strip()</code>：类似 <code>trim()</code>，但能正确处理 Unicode 空白（并有 <code>stripLeading</code>, <code>stripTrailing</code>）。</li></ul></li><li><ul><li><code>repeat(int count)</code>：重复当前字符串 count 次，返回新串。</li></ul></li><li><ul><li><code>lines()</code>：将字符串按行拆分为一个流（Stream）。<br>例如：<code>&quot; foo\n&quot;.strip()</code> 将得到 <code>&quot;foo&quot;</code>； <code>&quot;&quot;.isBlank()</code> 返回 true； <code>&quot;ab&quot;.repeat(3)</code> 返回 <code>&quot;ababab&quot;</code>。这些方法使常见字符串处理更方便。应用在清理用户输入、生成简单重复文本等场景。</li></ul></li><li><strong>文件方法和集合增强</strong>： 引入了 <code>Files.readString(Path)</code> 和 <code>Files.writeString(Path, CharSequence)</code> 来简化文件读写操作（以前需要自行使用流读取或写入）。集合接口也增加了一些默认方法，如 <code>Collection.toArray(IntFunction generator)</code> 可以方便地生成正确类型的数组。<code>Optional</code> 新增了 <code>isEmpty()</code> 方法，与 <code>isPresent()</code> 相对，更直观地判断空Optional。</li><li><strong>关键字 var 用于Lambda</strong>： 前面提及的 lambda 参数使用 <code>var</code> 实际上属于语言变化，但一起提及：这使得我们可以在 lambda 参数上加注解。例如 <code>(var x, var y) -&gt; x + y</code>，如果不需要注解，一般直接 <code>(x, y)</code> 就好，所以此特性主要为注解服务。</li></ul><h2 id="性能与内存"><a href="#性能与内存" class="headerlink" title="性能与内存"></a>性能与内存</h2><ul><li><strong>ZGC（可伸缩低延迟 GC）</strong>： Java 11 引入了实验性的 <code>Z Garbage Collector (ZGC)</code>。ZGC是一种着眼于超大堆内存的低延迟垃圾收集器，采用着色指针和读屏障，实现了几乎全部并发的收集过程。ZGC 的目标是在任意堆大小下将GC停顿控制在十毫秒级别以内。这对需要超低延迟且使用大内存的应用（如内存数据库）很有意义。启用ZGC需要加VM参数如 <code>-XX:+UseZGC</code>（仅限64位 Linux，当时）。虽然ZGC在Java 11是实验状态，但它展示了JVM GC技术的新方向。</li><li><code>Epsilon GC</code>： 另一个实验性GC —— <code>Epsilon</code> 也在Java 11中提供。Epsilon是一个<code>空GC</code>，它<code>不回收内存</code>，只负责分配内存，等内存用完即让程序崩溃。这个听似奇怪的GC主要用于性能测试和内存压力测试场景：比如对比不同GC的分配性能，或在短生命周期应用中避免GC开销。Epsilon不适合实际生产，但提供了一个极端基线。</li><li><code>低开销 Heap Profiling</code>： 引入了一种低开销的堆采样机制，可通过 JVM TI 获取堆上对象分配的信息。这有助于分析内存使用，而对性能影响较小。对于线上问题诊断（内存泄漏分析）会很有帮助。</li><li><code>Flight Recorder 开源</code>： 商业JDK中的 Java Flight Recorder (JFR) 在 Java 11 正式开源纳入OpenJDK。JFR是低开销的性能分析和事件收集工具，与JDK紧密集成。现在所有Java开发者都能使用<code>-XX:StartFlightRecording</code>来收集应用运行数据，用于诊断性能瓶颈。它特别适合在生产环境持续监控，因为开销很低。随JFR一起开放的还有Mission Control可视化工具（独立下载）。</li><li><code>TLS 1.3</code>： Java 11 实现了 TLS 1.3 协议，将安全套接字协议升级到最新标准。TLS 1.3 有更简洁的握手过程和更安全的密码套件。对于使用SSL/TLS的Java应用，这意味着开箱即用支持最新安全标准，提升安全性和性能（减少握手延迟）。</li></ul><h2 id="工具与其他-1"><a href="#工具与其他-1" class="headerlink" title="工具与其他"></a>工具与其他</h2><ul><li><strong>移除和弃用</strong>： Java 11 是一个LTS版本，也移除了不少遗留特性。例如彻底移除了 Java EE 和 CORBA 模块（在Java 9就标记deprecated），包括 <code>javax.xml.bind</code>、<code>javax.ws.rs</code> 等，这些由独立的Jakarta EE实现替代。还移除了Applet API等过时技术。另外 Nashorn JavaScript 引擎在Java 11被标记为弃用（最终移除于Java 15）。这些变化提示开发者需要从JDK中迁移相应依赖到独立库。</li><li><strong>Java 命令新选项</strong>： <code>java</code> 命令增加了 <code>--show-version</code> 等选项，更方便地查看版本。<code>keytool</code> 等安全工具也支持更多算法和更方便的选项。</li></ul><p><strong>总结</strong>： 作为长期支持版本，<strong>Java 11 集大成</strong>，巩固了Java 9和10的变化并提供了一些关键的新功能。HttpClient的正式加入填补了长期以来标准库缺乏现代HTTP客户端的空白。一系列细小的API改进（字符串、文件、集合等）提升了日常开发体验。ZGC等革新的GC技术虽然仍是实验性质，但展现了Java在大内存低延迟领域的潜力。Java 11 开源了之前商用的JFR，统一了Oracle JDK和OpenJDK的差异，这对Java生态意义重大。可以说，Java 11 为随后版本的演进打下了稳定基础，也成为许多企业下一步升级的目标版本。</p><h1 id="Java-12-新特性"><a href="#Java-12-新特性" class="headerlink" title="Java 12 新特性"></a>Java 12 新特性</h1><p><strong>发行时间</strong>： 2019 年 3 月</p><h2 id="语言特性（预览）"><a href="#语言特性（预览）" class="headerlink" title="语言特性（预览）"></a>语言特性（预览）</h2><ul><li><strong>Switch 表达式 (预览)**： Java 12 对 <code>switch</code> 进行了增强，推出了 **Switch 表达式</strong> 作为预览特性。它允许 <code>switch</code> 直接返回值并使用简洁的“箭头语法”或<code>yield</code>语句，避免了繁琐的<code>break</code>。例如，在Java 12中可以这样写：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的switch表达式语法（Java 12+，需 --enable-preview）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">numDays</span> <span class="operator">=</span> <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MON, FRI, SUN -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> TUE -&gt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> THU, SAT -&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> WED -&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 对于多行的逻辑，可使用 yield 返回值</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown day: &quot;</span> + day);</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>这种语法消除了忘写<code>break</code>导致贯穿的风险，每个分支的结果要么用<code>-&gt;</code>后的表达式，要么使用<code>yield</code>语句返回。Switch 表达式使得 <code>switch</code> 可用于内嵌在赋值或返回语句中，更加<strong>表达式化。</strong> <strong>应用场景</strong>： 需要根据枚举或常量计算结果的场合会更简洁，例如将老式的 <code>switch</code>-<code>case</code> 结构转换为一行返回值的表达式。Java 12 此特性需通过<code>--enable-preview</code>启用，经过12、13的反馈，最终在Java 14成为正式特性。</li><li><strong>Instanceof 模式匹配 (预览)**： Java 12 引入了</strong>模式匹配的 instanceof**（同为预览特性）。简化了在进行类型检查后再强制转换的常见模式。新语法允许：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) &#123;</span><br><span class="line">    <span class="comment">// 进入此块则自动完成类型转换，可直接使用 str</span></span><br><span class="line">    System.out.println(str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样，无需再写 <code>(String) obj</code> 的强转和单独声明变量。这使代码更紧凑，避免了转换错误。<strong>应用场景</strong>： 广泛存在于对参数进行不同类型处理的时候。例如一个 <code>Object</code> 可以是多种类型，根据不同类型有不同逻辑，用传统 instanceof 需要繁琐的强转，有了模式匹配就简洁安全得多。Instanceof 模式匹配在Java 16转正。</li></ul><h2 id="核心库增强-3"><a href="#核心库增强-3" class="headerlink" title="核心库增强"></a>核心库增强</h2><ul><li><strong>String 新方法</strong>： Java 12 为 <code>String</code> 添加了两个方便的方法：</li><li><ul><li>**String.indent(int n)**：调整字符串每行的缩进。正数n表示在每行前添加n个空格，负数n表示去除每行前最多n个空白字符。这对格式化多行字符串很有用。</li></ul></li><li><ul><li>**String.transform(Function&lt;String,R&gt; f)**：将字符串通过给定的函数转换为另一种对象。这相当于 <code>f.apply(str)</code>，只是使调用更流畅，可用于串联调用。例如 <code>&quot;foo&quot;.transform(s -&gt; s + &quot;bar&quot;)</code> 结果是 <code>&quot;foobar&quot;</code>。<br>这些方法提升了处理字符串的便利性。例如，indent配合文本块（在Java 13预览）可以很容易地调整代码或文案的缩进。</li></ul></li><li><strong>Files.mismatch</strong>： 在 <code>java.nio.file.Files</code> 中新增了 <code>Files.mismatch(Path, Path)</code> 方法，用于高效比较两个文件的内容是否相同。它返回第一个不匹配的字节的位置，若返回-1表示文件完全相同。这对比对大型文件很有帮助，利用底层字节比较，可能比逐行读更快。</li><li><strong>NumberFormat 压缩数字</strong>： <code>java.text.NumberFormat</code> 新增了<strong>紧凑数字格式</strong>（Compact Number Formatting）。这允许以“K”“M”等简写方式格式化数字。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NumberFormat</span> <span class="variable">fmt</span> <span class="operator">=</span> NumberFormat.getCompactNumberInstance(Locale.US, Style.SHORT);</span><br><span class="line">System.out.println(fmt.format(<span class="number">1000</span>));    <span class="comment">// 输出 &quot;1K&quot;</span></span><br><span class="line">System.out.println(fmt.format(<span class="number">1_000_000</span>)); <span class="comment">// 输出 &quot;1M&quot;</span></span><br></pre></td></tr></table></figure>对需要友好展示统计数据的场合很实用，比如在界面上显示“2.3万”这样的格式（中文 Locale 会输出类似“2万3千”）。</li><li><strong>Collector.Teeing</strong>： Java 12增加了一个很有用的<code>Collector：Collectors.teeing</code>，可以让流拆分成两个子流，各自收集后再合并结果。例如可以同时计算平均值和总和。这对于需要一次遍历计算多个结果的情况很方便。</li></ul><h2 id="JVM-与垃圾回收"><a href="#JVM-与垃圾回收" class="headerlink" title="JVM 与垃圾回收"></a>JVM 与垃圾回收</h2><ul><li><strong>Shenandoah GC</strong>： 由 RedHat 开发的低停顿垃圾收集器 <strong>Shenandoah</strong> 在 Java 12 正式引入（实验性）。Shenandoah 的目标是无论堆多大，GC 停顿都在10ms以内，它通过并发压缩来实现低停顿。Shenandoah 与 ZGC 类似，都是面向低延迟场景，但 Shendandoah 更早在 JDK 8u 上投入生产使用。对主要使用 OpenJDK 8 的企业来说，Shenandoah 提供了一个升级路径。启用参数为<code>-XX:+UseShenandoahGC</code>。</li><li><strong>G1 优化</strong>： Java 12 对默认 GC G1 进行了一些改进。其中包括 JEP 344：可中止的混合收集，使 G1 在达到暂停目标时可以提前终止当前垃圾收集循环；以及 JEP 346：空闲时取消分配堆内存，使 G1 在应用空闲时将未使用的堆内存返还给操作系统。这些改进进一步降低了 G1 的延迟并提高内存使用效率，对于长时间运行且内存使用波动的应用有帮助。</li></ul><h2 id="工具和其他-1"><a href="#工具和其他-1" class="headerlink" title="工具和其他"></a>工具和其他</h2><ul><li>**Microbenchmark Harness (试验)**： Java 12 引入了一个基于 Java 的微基准测试框架（JEP 230），方便进行性能测试。但普通开发者接触较少，该框架事实上就是后来广泛使用的 JMH（Java Microbenchmark Harness）的基础。</li><li><strong>JVM 常量 API</strong>： 提供了一套新的 <code>java.lang.invoke.ConstantBootstraps API</code>，用于在字节码中加载动态常量（JEP 309，在Java 11预览，在Java 12正式）。这对语言实现者或框架来说有用，可以更灵活地处理常量池。</li></ul><p><strong>总结</strong>： Java 12 属于过渡版本，但预示了Java语言几个重要演进方向：Switch表达式和模式匹配都是为了让Java语法更简洁、更强大（这些特性在后续版本陆续定型)。核心库的小改进（字符串indent/transform等）贴近开发者需求，让日常编码更高效。Shenandoah GC 等则体现了 Java 在 GC 领域的持续创新，和 ZGC 一起为低延迟场景提供了解决方案。虽然变化不如大版本明显，但Java 12为后来的Java 13、14继续迭代打下了基础。</p><h1 id="Java-13-新特性"><a href="#Java-13-新特性" class="headerlink" title="Java 13 新特性"></a>Java 13 新特性</h1><p><strong>发行时间</strong>： 2019 年 9 月</p><h2 id="语言特性（预览）-1"><a href="#语言特性（预览）-1" class="headerlink" title="语言特性（预览）"></a>语言特性（预览）</h2><ul><li><strong>文本块 Text Blocks (预览)**： Java 13 引入了</strong>文本块**作为预览特性。文本块使用三重引号 <code>&quot;&quot;&quot;</code> 包围多行字符串文字，支持保持代码中的排版格式，大大简化了多行字符串的书写。例如，以往我们需要：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;  \&quot;name\&quot;: \&quot;Alice\&quot;,\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;  \&quot;age\&quot;: 25\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&#125;\n&quot;</span>;</span><br></pre></td></tr></table></figure>有了文本块，我们可以写成：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              &#123;</span></span><br><span class="line"><span class="string">                  &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class="line"><span class="string">                  &quot;age&quot;: 25</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>以上文本块会自动包含换行符和缩进空格，使字符串内容看起来与源码格式一致。Java 13 的文本块还引入了两个新的转义序列：<code>\</code> 作为行结尾时表示忽略改行（连接行）、<code>\s</code> 表示空格。文本块显著提高了编写 JSON、HTML、正则、多行日志等字符串的可读性 <strong>（优点）</strong>，避免繁琐的换行符拼接和转义。需要注意文本块会保留缩进，可以用 later Java 14+的 <code>stripIndent()</code>方法去除多余缩进。Text Blocks 在Java15转正成为正式特性。</li><li><strong>Switch 表达式第二次预览</strong>： Java 13 对上一版的Switch表达式进行了改进，主要是引入了 <code>yield</code> 关键字来返回值而不是使用<code>break</code>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MON, TUE, WED, THU, FRI:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;Workday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> SAT, SUN:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;Weekend&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;Invalid&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在Java 12中，使用的是 <code>-&gt;</code> 箭头和直接返回值或者<code>break value</code>形式；Java 13统一改用<code>yield</code>关键字提高一致性。这个版本的Switch表达式依旧是预览，直到Java 14才正式定型。</li></ul><h2 id="核心库与其他"><a href="#核心库与其他" class="headerlink" title="核心库与其他"></a>核心库与其他</h2><ul><li><strong>ZGC 改进</strong>： Java 13 改善了ZGC，让其在空闲时能够将未使用的堆内存归还操作系统。这解决了之前ZGC不会释放堆的问题，更加“吝啬”地占用内存，从而降低应用的内存足迹。这对容器环境非常有用，当应用内存需求下降时可以把内存还给系统。</li><li><strong>Socket API 重构</strong>： Java 13 底层重写了传统 <strong>Socket 实现</strong>，引入 <code>NioSocketImpl</code> 取代旧的 <code>PlainSocketImpl</code>。新的实现使用更现代的机制（如基于 <code>java.util.concurrent</code> 的锁），提高了并发性能和可维护性。旧实现如有需要仍可通过系统属性切换回去（<code>-Djdk.net.usePlainSocketImpl=true</code>）。<strong>应用场景</strong>： 绝大部分应用无需关注此更改，但套接字通信的稳定性和性能都会从中受益。</li><li><strong>文件系统API新方法</strong>：在 <code>java.nio.file.FileSystems</code> 类中增加了简化从文件创建内存文件系统的几个 <code>newFileSystem(Path, ...)</code> 工厂方法。这允许开发者更方便地将 Zip 等文件当作文件系统来操作。这对需要浏览压缩包内容或特殊文件容器的场景更便利。</li><li><strong>动态 CDS 归档</strong>： Java 13 延伸了在Java 10引入的AppCDS功能，加入了<strong>动态类数据归档</strong>能力。现在不需要提前试跑生成类列表，可以在应用退出时由 JVM 动态地将加载的应用类归档保存。下次启动时读取这个归档即可。这提高了 AppCDS 的易用性，无需人为干预生成类列表 <strong>（优点）</strong>，让更多应用能够直接受益于共享类数据带来的启动性能提升。</li></ul><h2 id="工具和移除"><a href="#工具和移除" class="headerlink" title="工具和移除"></a>工具和移除</h2><ul><li><strong>JDK 13 没有大的工具变化</strong>。值得注意的是，从JDK 13开始，Java不再内置部署栈（Java Web Start在JDK 11就移除，Applet在JDK 11弃用），所以在桌面和浏览器部署方面Java逐渐淡出，更多聚焦在后端和嵌入式场景。</li></ul><p><strong>总结</strong>： Java 13 延续了预览新特性的打磨，文本块让多行字符串处理在Java中首次变得愉悦；Switch表达式朝着最终定稿又迈进一步。虽然没有正式定稿的新语法，但这些预览特性在社区中引起了极大兴趣。底层方面，Socket API 的重构和ZGC的完善提高了性能和资源利用率。Java 13 的新特性数量相对不多，但“麻雀虽小五脏俱全”，为随后Java 14的大量新功能铺垫了环境。</p><h1 id="Java-14-新特性"><a href="#Java-14-新特性" class="headerlink" title="Java 14 新特性"></a>Java 14 新特性</h1><p><strong>发行时间</strong>： 2020 年 3 月</p><h2 id="JVM-改进"><a href="#JVM-改进" class="headerlink" title="JVM 改进"></a>JVM 改进</h2><ul><li><strong>空指针异常详细提示</strong>： Java 14 对长期困扰开发者的 NullPointerException进行了改进。当发生NPE时，错误信息现在会指出<strong>具体哪个变量为空</strong>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 a、b 可能为空</span></span><br><span class="line">a.b.c.i = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>之前的异常信息只是 “NullPointerException at … 第5行”，现在则会提示类似 “Cannot read field ‘c’ because ‘a.b’ is null”。这个更详尽的消息让开发者立刻知道空指针的原因，大幅减少了排查时间 <strong>（优点）</strong>。该功能通过 JVM 参数 <code>-XX:+ShowCodeDetailsInExceptionMessages</code> 打开（在Java 14中默认关闭，在Java 15中成为默认开启）。</li></ul><h2 id="语言特性-3"><a href="#语言特性-3" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>Switch 表达式正式推出</strong>： 经过两个版本的预览，<strong>增强型 switch</strong> 在 Java 14 正式成为 Java 语言的一部分。现在无需任何预览标志，就可以使用前述的箭头语法和 <code>yield</code> 来编写 switch 表达式了。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;M&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;F&quot;</span> -&gt; <span class="string">&quot;MWF&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;T&quot;</span>, <span class="string">&quot;TH&quot;</span>, <span class="string">&quot;S&quot;</span> -&gt; <span class="string">&quot;TTS&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(day.isEmpty()) <span class="keyword">yield</span> <span class="string">&quot;Please insert a valid day.&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">yield</span> <span class="string">&quot;Looks like a Sunday.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(label);</span><br></pre></td></tr></table></figure>在这个例子里，多个 case 可以用逗号合并（如 “M”, “W”, “F”），<code>default</code> 分支里演示了多语句块如何使用 <code>yield</code> 返回值。Switch 表达式相比传统 switch 简洁且更安全，避免了遗忘 break 的错误。它还能直接用作表达式赋值或返回，大大增强了 Java 表达能力。</li><li><strong>Records（预览）</strong>： Java 14 引入了一种全新的类型声明：<strong>记录类</strong>（Record），作为预览特性。Record是一种<strong>浅不可变</strong>的数据载体类，它可以用简洁的语法声明，不必编写样板代码。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>编译器将为 <code>Point</code> 自动生成构造器、<code>x()</code>/<code>y()</code>访问器方法、<code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code>。所有字段默认是 <code>private final</code>，Record类自身被隐式声明为 <code>final</code>（不可子类化）。Record非常适合表示纯数据，如坐标点、范围、DTO等。它极大减少了冗余代码，提高了可读性，相当于Java内置了 Lombok 的 <code>@Data</code> 功能。<strong>应用场景</strong>： 用于值对象，特别是在API间传输数据的时候，使代码更简洁清晰。Record 在Java 16成为正式特性。</li><li><strong>文本块（第二次预览）</strong>： 文本块在Java 14继续预览，引入了新的转义：<code>\</code>（行尾忽略换行）和 <code>\s</code>（显式空格）。这些在Java 13就已加入预览。Java 14文本块的主要变化是针对前一轮反馈进行调整，比如结尾处的换行处理等。总之，文本块在这一版依然是预览，但已经相当成熟，最终在Java 15转正。</li><li><strong>instanceof 模式匹配（第二次预览）</strong>： Java 14 中，instanceof 模式匹配作为预览再次出现，没有语法变化，仅继续收集反馈。开发者已可熟练使用 <code>if(obj instanceof Type var)</code> 这种写法，直到Java 16成为正式特性。</li></ul><h2 id="核心库和工具"><a href="#核心库和工具" class="headerlink" title="核心库和工具"></a>核心库和工具</h2><ul><li><strong>移除过时的CMS GC</strong>： 并发标记清除（CMS）垃圾收集器自Java 9起弃用后，终于在Java 14中<strong>移除</strong>。CMS 曾经是低停顿GC的主力，但有新一代的G1、Shenandoah、ZGC替代。移除CMS可以减轻维护负担。对于仍在使用CMS的应用，需要转向其他GC（通常转G1）。</li><li><strong>ZGC 扩展到 macOS/Windows</strong>： Java 14 将ZGC从仅支持Linux扩展到了 macOS 和 Windows 平台。这意味着更多用户可以在各种主流系统上试验ZGC的低延迟特性 <strong>（优点）</strong>。也标志着ZGC逐渐成熟，不再局限于单一平台。</li><li><strong>jpackage 工具（孵化）</strong>： 提供了 <code>jpackage</code> 工具的早期版本，可将Java应用打包成原生安装包（exe、msi、pkg、deb等）。这对于需要交付桌面应用的场景很有价值，开发者可以直接生成包含运行时的安装程序。jpackage 在JDK 16转为正式。</li></ul><h2 id="安全和其他"><a href="#安全和其他" class="headerlink" title="安全和其他"></a>安全和其他</h2><ul><li><strong>Edwards-Curve 数字签名算法</strong>： Java 15（而非14）才加入EdDSA，但在Java 14时已在着手了。Java 14主要安全改进体现在对TLS、加密库的细节修复，没有显著的API变化。</li></ul><p><strong>总结</strong>： Java 14 是一个内容相当丰富的版本。<strong>Switch表达式</strong>终于定型、<strong>记录类</strong>和<strong>模式匹配</strong>开始崭露头角。这些语言层面的增强让Java变得更简洁和富有表达力，逐步摆脱“样板代码多”的诟病。尽管Record和模式匹配仍是预览，但开发者已经可以尝鲜感受到它们的魅力。核心库方面，本版本改动不大，但像文本块等继续改进。JVM则在整理历史包袱（移除CMS）和推广新GC（ZGC跨平台）上迈进。总的来说，Java 14标志着Java语言在保持稳定性的同时，开始大胆引入新语法，为现代应用需求提供更优雅的解决方案。</p><h1 id="Java-15-新特性"><a href="#Java-15-新特性" class="headerlink" title="Java 15 新特性"></a>Java 15 新特性</h1><p><strong>发行时间</strong>： 2020 年 9 月</p><h2 id="核心语言特性"><a href="#核心语言特性" class="headerlink" title="核心语言特性"></a>核心语言特性</h2><ul><li><strong>文本块正式发布</strong>： 经过两次预览，<strong>Text Blocks</strong> 在 Java 15 成为正式特性。现在多行字符串文字可以不加任何标志直接在代码中使用三重引号表示。与预览阶段相比，Java 15 的文本块已经非常稳定，之前提到的 <code>stripIndent()</code>、<code>translateEscapes()</code> 等辅助方法也都正式随之提供。</li><li><strong>密封类（预览）</strong>： Java 15 引入了 <strong>密封类</strong> 和 <strong>密封接口</strong>（Sealed Classes）作为预览特性。密封类允许开发者限制哪些子类可以继承它。使用 <code>sealed</code> 修饰类，并在类声明后使用 <code>permits 子类列表</code> 来显式列出允许继承的子类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">permits</span> Employee, Manager &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>在上例中，<code>Person</code> 这个密封类只允许有 <code>Employee</code> 和 <code>Manager</code> 两个子类。而这两个子类必须要么声明为 <code>final</code> 完全封闭继承（如Employee），要么继续声明为 <code>sealed</code>（列出下一层许可继承），或者声明为 <code>non-sealed</code> 表示开放继承（如Manager，不再受限制）。密封类的好处是可以严格限定继承层次，确保代码覆盖时知道所有可能的子类，有助于模式匹配等特性的穷尽性检查。<strong>应用场景</strong>： 枚举类型的扩展，当枚举不适用时，可以用密封类+模式匹配代替；或者框架定义接口只允许特定实现等。密封类提高了系统建模的精确性。它在Java 17正式成为语言特性。</li><li><strong>隐藏类（Hidden Classes）</strong>： Java 15 加入了一种专门面向框架、JVM内部使用的类加载功能：Hidden Classes。隐藏类是一些在运行时动态生成的类，它们不可见于外部，也不能通过普通反射获取，主要用于字节码框架生成代理类、动态语言实现等场景。使用 MethodHandles.Lookup 定义隐藏类后，可避免污染应用的类命名空间。普通应用开发者可能感觉不到这个特性，但像动态代理、GraalVM多语言支持都会受益于此，更加安全。</li></ul><h2 id="核心库与安全"><a href="#核心库与安全" class="headerlink" title="核心库与安全"></a>核心库与安全</h2><ul><li>**新增 CharSequence.isEmpty()**： 在 Java 15，<code>CharSequence</code> 接口添加了默认方法 <code>isEmpty()</code>。这使得所有实现了 CharSequence 的类（包括 String、StringBuilder等）都自动拥有了 <code>isEmpty()</code> 方法。以往我们只能用 <code>seq.length() == 0</code> 判断，现在调用更直观。类似地，<code>Collection</code>接口早有 <code>isEmpty()</code> 方法，如今字符串序列接口也统一了这个用法。</li><li><strong>增强 TreeMap</strong>： Java 15 为 <code>java.util.TreeMap</code> 增补了多个常用方法：<code>putIfAbsent</code>, <code>computeIfAbsent</code>, <code>computeIfPresent</code>, <code>compute</code>, <code>merge</code>。过去这些方法只在 <code>HashMap</code> 等中有，实现为直接调用这些接口的默认实现，现在 TreeMap 提供了自身优化实现。这使得使用 TreeMap 时也能方便地进行条件插入和合并操作，Collections API 更加一致。</li><li><strong>新的数字签名算法 EdDSA</strong>： Java 15 实现了 Edwards-Curve 数字签名算法（EdDSA）。它是一种现代的椭圆曲线签名方案，相比 ECDSA 算法，性能更好且安全性高（抗强力破解能力强）。Java 15 内置支持 Ed25519 和 Ed448 曲线，可以通过 <code>&quot;Ed25519&quot;</code> 算法名称使用。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KeyPairGenerator</span> <span class="variable">kpg</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;Ed25519&quot;</span>);</span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">kp</span> <span class="operator">=</span> kpg.generateKeyPair();</span><br><span class="line"><span class="type">Signature</span> <span class="variable">sig</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;Ed25519&quot;</span>);</span><br><span class="line">sig.initSign(kp.getPrivate());</span><br><span class="line">sig.update(data);</span><br><span class="line"><span class="type">byte</span>[] signature = sig.sign();</span><br></pre></td></tr></table></figure>这将产生一个 Ed25519 签名。EdDSA 的加入让Java标准库紧跟加密领域前沿，为需要高性能签名（如区块链、JWT）的应用提供了新选择。</li></ul><h2 id="JVM-和性能-1"><a href="#JVM-和性能-1" class="headerlink" title="JVM 和性能"></a>JVM 和性能</h2><ul><li><strong>ZGC 转正</strong>： ZGC 在 Java 15 终于结束了实验状态，变为生产可用的垃圾收集器。虽然默认GC仍是G1，但现在可以放心地在生产环境使用ZGC（通过<code>-XX:+UseZGC</code>启用）来获取低延迟优势。同时，Java 15 的ZGC已支持多平台并修复了早期问题，日趋成熟。应用场景： 针对超低延迟要求的服务或大内存应用，可以考虑尝试ZGC并调优。需要注意的是，ZGC此时仍非默认，意味对普通场景还是G1更通用，而ZGC提供特殊场景选项。</li><li><strong>弃用 Nashorn</strong>： Java 15 正式移除了 Nashorn JavaScript 引擎（在Java 11就标记了弃用）。由于JavaScript流行生态(如Node.js)已在JVM之外发展成熟，Nashorn的使用率和维护价值下降。今后在JVM内运行JS需要使用独立项目（如GraalJS）。这提醒开发者：内嵌脚本功能应逐步迁移到新的解决方案上。</li></ul><h2 id="预览-非正式特性"><a href="#预览-非正式特性" class="headerlink" title="预览/非正式特性"></a>预览/非正式特性</h2><ul><li><strong>记录类第二次预览</strong>： Record 在 Java 15 继续预览，做了一些改进比如允许局部类中定义Record等。语法基本维持不变，为最终转正做最后准备。</li><li><strong>模式匹配 instanceof 第二次预览</strong>： 也基本保持不变，只收集更多使用反馈。</li></ul><p><strong>总结</strong>： Java 15 虽然是短期版本，但特性相当丰富。<strong>文本块</strong>在这一版终于尘埃落定，使多行字符串处理不再繁琐。<strong>密封类</strong>的引入让Java的类型系统更加强大，配合记录类、pattern matching，Java正朝着模式匹配和代数数据类型的方向迈进。库方面小幅增强了集合、字符序列、密码学算法。ZGC成熟和Nashorn移除则反映了JVM内部技术迭代。对于开发者来说，Java 15 提供了更多工具来编写简洁、安全、高性能的代码，是一款值得关注的版本。</p><h1 id="Java-16-新特性"><a href="#Java-16-新特性" class="headerlink" title="Java 16 新特性"></a>Java 16 新特性</h1><p><strong>发行时间</strong>： 2021 年 3 月</p><h2 id="语言特性-4"><a href="#语言特性-4" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>Records（记录类）正式发布</strong>： Java 16 将<strong>记录类</strong>从预览转为正式特性。开发者可以不用任何额外开关，直接使用 <code>record</code> 关键字定义不可变数据类。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>编译器自动生成构造器、getter（以字段名为方法名）、<code>equals/hashCode</code>、<code>toString</code> 等。相比Java中的普通类，Record极大减少了样板代码，并且语义明确地表示这是一个值类型。值得注意的是，Java 16 对Record作了一些调整：允许<strong>内部类</strong>定义Record，并支持在接口中定义静态Record嵌套类等。<strong>应用场景</strong>： Record非常适合作为数据传输对象（DTO）、只读配置类等。例如在 Spring MVC 中，一个请求的响应可以直接用Record来建模，由于其自带<code>toString</code>/<code>equals</code>，打印日志和比较都方便许多。大量原本需写构造器和getter的类现在一行就搞定，开发效率和代码可读性大幅提升。</li><li><strong>模式匹配的 instanceof 正式发布</strong>： Java 16 将前几版预览的 <strong>instanceof 模式匹配</strong> 特性定型发布。现在，<code>if (obj instanceof String s)</code> 成为正式语法，<code>s</code> 变量的作用域在该 <code>if</code> 分支内有效，类型自动转换为 String。与预览版相比，唯一语义改动是模式变量不再隐式是 <code>final</code> 的（Java 16 起可以修改 <code>s</code> 的引用）。<strong>应用场景</strong>： 几乎所有需要类型检查再强转的地方都能用这特性简化。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer data) &#123;</span><br><span class="line">    System.out.println(data + <span class="number">1</span>); <span class="comment">// 直接使用 data，无需强转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>省去了典型的模板代码，提高了代码安全性（不易出错）和可读性。</li><li><strong>密封类第二次预览</strong>： Java 16 再次提供了 sealed classes 的预览，主要改进了编译器对于密封继承关系的一些检查，更加严格地确保密封约束。语法层面与Java 15类似。该特性在Java 17成为正式。</li></ul><h2 id="核心库增强-4"><a href="#核心库增强-4" class="headerlink" title="核心库增强"></a>核心库增强</h2><ul><li><strong>Vector API (孵化)**： Java 16 引入了一个全新的孵化模块 —— **向量API</strong>。它提供了在Java代码中使用 SIMD 指令进行向量化计算的能力，可显著提升数据并行处理性能。Vector API 以 <code>jdk.incubator.vector</code> 模块提供，包含向量算术、掩码操作等。示例：使用 Vector API 计算两个浮点数组和：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FloatVector</span> <span class="variable">v1</span> <span class="operator">=</span> FloatVector.fromArray(FloatVector.SPECIES_256, arr1, <span class="number">0</span>);</span><br><span class="line"><span class="type">FloatVector</span> <span class="variable">v2</span> <span class="operator">=</span> FloatVector.fromArray(FloatVector.SPECIES_256, arr2, <span class="number">0</span>);</span><br><span class="line"><span class="type">FloatVector</span> <span class="variable">vSum</span> <span class="operator">=</span> v1.add(v2);</span><br><span class="line">vSum.intoArray(result, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>这利用CPU的SIMD指令实现了并行加法。虽然Vector API 对一般应用不是直接可见的变化，但对数值计算、高性能应用来说是个重要工具。它在Java 20已孵化到第5次。</li><li><strong>Foreign Memory Access API (孵化)**： 继Java 14/15 的外部函数API探索后，Java 16 提供了 **外部内存访问 API</strong> 的第三次孵化。这个 API 提供了安全访问堆外内存的方法，包括 <code>MemorySegment</code>（表示一段内存）和 <code>MemoryAddress</code> 等。与 JNI 不同，它完全在 Java 层面操纵内存，受语言安全检查，可替代 <code>sun.misc.Unsafe</code> 的很多用途。在Java 16，此API仍需加入<code>--add-modules jdk.incubator.foreign</code>使用，但它是 Project Panama 的一部分，最终在Java 17预览、Java 19预览，Java 21正式推出 (JEP 442)。<strong>应用场景</strong>： 需要与本地内存交互的高性能代码，如调用本地数据库缓存、跨语言共享内存等，可以使用该API避免C代码，提升安全性和开发效率。</li><li><strong>JDK 内部 API 强封装</strong>： Java 16 开启了对<strong>内部API强封装</strong> 的最后一步。早在Java 9模块化时，JDK内部非导出包就不对外开放，但当时提供了 <code>--illegal-access=permit</code> 默认打开非法访问用于兼容旧程序。Java 16 中，这个默认变成 <code>deny</code>，即默认完全禁止不合法的反射访问内部API（如 <code>sun.*</code> 包），曾经的警告现在变成报错。这可能导致旧库在未调整下无法运行，需要开发者明确使用 <code>--add-opens</code> 打开特定内部包才能继续。这一步骤强调了使用标准API的重要性，也敦促生态完成向模块化的过渡。</li><li><strong>其它小改进</strong>：</li><li><ul><li><code>java.nio.channels</code> 包现在支持 <strong>Unix 域套接字</strong> 连接（JEP 380），包括在Windows上也能使用这种本地IPC通信。方便进程间高效通信。</li></ul></li><li><ul><li>新的 <code>java.net.InetAddress</code> 实现替换了旧的 Inet4Address<code>/</code>Inet6Address 双实现，使代码更简洁，DNS解析SPI（在Java 18实现）。</li></ul></li><li><ul><li>Stream API增加了 <code>Stream.toList()</code> 默认方法，这是个便利方法，效果等同于 <code>.collect(Collectors.toList())</code> 但返回不可修改列表。这样获取流结果更简洁。</li></ul></li></ul><h2 id="工具与-JVM"><a href="#工具与-JVM" class="headerlink" title="工具与 JVM"></a>工具与 JVM</h2><ul><li><strong>jpackage 工具正式发布</strong>： 之前孵化的 jpackage 在 Java 16 正式加入 <code>java.tool</code> 工具集。开发者现在可以用 jpackage 将应用打包为平台原生安装包，支持Windows的 msi/exe、macOS的 pkg、Linux的 deb/rpm 等。它还能将应用所需的模块一并打包（用jlink技术），让用户无需安装Java即可运行。<strong>应用场景</strong>： 制作桌面应用发行版时，jpackage一站式解决打包和自带JRE的问题，替代了过去需借助Install4j等第三方工具的局面。</li><li><strong>迁移至 Git/GitHub</strong>： Java 16 完成了 OpenJDK 源码从 Mercurial 仓库迁移到 Git/GitHub 的流程。这虽然对使用者无直接影响，但标志着Java社区融入更广泛的开源协作平台，降低了参与门槛，也加速了开发。比如现在可以方便地在GitHub浏览JDK源码、提交PR。</li><li><strong>Alpine/Linux AArch64 移植</strong>： Java 16 官方支持在 Alpine Linux（musl C库）以及 Windows/AArch64 平台上的运行。这意味着对轻量容器和 ARM 服务器的支持更完善。对于在这些环境部署Java应用，这是利好消息，比如可以直接使用OpenJDK 16跑在 Alpine 容器中而无需传统glibc兼容层。</li></ul><p><strong>总结</strong>： Java 16 是一个重要的<strong>过渡版本</strong>。它完成了若干预览特性的正化（Records, 模式匹配）和JDK内部重构（强封装），使Java语言和平台更加现代安全。记录类的加入改变了Java定义数据结构的习惯，大幅减少样板代码，受到开发者欢迎。与此同时，Java 16 在高性能计算领域布局：Vector API和外部内存API的孵化，为Java迈向系统编程领域铺平道路。对于一般开发者，Java 16的直接提升在于更简洁的代码和更一致的API，而对高级用户，则看到了Java在性能和底层操作上的野心。总的来说，Java 16继续平稳演进，为即将到来的下一个LTS版本(Java 17)做好了准备。</p><h1 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h1><p><strong>发行时间</strong>： 2021 年 9 月 14 日 （LTS长期支持版）</p><h2 id="语言特性-5"><a href="#语言特性-5" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>密封类（正式）</strong>： 继两轮预览后，<strong>Sealed Classes</strong>在Java 17正式成为语言特性。现在可以用 <code>sealed</code> 修饰类或接口，并用 <code>permits</code> 子句列出允许的子类/实现类。所有继承者必须是列出的类型，否则编译报错；而继承者本身也需显式声明为 <code>final</code>、<code>sealed</code> 或 <code>non-sealed</code>。密封类使得类层次结构变得<strong>封闭且可预测</strong>。<strong>应用场景</strong>：需要控制继承的场景，如安全框架只希望特定子类，否则抛错；或者用密封接口加模式匹配，可以在编译期检查匹配是否穷尽所有实现。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Rectangle, Square &#123; &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123; &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123; &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123; &#125;</span><br></pre></td></tr></table></figure>以上接口只有这三种实现，未来也不可能出现第4种，实现了逻辑上的完备性。</li><li><strong>Switch 模式匹配（预览）</strong>： Java 17 提供了 <strong>switch 的模式匹配</strong> 作为预览特性（JEP 406）。它扩展了 switch，可以直接对类型进行匹配。结合前述密封类，可以在 switch 的 case 中使用类型模式。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">        <span class="keyword">case</span> Circle c    -&gt; <span class="string">&quot;Circle radius=&quot;</span> + c.radius();</span><br><span class="line">        <span class="keyword">case</span> Rectangle r -&gt; <span class="string">&quot;Rectangle w=&quot;</span> + r.width();</span><br><span class="line">        <span class="keyword">case</span> Square sq   -&gt; <span class="string">&quot;Square side=&quot;</span> + sq.side();</span><br><span class="line">        <span class="keyword">default</span>          -&gt; <span class="string">&quot;Unknown shape&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个预览特性中，<code>switch</code> 的 case 可以是带变量的类型（如 <code>Circle c</code>），匹配成功则自动将 s 转型为对应类型绑定到 c。这是模式匹配在 switch 上的首次尝试。对于密封类，编译器还能检查 default 分支是否必要（如上例如穷尽所有子类，可省略default）。Switch模式匹配让多态处理更加简洁强大，不过该特性在Java 17仅预览，最终于Java 19正式发布。</li></ul><h2 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h2><ul><li><strong>增强的伪随机数生成器</strong>： Java 17 通过 JEP 356 引入了一系列新的 <strong>随机数生成器接口和实现</strong>。主要包括：</li><li><ul><li>新接口 <code>RandomGenerator</code> 统一了随机数类的抽象，<code>java.util.Random</code>、<code>SplittableRandom</code>、<code>ThreadLocalRandom</code> 都实现了该接口。</li></ul></li><li><ul><li>提供了多种新算法实现，如<code>Xoroshiro128Plus</code>, <code>SplitMix64</code>, <code>L128X256MixRandom</code> 等，放在 <code>java.util.random</code> 包下，它们各有特点，性能和随机质量较传统 Random 更好。</li></ul></li><li><ul><li>增加了<code>RandomGeneratorFactory</code>，可以枚举和创建不同算法的随机数生成器。<br><strong>应用场景</strong>： 科学计算、仿真、游戏等需要高质量随机数的领域，可以直接使用这些新实现。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomGenerator</span> <span class="variable">rand</span> <span class="operator">=</span> RandomGenerator.of(<span class="string">&quot;L128X256MixRandom&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rand.nextInt();</span><br></pre></td></tr></table></figure>这样获取的随机数在统计质量和速度上都会优于传统的 <code>java.util.Random</code>。此外统一的接口让代码更灵活，可以在不改变代码逻辑情况下切换不同生成器算法。</li></ul></li><li><strong>跨平台渲染管线</strong>： 针对 macOS 平台，JEP 382 引入了基于 Metal 的 Java 2D 渲染管线替代原先的 OpenGL 管线。这样在Apple弃用OpenGL后，Java的GUI渲染还能继续高效工作。这对使用 Swing/JavaFX 的桌面应用非常重要，不过对服务器开发无直接影响。</li><li><strong>弃用安全管理器</strong>： Java 17 将久未更新的 <strong>Security Manager</strong> 标记为弃用，将来版本中会移除（JEP 411）。安全管理器曾用于限制Java代码权限（沙箱机制），但由于设计过于复杂且很少使用，现在决定废弃。后续如果需要细粒度安全控制，会采用更现代的技术（如基于容器的隔离）。开发者需要注意，某些依赖安全管理器的库（例如一些老的测库或Applets相关代码）未来可能无法使用，需要及早寻找替代方案。<strong>Java 24 中已完全禁止启用Security Manager。</strong></li><li><strong>移除 RMI 激活机制</strong>： Java 17 删除了远程方法调用（RMI）中几乎不用的<strong>激活机制</strong>（JEP 407）。RMI Activation 允许远程对象按需启动，但现实中少有用到且存在维护成本，故予以删除。普通的RMI功能仍可用，不受影响。</li><li><strong>context-specific Deserialization Filters</strong>： 提供了针对反序列化过程的新过滤API（JEP 415），允许在特定上下文设置反序列化过滤规则，从而防御反序列化漏洞。比如可以针对某次ObjectInputStream限定可接受类的白名单，增强安全性。这对于开发需要反序列化不受信数据的应用非常重要，是Java安全加固的一部分。</li></ul><h2 id="性能与内部"><a href="#性能与内部" class="headerlink" title="性能与内部"></a>性能与内部</h2><ul><li><strong>永久性强封装 JDK 内部</strong>： 上文Java 16部分提到，Java 17 完成了内部 API 封装的最后工作，将非法反射访问默认禁止。因此许多以前打印警告的信息在Java 17下会直接报错退出。这要求各种框架升级以使用官方支持的API。例如ByteBuddy、cglib之类都已发布新版适配，否则可能无法在Java 17运行。如果遇到因无法访问<code>sun.misc</code>等内部类而报错，可通过<code>--add-opens</code>暂时开放对应模块包给相关库，但这只是过渡方案。</li><li><strong>移除实验性 AOT/JIT 编译器</strong>： Java 17移除了JDK 9引入的实验<strong>AOT编译器</strong>（jaotc）和<strong>JIT编译器Graal</strong>（JEP 410）。这些功能在实验阶段使用不广泛，并决定通过外部项目（如GraаlVM）继续发展，而不放在JDK中了。对大多数用户没有影响，因为默认HotSpot C1/C2编译器仍保留且性能良好。</li></ul><h2 id="适配与生态"><a href="#适配与生态" class="headerlink" title="适配与生态"></a>适配与生态</h2><p>作为LTS版本，Java 17 得到了各大框架和库的快速支持。Spring Boot 3 就要求最低Java 17运行。相较Java 11，Java 17的代码可读性更好（Record, Pattern Matching等）并且性能有所提升（如更好的GC选择和更优的随机数生成器）。迁移到Java 17需要注意以下：</p><ul><li>检查并替换对内部API的非法调用，或在启动脚本中加入对应<code>--add-opens</code>参数以保持兼容。</li><li>确认所用三方库已兼容Java 17（多数流行库如Netty、Spring等都已支持）。</li><li>充分利用新特性提升代码质量，如用Record代替冗长的POJO，密封类约束继承关系等。</li></ul><p><strong>总结</strong>： Java 17 是继Java 11之后的又一个长期支持版本，也是“现代Java”功能集的大成者。密封类、Record、Pattern Matching这些Java近年推出的语法糖在此全部稳固下来。它极大地提高了Java的开发效率和表达力，让Java代码更加简洁、类型更加安全可控。在JDK底层，Java 17 清理了许多历史遗留（如安全管理器、老的RMI子系统等），并优化了Randome API等基础库。对于计划长期使用的项目，Java 17 无疑是一个理想的选择。Java 17发布后，Java社区进入半年发布的新常态，但有了LTS保障，企业也能每隔几年来一次平滑升级以享受新特性红利。</p><h1 id="Java-18-新特性"><a href="#Java-18-新特性" class="headerlink" title="Java 18 新特性"></a>Java 18 新特性</h1><p><strong>发行时间</strong>： 2022 年 3 月</p><h2 id="平台与性能"><a href="#平台与性能" class="headerlink" title="平台与性能"></a>平台与性能</h2><ul><li><strong>默认字符集 UTF-8</strong>： Java 18 通过 JEP 400 将<strong>默认字符集</strong>统一为 UTF-8。之前，<code>Charset.defaultCharset()</code> 会根据操作系统locale返回本地编码（例如中文Windows通常是GBK），这可能导致跨平台不一致的问题。Java 18 起，无论在哪运行，默认Charset一律是UTF-8。这意味着不指定编码时（如使用 <code>FileReader</code> 默认构造）都以UTF-8读写文件。这对多语言应用、跨平台程序是重大利好，避免了常见的乱码问题 <strong>（优点）</strong>。但需要注意如果有程序依赖以前平台默认编码，需要显式指定回原编码，否则可能行为改变。</li><li><strong>简单的Web服务器</strong>： JDK 18 内置了一个简单的纯Java实现<strong>HTTP文件服务器</strong>。只需运行命令 <code>jwebserver</code> 即可在当前目录启动一个静态文件服务，默认监听本地8000端口。这个Web服务器仅支持静态文件，不支持CGI、Servlet等动态内容，但非常适合临时共享文件或前端开发进行快速测试。开发者也可以通过 API (<code>com.sun.net.httpserver.SimpleFileServer</code>) 在自己的应用中启动一个文件服务器实例。<strong>应用场景</strong>： 例如要快速查看某个HTML文件效果，只需 <code>jwebserver</code> 即可，不必安装额外软件。</li><li><strong>核心类重构（MethodHandle实现）</strong>： JEP 416 用 Method Handle 重写了 Java 核心反射的部分实现。原先诸如 <code>Class::forName</code>、<code>Method::invoke</code> 等底层由JVM C++代码处理，现在部分改由Java实现，以提升维护性和可能的性能。这一改动对开发者透明，行为没有变化，但体现出OpenJDK渐进用更高级方式优化底层的思路。</li></ul><h2 id="新特性和API"><a href="#新特性和API" class="headerlink" title="新特性和API"></a>新特性和API</h2><ul><li><strong>代码段（Snippet）标签 for JavaDoc</strong>： JEP 413 为 JavaDoc 文档引入了 <code>&lt;pre&gt;&lt;code&gt;</code> 风格的<strong>代码片段注释</strong>。开发者可以在注释中使用 ```java 标记和 <code>&#123;@snippet&#125;</code> 等标签来插入代码示例，JavaDoc 会自动高亮和编号这些代码。这比以前需要手工使用HTML <code>&lt;pre&gt;</code> 标记更方便，也减少了转义的麻烦。对于撰写API文档的开发者来说，这提高了文档可维护性和可读性。</li><li><strong>Vector API 第三次孵化</strong>： Java 18 中 Vector API 进入第3轮孵化。相比Java 16版有一些性能和API优化。依然需要<code>--add-modules jdk.incubator.vector</code>使用。值得一提的是，随着孵化次数增加，Vector API 正趋于成熟，目标是实现CPU SIMD指令可被Java程序员直接利用以获得本地性能。</li><li><strong>互联网地址解析 SPI</strong>： JEP 418 引入了一个可插拔的<strong>名称解析服务接口</strong>。这允许应用替换JDK默认的DNS解析器，例如使用自定义DNS服务器或实现特殊解析规则。对大多数应用而言用不到，但在一些网络隔离或自定义解析环境很有用，比如将Java应用的DNS解析定向到应用内部服务。</li><li><strong>外部函数 &amp; 内存 API 第二次孵化</strong>：Java 18 提供了Panama项目 <strong>Foreign Function &amp; Memory API</strong> 的第二版孵化 (JEP 419)。它包括 <code>MemorySegment</code>、<code>MemoryAddress</code>、<code>CLinker</code> 等，继续让Java可以更安全地访问本地内存并调用本地函数。和Java 17里的Incubator相比，这次孵化进一步完善了API设计。虽然仍非正式，但已经有不少开发者尝试用它调用本地C库而不用JNI。随着这一API的成熟，Java有望在后续版本里跨入系统编程领域，该API最终在Java 21正式发布。</li><li><strong>Switch 模式匹配第二次预览</strong>：跟随Java 17的首次预览，Java 18 的 JEP 420 给出了<strong>switch 模式匹配</strong>的第二次预览，实现上无大变化，只是根据反馈调整了一些细节。例如，在增强 Exhaustiveness（穷尽检查）方面有所改进。当使用密封类时，编译器能更好地确定是否需要 default 分支。这项特性最终在Java 19完成预览并在Java 21正式推出。</li><li><strong>弃用终结器 Finalization</strong>：虽然Java 9开始就不推荐使用 finalize() 方法做清理操作，但直到Java 18 才通过 JEP 421 正式将终结器标记为废弃以移除。未来的Java版本将彻底移除终结器机制，转而推荐 Cleaner 等更可靠的清理方式。终结器由于不可预知的执行时机和可能的性能、安全问题，一直被认为是不良实践，此举督促开发者尽早移除 finalize 的用法。</li></ul><h2 id="安全与密码"><a href="#安全与密码" class="headerlink" title="安全与密码"></a>安全与密码</h2><ul><li><strong>默认禁止弱算法</strong>： Java 18 在安全方面也做了一些更新，例如禁用了 TLS 1.0 和 1.1 协议默认支持、更严格的默认信任库等。这些变更虽不显著但体现了Java平台安全策略与时俱进。</li></ul><p><strong>总结</strong>： Java 18 新特性相对较少，而且很多是预览或孵化（Vector、外部内存、switch模式）。最大的“显性”变化对普通开发者来说莫过于<strong>默认编码UTF-8和内置简易Web服务器</strong>。UTF-8默认消除了长期以来跨平台编码不一致的问题，让Java更贴合互联网时代的数据交换标准。jwebserver则体现出Java对开发者体验的重视，即使是一个很小的工具，也能发挥作用。在底层性能上，Java 18 继续推进Panama和Vector等，使Java在系统编程和高性能计算上更具竞争力。作为非LTS版本，Java 18 提供了一个让社区试水新功能的平台，其反馈将作用于后续的Java 19和21中。</p><h1 id="Java-19-新特性"><a href="#Java-19-新特性" class="headerlink" title="Java 19 新特性"></a>Java 19 新特性</h1><p><strong>发行时间</strong>： 2022 年 9 月</p><h2 id="并发与虚拟线程"><a href="#并发与虚拟线程" class="headerlink" title="并发与虚拟线程"></a>并发与虚拟线程</h2><ul><li><strong>虚拟线程（预览）</strong>： Java 19 带来了备受期待的 <strong>虚拟线程</strong>（Virtual Threads）预览（JEP 425）。虚拟线程是由JVM管理的轻量级线程，实现了“纤程”的概念，每个虚拟线程由<strong>多个虚拟线程映射到一个OS线程</strong>执行，调度由JVM负责。创建虚拟线程的成本和内存占用都非常低，可以轻松创建数十万计线程而不会像平台线程那样耗尽资源<strong>（优点）</strong>。使用方式上，Java 19 提供了简化的 API，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟线程执行的代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello from a virtual thread&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>或通过 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 创建虚拟线程的执行器。对于IO阻塞操作，虚拟线程在等待时会让出底层OS线程，不会“固定”占用它。这意味着高并发IO场景下，使用虚拟线程可以大幅提升吞吐，而编程模型仍然是简单的同步代码，不需要使用复杂的Async框架。<strong>应用场景</strong>： 特别适合服务器端处理大量并发连接的场景（如Web服务器、聊天服务器），过去用线程池+异步，现在可以一请求一线程且线程数非常多却无明显性能损失。虚拟线程在Java 19为预览，需要 <code>--enable-preview</code> 开启，并在Java 21正式发布（JEP 444）。</li><li><strong>结构化并发（孵化）</strong>： 随着虚拟线程引入，Java 19 还孵化了 <strong>结构化并发 API</strong>（Structured Concurrency，JEP 428）。它提供 <code>StructuredTaskScope</code> 类，帮助把一组关联的任务提交到多个线程并汇总结果，方便以结构化的方式启动并行操作并在作用域结束时自动管理线程生命周期。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">    Future&lt;String&gt; user = scope.fork(() -&gt; fetchUser());</span><br><span class="line">    Future&lt;String&gt; order = scope.fork(() -&gt; fetchOrder());</span><br><span class="line">    scope.join();           <span class="comment">// 等待所有任务完成</span></span><br><span class="line">    scope.throwIfFailed();  <span class="comment">// 若有任务异常则抛出</span></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> user.resultNow();</span><br><span class="line">    <span class="type">String</span> <span class="variable">orderInfo</span> <span class="operator">=</span> order.resultNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样的模式使得并行任务像局部代码块一样管理，有助于避免遗留线程无法控制的问题。这一API仍在孵化阶段（需显式加入 <code>jdk.incubator.concurrent</code>），最终目标是简化多线程代码的组织，提高可维护性。</li></ul><h2 id="语言和模式匹配"><a href="#语言和模式匹配" class="headerlink" title="语言和模式匹配"></a>语言和模式匹配</h2><ul><li><strong>记录模式（预览）</strong>： Java 19 引入 <strong>Record Patterns</strong> 预览（JEP 405）。它允许在模式匹配中对 <strong>记录类</strong> 进行解构。比如有记录类 <code>Point(int x, int y)</code>，可以这样匹配：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot;, y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里<code>instanceof Point(int x, int y)</code> 就是记录模式，它不仅判断 obj 是否为 Point，还进一步将内部的 x,y 解构出来赋给新的局部变量。Record Patterns 还可以嵌套使用，用于复杂结构的匹配。<strong>应用场景</strong>： 配合密封类和switch，可以用非常简洁的代码处理递归数据结构或组合数据。例如匹配一个包含两个点的 Line 记录：<code>case Line(Point(int x1, int y1), Point(int x2, int y2)) -&gt; ...</code>。记录模式在Java 19为预览，Java 20进行了第二次预览，Java 21正式发布。</li><li><strong>Switch 模式匹配第三次预览</strong>： Java 19的switch模式匹配（JEP 427）进入第3轮预览。此次主要是与record模式更好地联动。例如可以在switch的case中使用记录模式、类型模式等组合匹配。此外，它根据之前反馈调整了一些细节，如guarded patterns的语法。总之，Java 19 的 switch 模式匹配已经相当成熟，为Java 21的正式上线奠定了基础。</li></ul><h2 id="外部接口和内存"><a href="#外部接口和内存" class="headerlink" title="外部接口和内存"></a>外部接口和内存</h2><ul><li><strong>外部函数与内存 API（预览）</strong>： 前述Panama项目在Java 19终于进入预览阶段（JEP 424），意味着<code>Foreign Function &amp; Memory API</code>可不带孵化模块直接使用（需启用预览）。它包括：</li><li><ul><li> <code>MemorySegment</code>/<code>MemoryAddress</code>：操作本地内存。</li></ul></li><li><ul><li><code>CLinker</code>：用于链接C语言函数，支持将Java方法转换为函数指针、将本地函数符号加载为MethodHandle等。</li></ul></li><li><ul><li><code>SegmentAllocator</code>：方便分配本地内存段。<br>通过这套API，Java 程序可以高效、类型安全地调用本地C函数和读写本地内存，不必使用JNI。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CLinker</span> <span class="variable">linker</span> <span class="operator">=</span> CLinker.systemCLinker();</span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">strlen</span> <span class="operator">=</span> linker.downcallHandle(</span><br><span class="line">        linker.lookup(<span class="string">&quot;strlen&quot;</span>).get(), </span><br><span class="line">        FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)</span><br><span class="line">);</span><br><span class="line"><span class="type">MemorySegment</span> <span class="variable">cString</span> <span class="operator">=</span> CLinker.toCString(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">long</span>) strlen.invokeExact(cString.address());</span><br></pre></td></tr></table></figure>以上代码通过 CLinker 调用标准C函数 <code>strlen</code> 计算字符串长度。可以看到没有一行JNI代码，全部在Java中完成。这个特性对于需要和C库交互的应用来说极为便利 <strong>（优点）</strong>，性能也与JNI相当。经过Java 19、20两轮预览，最终在Java 21正式发布 (JEP 442)。</li></ul></li></ul><h2 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h2><ul><li><strong>虚拟线程Pinning问题优化</strong>： Java 19 虚拟线程预览中已经实现了当虚拟线程在 <code>synchronized</code> 块中等待时，不会阻塞底层OS线程，可以提升并发度。不过更完善的非Pinning设计在Java 24（JEP 491）才完成。Java 19作为预览已经展示了虚拟线程良好的调度特性。</li><li><strong>Linux/RISC-V 移植</strong>： JEP 422 将OpenJDK移植到了Linux/RISC-V架构上。这对国内自主硬件生态是个好消息，Java可以运行在RISC-V服务器/设备上了。</li></ul><p><strong>总结</strong>： Java 19是一个亮点颇多的版本。<strong>虚拟线程</strong>的初次亮相标志着Java并发模型迎来巨大变革；<strong>结构化并发</strong>、<strong>记录模式</strong> 等则完善了并发和模式匹配的语法，使得Java代码能够写得更简洁清晰。外部函数/内存API的预览，则让Java开始真正涉足系统级编程。尽管这些重要特性多数仍在预览/孵化，但Java 19作为LTS之前的一个功能集合，已经让社区看到了Java未来的样子：<strong>高并发、高性能、强大的模式匹配和数据表达能力</strong>。对于愿意尝鲜的开发者，Java 19提供了极好的机会在实验环境试用这些新功能，并为迁移到Java 21LTS做技术准备。</p><h1 id="Java-20-新特性"><a href="#Java-20-新特性" class="headerlink" title="Java 20 新特性"></a>Java 20 新特性</h1><p><strong>发行时间</strong>： 2023 年 3 月</p><h2 id="项目-Loom-持续改进"><a href="#项目-Loom-持续改进" class="headerlink" title="项目 Loom 持续改进"></a>项目 Loom 持续改进</h2><ul><li><strong>虚拟线程第二次预览</strong>： Java 20 再次提供虚拟线程预览（JEP 436）。与Java 19相比改进了调试和JDK工具对虚拟线程的支持，并解决了一些bug。API基本不变。值得注意的是，结合虚拟线程的监控/分析工具也逐步更新，使得即使百万级线程的应用也能被有效诊断。Java 20 的虚拟线程已经非常接近最终形态（最终在Java 21正式推出）。</li><li><strong>结构化并发第二次孵化</strong>：Java 20 将结构化并发 API (StructuredTaskScope 等) 进行第二轮孵化（JEP 437）。本次主要是API调整和性能优化。开发者继续可以尝试用它来管理一组并行任务的范围，写出更整洁的并发代码。</li><li><strong>作用域值（孵化）</strong>： Java 20 引入了 <strong>Scoped Values</strong>（作用域值）孵化特性（JEP 429）。它提供了一种比 ThreadLocal 更安全高效的跨线程传递只读数据的方法。用 <code>ScopedValue</code> 可以将一个值绑定到当前线程（及其子线程）的动态作用域中，然后在这个作用域内的任意深度方法调用甚至新启动的线程中读取该值。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;String&gt; USER_ID = ScopedValue.newInstance();</span><br><span class="line"><span class="comment">// 在某作用域绑定 USER_ID</span></span><br><span class="line">ScopedValue.where(USER_ID, <span class="string">&quot;alice&quot;</span>).run(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 在作用域内的任意代码都可读取 USER_ID</span></span><br><span class="line">    processOrder();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> USER_ID.get();  <span class="comment">// 获取当前作用域绑定的值 &quot;alice&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>相比 ThreadLocal，ScopedValue 的生命周期和线程结构更加明确，不会发生内存泄漏，并且对于大量虚拟线程场景，访问开销也更小。它非常适合保存一些上下文信息（如当前用户ID、请求ID等），供调用链路下游使用而无需层层传参。ScopedValue 在Java 20孵化，Java 21再次预览（JEP 487 第四次预览），预计Java 22+正式推出。</li></ul><h2 id="模式匹配和类型系统"><a href="#模式匹配和类型系统" class="headerlink" title="模式匹配和类型系统"></a>模式匹配和类型系统</h2><ul><li><strong>记录模式第二次预览</strong>： Java 20 延续了 Java 19 的记录模式预览（JEP 432）。改进包括允许在 <code>instanceof</code> 之外，也能在增强的 <code>for</code> 循环、switch中使用记录模式，并一些语法细节调整。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Point</span><span class="params">(<span class="keyword">var</span> x, <span class="keyword">var</span> y)</span> p &amp;&amp; x == y) &#123; ... &#125;</span><br></pre></td></tr></table></figure>其中的 <code>(var x, var y)</code> 就是记录模式，使用了 var 来省略类型。记录模式的二次预览让它和其它模式（类型模式、常量模式）配合得更好。基本语法趋于稳定，为Java 21转正铺路。</li><li><strong>Switch 模式匹配第四次预览</strong>： 经过Java 17、18、19三次预览，Java 20 的 switch 模式匹配（JEP 433）进入第4次也应该是最后一次预览。这一版修复了一些角落情况并与记录模式整合。典型使用如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> Circle c               -&gt; handleCircle(c);</span><br><span class="line">    <span class="keyword">case</span> <span class="title function_">Rectangle</span><span class="params">(<span class="keyword">var</span> w, <span class="keyword">var</span> h)</span>-&gt; handleRect(w, h);</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>                   -&gt; handleNull();</span><br><span class="line">    <span class="keyword">default</span>                     -&gt; handleOther();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里既有类型模式（Circle）、又有记录模式（Rectangle解构），还有显式处理null的分支。Java 20 的预览几乎与最终版一致，之后Java 21正式推出时仅有极小调整。</li><li><strong>泛型实例推断改进（预览）</strong>： 虽然未在上文提及，但Java 20还预览了一个非常小的语法糖JEP 433的一部分：允许 <code>instanceof</code> 后的变量声明使用泛型实例。例如 <code>obj instanceof Box&lt;String&gt; b</code> 过去是不被允许的，现在作为预览可以。</li></ul><h2 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h2><ul><li><strong>外部函数 &amp; 内存 API 第二次预览</strong>： Java 20 将 Java 19 的外部函数/内存API (Panama) 进行第二次预览（JEP 434）。这次预览对API命名和组织作了一些修改，比如将 MemorySession 拆分为 Arena 和 SegmentScope 等。总体而言功能更完善，为最终定型做准备。Java 21 该API第三次预览，Java 22 正式发布 (JEP 454)。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>JDK 20 无长期支持版</strong>，生命周期只有6个月，因此没有特别重大的行为改变，更多是延续性改进和预览。值得一提的是 JDK 20 是 JDK 21（LTS）的前哨战，大部分Java 21的重磅功能（虚拟线程、模式匹配、FFM API等）都已在Java 20经过充分打磨。</li></ul><p><strong>总结</strong>： Java 20 在功能上和Java 19一脉相承，并无全新重量级特性亮相，但却将之前的创新推进到了最后阶段。<strong>虚拟线程</strong>更完善、<strong>结构化并发</strong>和<strong>作用域值</strong>为简化并发提供了全新思路；<strong>记录模式</strong>和<strong>switch模式</strong>几乎打磨成熟，为模式匹配全面落地做好准备。这些都预示了即将到来的Java 21将会是个非常强大的版本。因此对于期待LTS的开发者来说，Java 20 显得“波澜不惊”，但这正是暴风雨前的平静——所有新特性的铺垫都已就绪，等待在Java 21中释放。</p><h1 id="Java-21-新特性"><a href="#Java-21-新特性" class="headerlink" title="Java 21 新特性"></a>Java 21 新特性</h1><p><strong>发行时间</strong>： 2023 年 9 月 19 日 （LTS长期支持版）</p><p>Java 21 作为第5个LTS版本，融合了过去几版的预览特性，带来了<strong>15项新特性</strong>。这是一版里程碑式的发布，使Java在语法、并发、性能等方面迈上新台阶。</p><h2 id="语言特性-6"><a href="#语言特性-6" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><strong>字符串模板（预览）</strong>： Java 21 引入了<strong>字符串模板</strong>（String Templates）预览（JEP 430）。它提供类似其他语言的内嵌表达式的字符串字面量，用 <code>$&#123;...&#125;</code> 作为占位符，把变量值或表达式结果直接嵌入字符串中。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> STR.`Hello, $&#123;user&#125;! Your score is $&#123;score&#125;.`;</span><br><span class="line">System.out.println(msg); <span class="comment">// 输出: Hello, Bob! Your score is 42.</span></span><br></pre></td></tr></table></figure>使用时需在字符串前加 <code>STR</code>. 前缀来开启模板字符串字面量（这是预览期的语法要求）。模板中可以直接嵌入局部变量、字段、方法调用等。编译器会将模板转换为高效拼接代码，并可配合模板处理API进行高级用法（如SQL安全拼接等）。<strong>应用场景</strong>： 拼接字符串是最常见的需求，字符串模板让这件事变得安全又简单，再也不需大量引号加加号，也无需 <code>String.format</code> 的占位符，对新手友好、对老手高效。虽然Java 21为预览，需要 <code>--enable-preview</code>，但预计不久后转正，使Java终于拥抱与现代语言一致的字符串插值能力。</li><li><strong>记录模式 &amp; 模式匹配 for switch（正式）</strong>： <strong>Record Patterns</strong> 和 <strong>Pattern Matching for switch</strong> 在经历多次预览后，终于在 Java 21 正式发布（JEP 440, 441）。这意味着我们可以在 <code>instanceof</code> 和 <code>switch</code> 中自由使用类型模式和记录模式进行解构匹配，无需启用预览。</li></ul><p>记录模式允许匹配记录类并直接解构其组分，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shape <span class="keyword">instanceof</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;长方形面积:&quot;</span> + w*h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Switch模式匹配允许 switch 直接按类型/结构分支，例如结合密封类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> r)</span>        -&gt; System.out.println(<span class="string">&quot;圆面积:&quot;</span> + Math.PI*r*r);</span><br><span class="line">    <span class="keyword">case</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> -&gt; System.out.println(<span class="string">&quot;矩形面积:&quot;</span> + w*h);</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>                    -&gt; System.out.println(<span class="string">&quot;空形状&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>                      -&gt; System.out.println(<span class="string">&quot;未知形状&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>Circle(double r)</code> 是类型+变量模式，<code>Rectangle(int w, int h)</code> 是记录模式。由于 <code>Shape</code> 假设是密封接口，列举了所有子类，所以可以省略 default 或只用于 null 情况。<strong>应用场景</strong>： 模式匹配让 Java 处理复杂数据结构时如鱼得水。例如遍历一个 JSON 抽象语法树，不同节点类型（对象、数组、值）用 switch 匹配类型，既直观又安全。过去这些需要大量的 instanceof + 强转+if/else，而现在简洁明了。Java 21 的模式匹配使Java具备了代数数据类型模式匹配的威力，大大提高了代码可读性和可靠性。</p><ul><li><strong>未命名模式和变量（正式）</strong>： Java 21 正式引入了 <strong>未命名模式(_)</strong> 和 **未命名变量(_)**（JEP 443）。简单来说，就是引入了下划线 <code>_</code> 作为通配符，可在模式匹配中忽略不需要的部分，以及作为一种“匿名变量”用于标识暂时用不到的本地变量。这两个用途不同：</li><li><ul><li><strong>未命名模式</strong>： 在模式匹配（instanceof或switch的模式）中，用 <code>_</code> 表示“匹配任何，不使用该值”。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (point <span class="keyword">instanceof</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, _)</span>) &#123;  <span class="comment">// 只关心x，不在意y值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;x坐标:&quot;</span> + x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里第二个分量用了 <code>_</code>，表示匹配任何y而不绑定变量。这避免了像以前那样写一个无用的名字又不使用产生警告。</li></ul></li><li><ul><li><strong>未命名变量</strong>： 允许定义本地变量时用单个下划线作为名称，但这样的变量无法使用（编译器也不允许使用），只是为了占位。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">_</span> <span class="operator">=</span> computeHeavy();  <span class="comment">// 调用方法但不关心返回值，只是为了触发方法副作用</span></span><br></pre></td></tr></table></figure>定义了一个名为<code>_</code>的int变量，但后续无法引用它。这样做的意义在于清晰表达“我故意忽略这个返回值”。这种写法主要用于兼容需要变量语法但我们不需要实际变量的场景（类似 <code>_ = in.read()</code> 读而不处理）。另外，未命名变量只能定义一次，不能重复定义或和其他变量重名。</li></ul></li></ul><p><strong>应用场景</strong>： 未命名模式在复杂模式匹配时尤其实用，如果一个模式中有部分内容不关心，可以用 <code>_</code> 占位，使代码更简洁。未命名变量用得不多，但在调用返回值不需要的方法时可以表明意图。例如在测例中调用某初始化函数，只为触发内部逻辑，不关心结果，就可以 <code>Object _ = init()</code>;。需要注意，下划线作为关键字在这之前已不能当普通变量名使用，因此这项特性没有向后不兼容问题。</p><ul><li><strong>未命名类和实例 main 方法（预览）</strong>： Java 21 提供了一个有趣的预览特性 JEP 445：<strong>隐藏类名和实例主方法</strong>。它允许编写更简洁的单文件程序：可以省略类声明，直接写语句，甚至 <code>main</code> 方法也可以写成实例方法。具体来说：</li><li><ul><li>可以在源文件中不显式声明类，Java编译器会为顶层语句隐含定义一个类。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样写一个 <code>.java</code> 文件也能编译运行。编译器会自动包裹成 <code>class X &#123; void main() &#123;...&#125; &#125;</code> 形式并生成入口。</li></ul></li><li><ul><li>允许 <code>main</code> 方法定义为实例方法而非静态，并且类可以不命名（编译器生成类名）。甚至可直接写 <code>void main()&#123;&#125;</code> 顶格在文件开头，不用类和方法签名。例如上例已经展示，无需 <code>public static void main(String[] args)</code> 那么啰嗦。</li></ul></li></ul><p><strong>应用场景</strong>： 主要目的是降低初学者学习Java的门槛，以及让脚本式的小程序更简洁。过去新手写HelloWorld，一上来就要理解类、静态方法、字符串数组，对入门不友好。有了这个预览特性，可以更像脚本语言一样直接写代码执行。当然，这只是源代码层面的语法糖，实际编译还是会生成类。这个特性也显示了Java追求更“轻量”的一面。不过在大型项目中，还是会明确定义类和main，未命名类更多用于教学、快速脚本等场景。它在Java 21为预览，要启用预览才能使用。</p><h2 id="并发和虚拟线程"><a href="#并发和虚拟线程" class="headerlink" title="并发和虚拟线程"></a>并发和虚拟线程</h2><ul><li><strong>虚拟线程正式发布</strong>： Java 21 通过 JEP 444 将 <strong>虚拟线程</strong> (Virtual Threads) 定稿发布！这意味着不需任何标志，就可以在生产中使用 Project Loom 带来的虚拟线程能力了。从此，Java 有了两种线程：平台线程（传统操作系统线程）和虚拟线程（由JVM调度）。虚拟线程的使用方式和之前预览一致，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 虚拟线程执行代码 ...</span></span><br><span class="line">&#125;);</span><br><span class="line">vt.join();</span><br></pre></td></tr></table></figure>或通过 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 来大量提交任务。虚拟线程的调度、同步都与普通线程一致，支持ThreadLocal、锁等，只是代价极低，可以创建百万级。<strong>应用场景</strong>： 几乎所有并发服务器负载都可以考虑迁移到虚拟线程模型。例如基于Spring、Tomcat的Web应用，可配置使用虚拟线程的执行器，每请求一个虚拟线程处理，简化复杂的异步逻辑。数据库驱动如果配合良好（阻塞IO释放OS线程），也能提升吞吐。总之，虚拟线程使编程模型和高并发性能实现了统一：我们可以用同步代码写出异步高并发效果。需要注意监控工具升级以识别大量线程，但JDK本身的jstack等已经支持很好。</li><li><strong>Sequenced Collections（序列集合）</strong>： Java 21 引入了新的集合接口族 <strong>Sequenced</strong> 集合（JEP 431）。主要包括 <code>SequencedCollection</code>、<code>SequencedSet</code>、<code>SequencedMap</code>。这些接口统一了“有顺序的集合”的抽象，提供了在集合两端操作元素的方法以及反转视图。比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SequencedCollection&lt;Integer&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">coll.addFirst(<span class="number">1</span>);</span><br><span class="line">coll.addLast(<span class="number">2</span>);</span><br><span class="line">System.out.println(coll.getFirst()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(coll.getLast());  <span class="comment">// 2</span></span><br><span class="line">SequencedCollection&lt;Integer&gt; reversed = coll.reversed();</span><br></pre></td></tr></table></figure>在Java 21中，<code>ArrayList</code>、<code>LinkedList</code> 实现了 <code>SequencedCollection</code>；<code>LinkedHashSet</code> 实现了<code>SequencedSet</code>；<code>LinkedHashMap</code>实现了 <code>SequencedMap</code>。这样我们可以方便地对这些集合的头尾进行操作，而不必区分List或Deque接口。例如以前要获取List最后一个元素需要 <code>list.get(list.size()-1)</code>，现在 <code>list.getLast()</code> 即可。反转视图 <code>reversed()</code> 则返回一个与原集合顺序相反的同类型集合视图，操作视图相当于操作原集合两端。<strong>应用场景</strong>： 任何需要队列/双端队列操作的地方更方便了，而且统一接口后，可以写通用算法处理SequencedCollection，不用分别考虑List或Deque，实现接口分离更合理（Deque过于笼统，而Sequenced只关注顺序）。这个特性在集合框架演进史上是个重要调整，使得List, Set, Map在迭代顺序方面有了共同的父接口，更加一致。</li></ul><h2 id="JVM-和性能-2"><a href="#JVM-和性能-2" class="headerlink" title="JVM 和性能"></a>JVM 和性能</h2><ul><li><strong>分代 ZGC（实验）</strong>： Java 21 将 ZGC 升级为<strong>分代式垃圾收集器</strong>（Generational ZGC，JEP 439）。以前ZGC是非分代收集，Java 21引入分代概念，将堆分为新生代和老年代。如此一来，ZGC 可以针对新生对象和长期存活对象采用不同策略，提升整体吞吐量和内存回收效率。Gen ZGC 仍是实验状态，需要通过 <code>-XX:+ZGenerational</code> 开启。但测试表明 generational 模式下，ZGC 的 STW 停顿仍然保持极低，同时回收效率明显提高，在大部分场景下优于非分代模式。<strong>应用场景</strong>： 如果使用ZGC，可以考虑在Java 21上试验开启分代模式，以获得更好的性能。需要注意持续关注后续版本，因为目标是在验证效果后将 Gen ZGC 替换掉非分代ZGC。</li><li><strong>禁用安全管理器</strong>： Java 21 虽未完全移除 SecurityManager，但已经采取了进一步措施：完全禁止在启动时开启安全管理器。即使使用 <code>-Djava.security.manager</code> 也无法再启用它（会抛异常）。这是JEP 486的一部分。这意味着 SecurityManager 已经走到寿终正寝阶段，Java 21 开始不允许使用它。对于仍依赖安全管理器的应用，这是最后通牒，必须迁移（常用场景如SecurityManager控制脚本权限，现在可用沙箱ClassLoader等替代）。这个改动对大多数现代应用无影响，因为安全管理器早已很少使用。</li><li><strong>虚拟线程同步非阻塞平台线程</strong>： 前面提到，Java 21 正式版虚拟线程在阻塞时（包括进入 synchronized 区块）基本都不会固定占用平台线程。JEP 491 进一步优化了虚拟线程遇到 monitor 锁的处理：如果虚拟线程在同步锁等待，它后台的OS线程会释放出来去执行别的虚拟线程。这一机制确保即使有大量虚拟线程同时阻塞在锁上，也不会占满对应数量的OS线程，从而保持高度并发。这使得在使用传统锁的代码中引入虚拟线程也依然高效，并发能力不会下降。</li><li><strong>类加载和链接缓存（预览）</strong>： JEP 483 引入了“提前加载和链接”的机制，允许缓存类加载和链接结果，加速应用启动。通过在上次运行中记录已加载链接的类，在下次JVM启动时跳过重复工作，实现<strong>40%以上的启动提速</strong>。这类似于CDS，但作用于类链接阶段。Java 21 中这是预览需手动开启（<code>-XX:+EnableClassDataSharing</code> 等），未来可能默认启用来提升大应用启动性能（微服务、无服务器函数启动速度变快）。</li><li><strong>类文件 API 正式发布</strong>： 前几版孵化的<strong>类文件解析 API</strong> 在 Java 24 正式发布（Java 21中处于第二次预览JEP 451/456）。开发者可以使用标准API解析、生成和转换 <code>.class</code> 文件。这对于构建字节码操作工具（类似ASM）提供了官方支持。虽然普通业务开发用不到，但对于框架和工具作者是个好消息，避免依赖第三方库，增加可靠性。</li></ul><h2 id="新安全特性"><a href="#新安全特性" class="headerlink" title="新安全特性"></a>新安全特性</h2><ul><li><strong>密钥派生函数 API（预览）</strong>： 虽然Java 21没有包含，但Java 24预览了 <strong>KDF API</strong> (JEP 478)。这将标准化PBKDF2、HKDF等密钥派生算法的使用。在Java 21，安全新增主要是一些TLS KEM算法和DH算法强化，不是主要特性。</li></ul><p><strong>总结</strong>： Java 21 是迄今<strong>功能最强大</strong>的Java版本之一。<strong>虚拟线程</strong>和<strong>结构化并发</strong>在并发编程领域给予Java巨大能量，<strong>Sequenced集合</strong>完善了集合框架，<strong>模式匹配</strong>全面落地使Java具备了代数数据类型的便利。诸多预览（字符串模板、隐藏类、KDF等）也预示着未来的发展方向。作为LTS版本，Java 21 具备足够的稳定性，又融入了现代语言的诸多精华，难怪被称为“继Java 8之后最重要的版本”。对于开发者来说，如果从Java 17升级上来，将明显感受到代码可以写得更简洁（Record, 模式匹配）, 性能可以更上一层楼（虚拟线程, 新GC）, 开发体验也更好（UTF-8默认, 文本块, 字符串模板等）。Java 21 为未来几年Java的发展奠定了基础，下一个LTS预计是Java 25，期间Java 22/23/24也会继续在这些方向演进。</p><h1 id="Java-22-新特性"><a href="#Java-22-新特性" class="headerlink" title="Java 22 新特性"></a>Java 22 新特性</h1><p><strong>发行时间</strong>： 2024 年 3 月</p><p>Java 22 虽为非LTS版本，但也引入了一些值得关注的新特性，共计约12项（其中多项为预览/孵化）。Java 22 基本上是在Java 21基础上的小幅增量。</p><h2 id="语言与语法"><a href="#语言与语法" class="headerlink" title="语言与语法"></a>语言与语法</h2><ul><li><strong>未命名模式和变量转正</strong>： 前文提到的下划线 <code>_</code> 模式和未命名变量在 Java 22 顺利成为正式特性。因此，在 Java 22+ 编码时，可以直接使用 <code>_</code> 来忽略模式中的某部分，无需任何开关。比如 <code>case Point(int x, _) -&gt; ...</code> 这样的 switch 分支现在是标准写法。此举标志着模式匹配相关语法进一步完善，开发者可以更自在地使用通配模式，提高可读性。</li><li><strong>外部函数和内存 API 正式发布</strong>： Java 22 通过 JEP 454 将<strong>Foreign Function &amp; Memory API</strong>正式加入标准库。这表示 Project Panama 历经多个版本终于落地。开发者无需再加孵化模块，可直接使用 <code>MemorySegment</code>, <code>MemorySession</code>（已更名为Arena）, <code>CLinker</code> 等类与本地交互。相比Java 21预览，Java 22 的API可能略有调整但大体一致。<strong>应用场景</strong>：底层系统编程、JNI替代方案，如直接调用操作系统函数、读取映射文件、高性能I/O等，现在都能用这套安全的API完成。由于已正式发布，各种框架和库也会开始利用它，例如Netty可以用MemorySegment管理直接内存，JNI层代码有望大幅减少。</li><li><strong>多文件源代码程序启动</strong>： Java 11 实现了单文件运行，Java 22 则更进一步引入<strong>多源文件一起运行</strong>的功能（JEP 458）。这允许我们使用 <code>java</code> 命令一次性运行多个源文件，无需手动编译链接。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyMain.java Utils.java Helper.java</span><br></pre></td></tr></table></figure>Java 将同时编译这些源并执行包含 <code>main</code> 方法的类。这对写小型脚本程序又更方便了一步，打破了“一次只能运行一个源文件”的限制。<strong>应用场景</strong>： 在教学、快速试验时，可以把若干相关类放在不同文件，一条命令运行，避免每改一点就javac再java分步做。</li><li><strong>构造函数中允许语句在 super() 之前（预览）</strong>： JEP 447 在 Java 22 作为预览推出了<strong>构造方法前置语句</strong>功能。以往在构造函数中，调用父类构造 (<code>super(...)</code>) 或本类重载构造 (<code>this(...)</code>) 必须是第一条语句，不能有任何其他代码在其前面。这导致有时想在调用父类前做点检查或计算很麻烦。Java 22 放宽了这个限制，允许在构造器首行调用之前加入一些限定的语句，比如对参数的合法性检查、静态方法调用获取配置等。示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    MyClass(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x = <span class="number">0</span>;           <span class="comment">// 现在可以在 super() 调用前执行</span></span><br><span class="line">        <span class="built_in">super</span>(calcValue(x));       <span class="comment">// 然后调用父类构造</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此特性可以减少在上一级构造做逻辑绕过的繁琐，代码意图更直接。但是仍有限制：不能访问未初始化的成员等。<strong>应用场景</strong>： 主要用于构造参数预处理，例如确保传给父类的参数符合要求。以前需要在子类构造方法之外先处理好参数再传，如今可以在构造内部做处理，更封装直观。</li></ul><h2 id="核心库与安全-1"><a href="#核心库与安全-1" class="headerlink" title="核心库与安全"></a>核心库与安全</h2><ul><li><strong>类文件 API 第二次预览</strong>： 尽管Java 24才正式发布类文件API (JEP 484)，Java 22 已经进行了第一次预览 (JEP 457) 和 Java 23 第二次预览 (JEP 456)。这意味着Java 22的开发者已经可以试用标准的类文件解析生成API，为后续正式版做准备。具体API见上文Java 24部分介绍。</li><li><strong>流收集器 API（预览）</strong>： Java 22 引入了流处理的新机制预览：<strong>Stream::collect 使用自定义收集器（Gatherer）</strong>，也称<strong>Stream Gatherers</strong> (JEP 461/473)。简单来说，它允许开发者定义自定义的流中间收集逻辑，通过新的<code>Stream.gather(Gatherer)</code>方法实现。这拓展了Stream API，能表达更复杂的操作如滑动窗口、批处理等。Java 22 预览后，Java 23 继续预览，Java 24 正式推出 (JEP 485)。这个特性复杂但功能强大，前文Java 24部分已详细说明。</li><li><strong>Markdown 文档注释</strong>： Java 23 正式加入了 <strong>Markdown 支持的 JavaDoc</strong> (JEP 467)，Java 22 可能已经对这一特性做好了准备或者在22预览，在23正式。因此Java 22/23写JavaDoc可以直接用Markdown语法，更方便地编写列表、链接等。</li></ul><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><ul><li><strong>G1 区域固定</strong>： JEP 423 针对 G1 GC 引入了<strong>区域固定</strong>的能力。这使得JNI临界区中的对象可以避免被移动，从而减少复制开销，对某些场景下提高GC性能有帮助。但这属于JVM内部优化，开发者无感知。</li><li><strong>Unsafe 内存访问方法弃用</strong>：Java 22 正式弃用了<code>sun.misc.Unsafe</code>中一批直接内存访问方法（JEP 471）。因为有VarHandle和MemorySegment这些更安全的替代了。Unsafe依然能用，但调用这些方法会警告，未来版本将移除。这促使底层库向VarHandle/FFM API迁移。</li><li><strong>端口和平台支持</strong>：随着JDK进入高频发布，Java 22 没有大的移植JEP，因为21已涵盖RISC-V等。不过可能在22对Windows/AArch64、macOS/AArch64等新平台做了性能调优和问题修复。</li></ul><p><strong>总结</strong>： Java 22 作为 Java 21 之后的过渡版本，主要工作是<strong>巩固</strong>和<strong>过渡</strong>。大量Java 21预览的特性在Java 22得到正式发布（如 FFM API、Unnamed模式变量），使得Java语言和API更加完善。对开发者来说，升级到Java 22不会像21那样冲击大，但能开始稳定地使用21里预览的一些功能。例如，用MemorySegment替代ByteBuffer变得稳妥了，用模式匹配下划线占位也没问题了。这版也包含一些语法糖改进，如构造器中可以有前置语句，这些虽然小，但提升了编码便利性。Java 22 还为未来的新特性继续铺路，例如Stream自定义收集、模块导入声明（JEP 476，允许<code>import java.util.* from module java.base;</code>这样的简化语法，在22孵化）等。这些预览将在Java 23/24成熟。可以预见，Java 22 的变化累积到Java 25 (下一个LTS) 会带来更多惊喜。</p><h1 id="Java-23-新特性"><a href="#Java-23-新特性" class="headerlink" title="Java 23 新特性"></a>Java 23 新特性</h1><p><strong>发行时间</strong>： 2024 年 9 月</p><p>Java 23 延续了 22 的趋势，也是非LTS版本。根据目前信息，Java 23 包含约12项新特性。其中相当一部分是继续预览或最终定型上版的特性。</p><h2 id="语言与语法-1"><a href="#语言与语法-1" class="headerlink" title="语言与语法"></a>语言与语法</h2><ul><li><strong>原始类型模式（预览）</strong>：Java 23 通过 JEP 455 引入了 <strong>对原始类型的模式匹配</strong> 预览。这扩展了前面的模式匹配，使 <code>instanceof</code> 和 <code>switch</code> 可以直接匹配 primitive 类型的值。这其实在语法上表现为允许 instanceOf 右边出现基本类型，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer i) &#123; ... &#125; <span class="comment">// 之前只能这样</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="type">byte</span> b)   &#123; ... &#125; <span class="comment">// 现在可以直接匹配 byte 范围</span></span><br></pre></td></tr></table></figure>如上，第二个判断如果 obj 是数值且在 byte 范围内，就匹配成功并转换为 byte。同理，switch 也允许case 是 long、double 等字面量。这使模式匹配对基本数据类型更友好。<strong>应用场景</strong>：通常从文本或网络得到Object，需要根据类型处理，比如 JSON节点可能是Double但实际表示整数，这时instanceOf double d -&gt; 转 int 就方便了。不过原始类型模式属于锦上添花的特性，非核心。</li><li><strong>类文件 API 第二次预览</strong>：Java 23 继续预览类文件API (JEP 456/466)。根据JEP 484，在Java 24最终发布。Java 23也许主要更改了一些API命名、包结构等。</li><li><strong>Markdown JavaDoc 正式</strong>：Java 23 (JEP 467) 把JavaDoc的 Markdown 支持正式化。因此现在可以在JDK文档中看到格式良好的列表、代码等了。对开发者，写注释也更方便，不必纯HTML。</li><li><strong>向量API 第八次孵化</strong>：Java 23 的 Vector API 进入第8次孵化（JEP 469）。应该做了更多性能改进，可能已经接近转正式阶段（Java 25?）。</li><li><strong>Stream 收集器第二次预览</strong>：Java 23 通过 JEP 473 继续预览 Stream::gather（流收集器）功能。可能完善了Gatherer接口定义。Java 24 已正式推出 (JEP 485)。因此Java 23开发者已可试用 gather 功能进行复杂流处理。</li></ul><h2 id="JVM-与安全"><a href="#JVM-与安全" class="headerlink" title="JVM 与安全"></a>JVM 与安全</h2><ul><li><strong>禁用 SecurityManager 完成</strong>：Java 24 完全禁止开启安全管理器。Java 23 应该已经完全不支持 SecurityManager，在Java 21就已经禁止使用 <code>-Djava.security.manager</code> 了。因此Java 23在安全方面把老的 SecurityManager 体系彻底关停。</li><li><strong>TLS/KEM 支持</strong>：可能添加了一些后量子密码学支持，例如密钥封装机制（KEM）API等。但具体JEP (452 KEM API) 最终目标在Java 21/22实现，这里可能预览或完善。Java 24通过JEP 478预览KDF，目前KEM方面JEP 452已在21实现KeyAgreement中。</li><li><strong>JVM性能优化</strong>：Java 23 完成了Gen ZGC的发展。JEP 474 切换ZGC默认启用分代模式并弃用非分代模式。可能Java 23实验提供一个flag，Java 24就默认改为分代。</li><li><strong>模块导入声明（预览）</strong>：JEP 476 在Java 24预览。Java 23或22可能已经孵化。它允许在代码顶部导入整个模块导出的所有包，比如 <code>import static from javafx.graphics;</code> 这对模块化用户方便一些，但普通场景用处不大，目前也只是预览。</li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>RMI Registry 拓展</strong>：Java 23 几乎不涉及RMI了，RMI Activation已移除，Registry部分或性能改善可能进行了一些微调，但无JEP说明。</li></ul><p><strong>总结</strong>： Java 23 是在 LTS (21) 之后，下一次 LTS (25) 之前的第二个常规版本。其主要作用是<strong>巩固新功能</strong>并<strong>继续探索</strong>。许多 Java 22 引入的预览在 Java 23 得到完善，例如原始类型模式、流收集器等。这些都在为下一个LTS做准备，使得 LTS 发布时新特性能更成熟稳定。对开发者而言，Java 23新增的稳定特性较少，更像是在21的基础上修修补补。但对于喜欢尝新的团队，可以在 Java 23中尝试前沿特性（如 gatherer、类文件API 等）并给出反馈。考虑到 Java 25将是LTS且会包含22-24的成果，Java 23的意义更多在于验证和过渡。</p><h1 id="Java-24-新特性"><a href="#Java-24-新特性" class="headerlink" title="Java 24 新特性"></a>Java 24 新特性</h1><p><strong>发行时间</strong>： 2025 年 3 月</p><p>根据官方消息，Java 24 带来了 <strong>24 项新特性</strong>（恰好与版本号相同的数量），是一个内容相当丰富的版本，甚至相当于Java 22和23新特性之和。它汇集了过去几版的预览成果，也有新的探索。以下列出几项主要新特性：</p><h2 id="安全与密码学"><a href="#安全与密码学" class="headerlink" title="安全与密码学"></a>安全与密码学</h2><ul><li><strong>密钥派生函数 API（预览）</strong>：Java 24 引入了 <strong>KDF(Key Derivation Function) API</strong> 预览（JEP 478）。KDF算法如 HKDF、PBKDF2 用于从一个初始密钥派生出二次密钥。JDK 24 提供统一接口 <code>KDF</code> 来获取和使用这些算法。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KDF</span> <span class="variable">hkdf</span> <span class="operator">=</span> KDF.getInstance(<span class="string">&quot;HKDF-SHA256&quot;</span>);</span><br><span class="line"><span class="type">AlgorithmParameterSpec</span> <span class="variable">params</span> <span class="operator">=</span> HKDFParameterSpec.of(initialKey).thenExpand(info, <span class="number">32</span>);</span><br><span class="line"><span class="type">SecretKey</span> <span class="variable">derivedKey</span> <span class="operator">=</span> hkdf.deriveKey(<span class="string">&quot;AES&quot;</span>, params);</span><br></pre></td></tr></table></figure>这样就得到一个32字节的AES密钥。这个API使得密码学编程更加直观规范，避免开发者自己实现易出错。<strong>应用场景</strong>： 密码协议需要从会话密钥生成加密密钥、认证密钥等，例如TLS 1.3的密钥扩展，就可使用HKDF实现。KDF API 预览后预计在下一LTS(Java 25)转正，对那些需要自己拼凑调用 MessageDigest 的业务大有裨益。</li><li><strong>完全禁用 Security Manager</strong>：前文已述，Java 24 (JEP 486) 完全移除了安全管理器的启用可能。这标志着 SecurityManager 彻底退出历史舞台，相关API调用会直接抛异常。开发者应确认没有使用 <code>System.setSecurityManager</code> 等，以免升级引发错误。</li></ul><h2 id="性能与工具"><a href="#性能与工具" class="headerlink" title="性能与工具"></a>性能与工具</h2><ul><li><strong>类加载与链接缓存</strong>：Java 24 通过 JEP 483 引入了 <strong>Class Preloading &amp; Linking</strong>（提前类加载和链接）特性。它会在首次运行应用时缓存类加载+验证+链接结果，存储到类数据共享（CDS）的归档中。下次JVM启动加载相同应用时，可直接使用缓存，避免重复解析验证，大幅加速启动时间。实测对于大型Spring应用启动提升可超40%。此特性类似于CDS但更进一步。<strong>应用场景</strong>： 短命令行工具或Serverless函数的冷启动、频繁重启的服务等，将显著受益。Java 24 该功能预览，需要开启参数，未来Java可能默认启用这一优化。</li><li><strong>类文件 API 正式发布</strong>：Java 24 正式推出了 <strong>ClassFile API</strong>（JEP 484）。开发者可以使用它来读写 <code>.class</code> 文件而不依赖第三方库。API位于<code>java.lang.classfile</code>包下，包括<code>ClassFile</code>，<code>ClassModel</code>, <code>MethodModel</code> 等，可以方便地遍历类的字节码结构。例如，可以用它做一个简单的类浏览器或者字节码修改工具。这个特性更多惠及框架和工具作者，一般业务不会直接用。但有了官方API，像ASM等库可能会慢慢过渡或封装该API，以减少维护负担。</li><li><strong>Stream::gather 正式发布</strong>：Java 24 通过 JEP 485 增强了 Stream API，引入了 <code>Stream.gather(Gatherer)</code> 方法及 <strong>Gatherer接口</strong>。这允许自定义流的中间操作逻辑，实现之前难以表达的操作模式。举例来说，使用 gatherer 可以实现“跳过重复长度的字符串”这样的需求，如前文示例所示：用一个 HashSet 作为状态，在Gatherer每次收到元素时检查长度是否出现过，没出现过就 push 给下游，否则跳过。Gatherer 接口提供了类似状态机的钩子，使一个流可自定义内部行为。<strong>应用场景</strong>： 复杂数据流处理，如滑动窗口统计、跨元素的自定义去重、批量输出等，以前要借助外部变量或拆分流处理，现在 gatherer 使这些逻辑优雅地内聚在Stream管道中。这对高级Java数据处理开发者是个强力工具。</li></ul><h2 id="并发与内部改进"><a href="#并发与内部改进" class="headerlink" title="并发与内部改进"></a>并发与内部改进</h2><ul><li><strong>作用域值第四次预览</strong>：ScopedValue 在 Java 24 进入第4次预览（JEP 487）。它的API进一步稳定，预计Java 25会正式推出取代ThreadLocal的大部分使用场景。Java 24的ScopedValue足够成熟，可以尝试在虚拟线程环境下用它传递上下文数据。相对于ThreadLocal，它不会引起内存泄漏且性能更好，是 Loom 计划的重要补充。</li><li><strong>虚拟线程同步无Pinning</strong>：之前Java 21中引入，此处在Java 24 (JEP 491) 已经默认生效：虚拟线程在锁中阻塞时会挂起自己，让出载体线程，实现无Pinning锁。对开发者而言，这意味着可以放心在虚拟线程中使用传统锁，不必担心阻塞OS线程导致并发度下降。这彻底解决了以往Fibers实现的一个缺陷，使虚拟线程更加Transparent地兼容现有同步代码。</li><li><strong>jlink 无需 JMOD 文件</strong>：Java 24 (JEP 493) 改进了 jlink 工具，打包定制运行时镜像时不再需要JDK自带的 .jmod 文件。这减少了JDK安装体积约25%，并且使得 jlink 使用更简单。对最终用户来说，Java 24的JDK包会更小，jlink运行时不会受影响。</li></ul><h2 id="预览-孵化"><a href="#预览-孵化" class="headerlink" title="预览/孵化"></a>预览/孵化</h2><ul><li><strong>字符串模板第二次预览</strong>： 虽然Java 24发布时间未来，但可以预计 String Templates 可能在Java 24继续预览甚至转正。JEP 430在Java 21预览，引起极大关注，Java 24 若提前成熟就可能正式发布，否则会第二次预览。无论如何，离成为正式特性不远了。</li><li><strong>隐式类导入（预览）</strong>： JEP 485?其实没此号，隐式模块导入JEP 476在Java 24预览了。它允许像一些脚本语言一样导入整个模块，不用逐个包声明import。但这个特性用处和接受度有限，尚不确定是否会最终发布。</li></ul><p><strong>总结</strong>：Java 24 作为非LTS版本，却引入了<strong>史无前例多的新特性</strong>。一方面，它将过去几年的预览几乎全部定型（FFM API、类文件API、流收集器等），另一方面也推出了像KDF API、Scope Values 等值得期待的新预览。此外，性能优化（类加载缓存、虚拟线程锁优化）使Java运行效率更上一层楼。Java 24对于追新的开发者无疑是一个盛宴，但要谨慎用于生产，因为变化很多且缺少长期支持。但可以预见，<strong>Java 25</strong> 作为下一个LTS，将包含Java 22-24的大量成果，届时Java语言的现代化转型可以说基本完成。因此Java 24不仅有自身价值，更是Java 25 前的重要一跃，值得关注和试用，为未来做准备。</p><hr><p><strong>参考资料：</strong></p><ul><li>OpenJDK 官方 JEP 列表及发布说明。</li><li>Oracle Blogs: Java Language Futures 系列文章。</li></ul>]]></content>
    
    
    <summary type="html">列举了关键特性及应用场景和示例代码，值得了解</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Java, JDK" scheme="https://wyiyi.github.io/amber/tags/Java-JDK/"/>
    
  </entry>
  
  <entry>
    <title>程序员修炼之道：通向务实的最高境界（第2版）</title>
    <link href="https://wyiyi.github.io/amber/2025/06/20/the-pragmatic-programmer/"/>
    <id>https://wyiyi.github.io/amber/2025/06/20/the-pragmatic-programmer/</id>
    <published>2025-06-20T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本书赞誉"><a href="#本书赞誉" class="headerlink" title="本书赞誉"></a>本书赞誉</h2><blockquote><p>正是这本书，开阔了我的视野，让我意识到自己不仅仅是庞大机器上的一枚齿轮，有朝一日也能藉由修炼成为匠师。它是我生命中最重要的一本书。</p></blockquote><blockquote><p>哪有什么简单的答案。没有最好的解决方案，无论是工具、语言还是操作系统；只在特定的环境下才有所谓更合适的系统。</p></blockquote><blockquote><p>作为务实的程序员，你们会共有许多如下特征：</p><ul><li>早期的采纳者/快速的适配者。</li><li>你热衷于收集各种细微的事实，坚信它们会影响自己多年后的决策。</li></ul></blockquote><h2 id="提示1-关注你的技艺"><a href="#提示1-关注你的技艺" class="headerlink" title="提示1 关注你的技艺"></a>提示1 关注你的技艺</h2><h2 id="提示2-思考！思考你的工作"><a href="#提示2-思考！思考你的工作" class="headerlink" title="提示2 思考！思考你的工作"></a>提示2 思考！思考你的工作</h2><blockquote><p>你能更积极地投入喜欢的工作，对越来越多的学科有掌控感，对不断进步产生愉悦感。从长期来看，时间投资将得到回报，因为你和你的团队将变得更高效，能编写出更容易维护的代码，并且在会议上花的时间更少。</p></blockquote><blockquote><p>伟大的草坪需要每天的点滴护理，伟大的程序员也是如此。</p></blockquote><blockquote><p>我活着不是为了满足你的期望，正如你也不是因为我的期望而活着。<br>——李小龙</p></blockquote><h2 id="提示3-你有权选择"><a href="#提示3-你有权选择" class="headerlink" title="提示3 你有权选择"></a>提示3 你有权选择</h2><blockquote><p>如果你的技术过时了，安排时间（你自己的时间）学习一些看起来有趣的新东西。这是一种自我投资，只有为此而加班才是合理的。</p></blockquote><blockquote><p>在你的职业发展、学习教育，以及你的项目、每天的工作等各方面对你自己负责，对你的行为负责，这是务实哲学的基石之一。</p></blockquote><h2 id="提示4-提供选择，别找借口"><a href="#提示4-提供选择，别找借口" class="headerlink" title="提示4 提供选择，别找借口"></a>提示4 提供选择，别找借口</h2><blockquote><p>给出选择，而不是找借口。不要说搞不定；解释一下要做些什么才能挽回这个局面。</p></blockquote><blockquote><p>当你意识到自己在说“我不知道”时，一定要接着说“——但是我会去搞清楚”。用这样的方式来表达你不知道是非常好的，因为接着你就可以像一个专家一样承担起责任。</p></blockquote><h2 id="提示5-不要放任破窗"><a href="#提示5-不要放任破窗" class="headerlink" title="提示5 不要放任破窗"></a>提示5 不要放任破窗</h2><blockquote><p>不要搁置“破窗”（糟糕的设计、错误的决定、低劣的代码）不去修理。每发现一个就赶紧修一个。如果没有足够的时间完全修好，那么就把它钉起来。也许你可以注释掉那些糟糕的代码，显示一行“尚未实现”的信息，或用假数据先替代一下。采取行动，预防进一步的损害发生，表明一切尽在你的掌握中。</p></blockquote><h2 id="提示6-做推动变革的催化剂"><a href="#提示6-做推动变革的催化剂" class="headerlink" title="提示6 做推动变革的催化剂"></a>提示6 做推动变革的催化剂</h2><blockquote><p>大多数软件灾难都始于微不足道的小事，项目的拖延也是一天天累积而成的。系统一个特性接一个特性地偏离规范，一个接一个的补丁加到代码上，最终原始代码无影无踪。往往就是一件件小事的累积破坏了团队和士气。</p></blockquote><h2 id="提示7-牢记全景"><a href="#提示7-牢记全景" class="headerlink" title="提示7 牢记全景"></a>提示7 牢记全景</h2><blockquote><p>永远留意着大局，持续不断地审视你身边发生的事情，而不要只专注于你个人在做的事情。</p></blockquote><h2 id="提示8-将质量要求视为需求问题"><a href="#提示8-将质量要求视为需求问题" class="headerlink" title="提示8 将质量要求视为需求问题"></a>提示8 将质量要求视为需求问题</h2><blockquote><p>投资知识，收益最佳。<br>——本杰明·富兰克林</p></blockquote><blockquote><p>管理知识组合和管理金融投资组合非常的类似：</p><ol><li><p>正规投资者有定期投资的习惯。</p></li><li><p>多样化是长线成功的关键。</p></li><li><p>聪明的投资者会平衡保守型和高风险高回报型投资的组合。</p></li><li><p>投资者用低买高卖来获得最大的回报。</p></li><li><p>应定期审查和重新平衡投资组合。</p></li></ol></blockquote><h2 id="提示9-对知识组合做定期投资"><a href="#提示9-对知识组合做定期投资" class="headerlink" title="提示9 对知识组合做定期投资"></a>提示9 对知识组合做定期投资</h2><blockquote><ul><li><p>每年学习一门新语言</p></li><li><p>每月读一本技术书</p></li><li><p>还要读非技术书</p></li><li><p>上课</p></li><li><p>加入本地的用户组和交流群</p></li><li><p>尝试不同的环境</p></li><li><p>与时俱进</p></li><li><p>学习的机会</p></li><li><p>批判性思维</p></li></ul></blockquote><h2 id="提示10-批判性地分析你读到和听到的东西"><a href="#提示10-批判性地分析你读到和听到的东西" class="headerlink" title="提示10 批判性地分析你读到和听到的东西"></a>提示10 批判性地分析你读到和听到的东西</h2><h2 id="提示11-英语就是另一门编程语言"><a href="#提示11-英语就是另一门编程语言" class="headerlink" title="提示11 英语就是另一门编程语言"></a>提示11 英语就是另一门编程语言</h2><blockquote><ul><li><p>了解听众。</p></li><li><p>明白自己想说什么。</p></li><li><p>选择时机。</p></li><li><p>挑选风格。</p></li><li><p>让它看起来不错。</p></li><li><p>让听众参与。</p></li><li><p>做倾听者。</p></li><li><p>回应别人。</p></li></ul></blockquote><h2 id="提示12-说什么和怎么说同样重要"><a href="#提示12-说什么和怎么说同样重要" class="headerlink" title="提示12 说什么和怎么说同样重要"></a>提示12 说什么和怎么说同样重要</h2><blockquote><p>越是有效的交流，影响力就越大。</p></blockquote><h2 id="提示13-把文档嵌进去，而不要栓在表面"><a href="#提示13-把文档嵌进去，而不要栓在表面" class="headerlink" title="提示13 把文档嵌进去，而不要栓在表面"></a>提示13 把文档嵌进去，而不要栓在表面</h2><blockquote><p>注释源码是一个绝佳的机会，可以用来记录那些在其他地方无法记录的项目细节：工程上的权衡，为什么要做决定，放弃了哪些替代方案，等等。</p></blockquote><blockquote><p>接下来的两部分：DRY—邪恶的重复和正交性，有紧密关联。前一个提醒你不要在系统中复制知识，后一个阐述了不要把同一块知识切分到多个系统组件中。</p></blockquote><h2 id="提示14-优秀的设计比糟糕的设计更容易变更"><a href="#提示14-优秀的设计比糟糕的设计更容易变更" class="headerlink" title="提示14 优秀的设计比糟糕的设计更容易变更"></a>提示14 优秀的设计比糟糕的设计更容易变更</h2><blockquote><p>为什么解耦很好？因为通过隔离关注焦点，可让每一部分都容易变更—此谓ETC。</p></blockquote><blockquote><p>ETC是一种价值观念，不是一条规则。</p></blockquote><blockquote><p>ETC里有一个隐含的前提。</p><p>第一件事，假设不确定什么形式的改变会发生，你也总是可以回到终极的“容易变更”的道路上：试着让你写的东西可替换。</p><p>第二件事，把它当作培养直觉的一种方式。在工程日志中记下你面临的处境：你有哪些选择，以及关于改变的一些猜测。</p></blockquote><h2 id="提示15-DRY—不要重复自己"><a href="#提示15-DRY—不要重复自己" class="headerlink" title="提示15 DRY—不要重复自己"></a>提示15 DRY—不要重复自己</h2><blockquote><p>唯一的方法是遵循下面这条被称为<strong>DRY</strong>的原则：在一个系统中，每一处知识都必须单一、明确、权威地表达。</p></blockquote><blockquote><p>DRY 针对的是你对知识和意图的复制。它强调的是，在两个地方表达的东西其实是相同的，只是表达方式有可能完全不同。</p></blockquote><h2 id="提示16-让复用变得更容易"><a href="#提示16-让复用变得更容易" class="headerlink" title="提示16 让复用变得更容易"></a>提示16 让复用变得更容易</h2><blockquote><p>你要努力的方向，应该是孕育出一个更容易找到和复用已有事物的环境，而不是自己重新编写。</p></blockquote><h2 id="提示17-消除不相关事物之间的影响"><a href="#提示17-消除不相关事物之间的影响" class="headerlink" title="提示17 消除不相关事物之间的影响"></a>提示17 消除不相关事物之间的影响</h2><blockquote><p>但凡编写正交的系统，就能获得两个主要的收益：提高生产力及降低风险。</p></blockquote><blockquote><p>有几种技术可以用来保持正交性：</p><ul><li><p>保持代码解耦</p></li><li><p>避免全局数据</p></li><li><p>避免相似的函数</p></li><li><p>养成不断质疑代码的习惯</p></li><li><p>测试</p></li><li><p>由于系统组件之间的交互是形式化的，且交互有限，因此可以在单个模块级别上执行更多的系统测试。</p></li><li><p>编写单元测试本身就是一个有趣的正交性测试</p></li><li><p>修Bug也是评估整个系统的正交性的好时机</p></li></ul></blockquote><h2 id="提示18-不设最终决定"><a href="#提示18-不设最终决定" class="headerlink" title="提示18 不设最终决定"></a>提示18 不设最终决定</h2><h2 id="提示19-放弃追逐时尚"><a href="#提示19-放弃追逐时尚" class="headerlink" title="提示19 放弃追逐时尚"></a>提示19 放弃追逐时尚</h2><blockquote><p>要让你的代码具备“摇滚”精神：顺境时摇摆滚动，逆境时直面困难。</p></blockquote><h2 id="12-曳光弹"><a href="#12-曳光弹" class="headerlink" title="12 曳光弹"></a>12 曳光弹</h2><blockquote><p>曳光弹之所以有用，是因为其工作环境和约束与真实子弹的相同。曳光弹能快速抵达目标，所以枪手可以得到即时的反馈。</p></blockquote><h2 id="提示20-使用曳光弹找到目标"><a href="#提示20-使用曳光弹找到目标" class="headerlink" title="提示20 使用曳光弹找到目标"></a>提示20 使用曳光弹找到目标</h2><blockquote><p>曳光弹式开发和项目不会结束这种理念是一致的：总有东西需要改，总有新功能需要加。这是一个逐步递增的方法。</p></blockquote><h2 id="提示21-用原型学习"><a href="#提示21-用原型学习" class="headerlink" title="提示21 用原型学习"></a>提示21 用原型学习</h2><blockquote><p>由于原型需要跳过细节，专注于它所考虑的系统的特定方面，所以你可能想用高阶脚本语言来实现原型。</p></blockquote><blockquote><p>脚本语言也可以很好地充当“粘合剂”，将低阶代码块组合成新的搭配。</p></blockquote><h2 id="提示22-靠近问题域编程"><a href="#提示22-靠近问题域编程" class="headerlink" title="提示22 靠近问题域编程"></a>提示22 靠近问题域编程</h2><blockquote><p>领域语言语言之界限，即是一个人世界之界限。</p></blockquote><h2 id="提示23-通过估算来避免意外"><a href="#提示23-通过估算来避免意外" class="headerlink" title="提示23 通过估算来避免意外"></a>提示23 通过估算来避免意外</h2><blockquote><p>吃掉大象：</p><ul><li><p>检查需求分析风险</p></li><li><p>设计、实现、集成</p></li><li><p>和用户一起验证</p></li></ul></blockquote><blockquote><p>一次次地迭代下去，提炼出的东西会变得更好，对进度的信心也会随之增长。这种评估工作通常在每个迭代周期的末尾团队进行回顾时完成。</p></blockquote><h2 id="提示24-根据代码不断迭代进度表"><a href="#提示24-根据代码不断迭代进度表" class="headerlink" title="提示24 根据代码不断迭代进度表"></a>提示24 根据代码不断迭代进度表</h2><blockquote><p>把提炼进度表作为每次迭代的一部分，你就可以估算出能力范围内最精确的进度安排。</p></blockquote><h2 id="提示25-将知识用纯文本保存"><a href="#提示25-将知识用纯文本保存" class="headerlink" title="提示25 将知识用纯文本保存"></a>提示25 将知识用纯文本保存</h2><blockquote><p>我们把需求以知识的形式收集起来，然后在设计、实现、测试和文档中表达这些知识。</p></blockquote><blockquote><p>纯文本赋予了我们操作知识的能力</p></blockquote><blockquote><ul><li><p>为防备老化而加保险</p></li><li><p>利用杠杆效应让已有工具发挥最大优势</p></li><li><p>易于测试</p></li></ul></blockquote><h2 id="提示26-发挥Shell命令的威力"><a href="#提示26-发挥Shell命令的威力" class="headerlink" title="提示26 发挥Shell命令的威力"></a>提示26 发挥Shell命令的威力</h2><blockquote><p>在Shell中，你可以调用所有能用的工具，或通过管道用各种方式把工具组合起来—恐怕开发者自己做梦都不会想到，自己当初开发的工具会被这么使用。</p></blockquote><h2 id="提示27-游刃有余地使用编辑器"><a href="#提示27-游刃有余地使用编辑器" class="headerlink" title="提示27 游刃有余地使用编辑器"></a>提示27 游刃有余地使用编辑器</h2><blockquote><p>怎么才算游刃有余。这里有一个挑战列表：</p><ul><li><p>当编辑文本时，以字符、单词、行、段落为单位移动光标及进行选择。</p></li><li><p>当编辑代码时，在各种语法单元（配对的分隔符、函数、模块……）之间移动。</p></li><li><p>做完修改后，重新缩进代码。</p></li><li><p>用单个指令完成代码块的注释或取消注释。</p></li><li><p>Undo并Redo变更。</p></li><li><p>把编辑窗口切割成多个面板，然后在它们之间跳转。</p></li><li><p>跳转到特定的行号。</p></li><li><p>对选出的多行进行排序。</p></li><li><p>搜索普通字符串，或用正则表达式搜索，然后重复上一次的搜索。</p></li><li><p>基于框选或某个模式匹配的结果，临时创建多个光标，并行地在多个光标处编辑文本。</p></li><li><p>显示当前项目的编译错误。</p></li><li><p>跑一下当前项目的测试。能不能不用鼠标/触控板完成上面所有的任务？</p></li></ul></blockquote><blockquote><p>首先，编辑时要自省。每次发现自己又在重复做某件事情的时候，要习惯性地想到“或许有更好的方法”，然后找到这个方法。</p></blockquote><blockquote><p>藏起鼠标/触摸板，一整个星期只用键盘。如果发现有大量的事情，离开点击你就干不了了，那么正好学习一下该怎么干。</p></blockquote><h2 id="提示28-永远使用版本控制"><a href="#提示28-永远使用版本控制" class="headerlink" title="提示28 永远使用版本控制"></a>提示28 永远使用版本控制</h2><blockquote><p>把版本控制视为项目中枢。</p></blockquote><h2 id="提示29-去解决问题，而不是责备"><a href="#提示29-去解决问题，而不是责备" class="headerlink" title="提示29 去解决问题，而不是责备"></a>提示29 去解决问题，而不是责备</h2><blockquote><p>Bug是你的错还是别人的错并不重要。无论是谁的错，问题仍然要你来面对。</p></blockquote><blockquote><p>调试心态。</p></blockquote><blockquote><p>最容易欺骗的人就是自己。</p></blockquote><h2 id="提示30-不要恐慌"><a href="#提示30-不要恐慌" class="headerlink" title="提示30 不要恐慌"></a>提示30 不要恐慌</h2><blockquote><p>人们很容易陷入恐慌，尤其是当最后期限逼近，或是在老板或客户站在背后紧张凝视之下，拼命找出问题原因的时候。</p></blockquote><blockquote><p>如果你在看到Bug或Bug报告时的第一反应是“这不可能”，那你就大错特错了。不要在“但那不可能发生”的思路上浪费哪怕一个神经元，因为很明显它会发生，而且已经发生了。</p></blockquote><blockquote><p>永远要去发掘问题的根本原因，而不仅仅停留在问题的表面现象。</p></blockquote><blockquote><p>从哪里开始。</p></blockquote><blockquote><p>请确保正在处理的代码可以干净构建——没有警告。</p></blockquote><blockquote><p>当错误报告来自第三方时，Bug报告的准确性会进一步降低——实际上，你可能需要观察提交错误报告的用户，通过其操作来获得足够详细的信息。</p></blockquote><blockquote><p>调试策略。</p></blockquote><blockquote><p>复制Bug。</p></blockquote><h2 id="提示31-修代码前先让代码在测试中失败"><a href="#提示31-修代码前先让代码在测试中失败" class="headerlink" title="提示31 修代码前先让代码在测试中失败"></a>提示31 修代码前先让代码在测试中失败</h2><h2 id="提示32-读一下那些该死的出错信息"><a href="#提示32-读一下那些该死的出错信息" class="headerlink" title="提示32 读一下那些该死的出错信息"></a>提示32 读一下那些该死的出错信息</h2><blockquote><p>通常有一种比逐个检查每个栈帧更快的方法来发现问题：使用二分法。但是在讨论二分法之前，让我们先看看另外两个常见的Bug场景。</p></blockquote><blockquote><p>输入值的敏感度。</p></blockquote><blockquote><p>获取数据集的副本，并用数据测试本地运行的应用程序副本，确保其在本地也能崩溃。</p></blockquote><blockquote><p>版本间回退。</p></blockquote><blockquote><p>二分法。</p></blockquote><blockquote><p>不断分割数据，直到得到能显露问题的最小集。</p></blockquote><blockquote><p>输出日志及（或）跟踪信息。</p></blockquote><blockquote><p>通过使用文本处理工具或Shell命令来处理日志文件，就可以很容易地识别出，有问题的打开操作发生在哪里。</p></blockquote><blockquote><p>排除法。</p></blockquote><h2 id="提示33-“select”没出问题"><a href="#提示33-“select”没出问题" class="headerlink" title="提示33 “select”没出问题"></a>提示33 “select”没出问题</h2><blockquote><p>有时改变的东西超出了你的控制范围：更新操作系统、编译器、数据库或其他第三方软件的版本，可能会破坏以前正确的代码，因而出现新的Bug。</p></blockquote><blockquote><p>不要因为“觉得”一个程序或一段代码没问题，就在它牵涉一个Bug时，对它视而不见。你需要证明它没问题，用出Bug时的上下文、同样的数据、当时的边界条件来证明它没问题。</p></blockquote><h2 id="提示34-不要假设，要证明"><a href="#提示34-不要假设，要证明" class="headerlink" title="提示34 不要假设，要证明"></a>提示34 不要假设，要证明</h2><blockquote><p>如果Bug是损坏的数据造成的结果，而数据引爆程序前经过几层逐级传播，可以试试给函数加上更完备的参数检查，以便更早地将问题剥离出来。</p></blockquote><blockquote><p>如果修复这个Bug花了很长时间，问问自己为什么。你能做些什么来让下次修复这个Bug更容易呢？也许可以构建更好的测试钩子，或是编写一个日志文件分析器。</p></blockquote><blockquote><p>如果Bug是因为某人的错误假设造成的，那么就与整个团队讨论这个问题：如果一个人误解了，那么很可能很多人都误解了。</p></blockquote><blockquote><p>调试工作的清单。</p></blockquote><h2 id="提示35-学习一门文本处理语言"><a href="#提示35-学习一门文本处理语言" class="headerlink" title="提示35 学习一门文本处理语言"></a>提示35 学习一门文本处理语言</h2><h2 id="提示36-你无法写出完美的软件"><a href="#提示36-你无法写出完美的软件" class="headerlink" title="提示36 你无法写出完美的软件"></a>提示36 你无法写出完美的软件</h2><blockquote><p>我们需要防御性驾驶。在麻烦发生之前就做好准备，预料到意料之外的事情，永远不要把自己置于无法自拔的境地。</p></blockquote><blockquote><p>我们被教导要防御式编程——有任何疑问，都要去验证我们得到的一切信息；使用断言来检测错误数据，不信任任何可能来自潜在攻击者或有恶意者的数据；做一致性检查，对数据库的列设置约束——做完这些，我们通常就会自我感觉良好。</p></blockquote><blockquote><p>务实的程序员则更进一步，他们连自己也不相信。既然没人能写出完美的代码，那么也包括自己在内。</p></blockquote><blockquote><p>务实的程序员会为自己的错误建立防御机制。</p></blockquote><blockquote><p>最重要的一点是，只要我们总是坚持走小步，按照不要冲出前灯范围中描述的那样，就不会从悬崖边掉下去。</p></blockquote><blockquote><p>“当所有人都真的在给你找麻烦的时候，偏执就是一个好主意。”</p></blockquote><h2 id="提示37-通过契约进行设计"><a href="#提示37-通过契约进行设计" class="headerlink" title="提示37 通过契约进行设计"></a>提示37 通过契约进行设计</h2><blockquote><p>请记住，如果你订的契约是可以接受任何东西，并且承诺要回报整个世界，那么你就有很多代码要写！</p></blockquote><blockquote><p>类的不变式与函数式语言。</p></blockquote><blockquote><p>DBC与测试驱动开发。</p></blockquote><blockquote><p>实现DBC。</p></blockquote><blockquote><p>在编写代码之前，简单地列出输入域的范围、边界条件是什么、例程承诺要交付什么——或者更重要的是，没有承诺要交付什么——这些对编写更好的软件来说，是一个巨大的飞跃。</p></blockquote><blockquote><p>断言。</p></blockquote><blockquote><p>因为契约最大的用途，就体现在你的代码和它所使用的库之间的边界处，这里通常会检测到最多的问题。</p></blockquote><blockquote><p>DBC与尽早崩溃。</p></blockquote><blockquote><p>谁的责任。</p></blockquote><blockquote><p>语义不变式。</p></blockquote><blockquote><p>出错时要偏向消费者。</p></blockquote><h2 id="提示38-尽早崩溃"><a href="#提示38-尽早崩溃" class="headerlink" title="提示38 尽早崩溃"></a>提示38 尽早崩溃</h2><blockquote><p>崩溃，不要制造垃圾。</p></blockquote><blockquote><p>一旦代码发现本来不可能发生的事情已发生，程序就不再可靠。</p></blockquote><blockquote><p>一个死掉的程序，通常比一个瘫痪的程序，造成的损害要小得多。</p></blockquote><h2 id="提示39-使用断言去预防不可能的事情"><a href="#提示39-使用断言去预防不可能的事情" class="headerlink" title="提示39 使用断言去预防不可能的事情"></a>提示39 使用断言去预防不可能的事情</h2><blockquote><p>论何时，你发现自己在想“当然这是不可能发生的”时，添加代码来检查这一点。最简单的方法是使用断言。</p></blockquote><h2 id="提示40-有始有终"><a href="#提示40-有始有终" class="headerlink" title="提示40 有始有终"></a>提示40 有始有终</h2><blockquote><p>无论在什么时候，我们写代码都要管理资源：内存、事务、线程、网络连接、文件、计时器——所有可用的数量有限的东西。大多数情况下，资源使用遵循一个可预测的模式：分配资源，使用它，然后释放它。</p></blockquote><blockquote><p>当有疑问时，缩小范围总是有好处的。</p></blockquote><h2 id="提示41-在局部行动"><a href="#提示41-在局部行动" class="headerlink" title="提示41 在局部行动"></a>提示41 在局部行动</h2><blockquote><p>嵌套的分配。</p></blockquote><blockquote><p>释放资源的顺序与分配资源的顺序相反。</p></blockquote><blockquote><p>在代码的不同位置，如果都会分配同一组资源，就始终以相同的顺序分配它们。</p></blockquote><blockquote><p>长期的平衡。</p></blockquote><blockquote><p>对象与异常。</p></blockquote><blockquote><p>保持平衡与异常。</p></blockquote><blockquote><p>当你无法保持资源的平衡时。</p></blockquote><blockquote><p>检查平衡。</p></blockquote><blockquote><p>因为务实的程序员不相信任何人，包括自己。</p></blockquote><h2 id="提示42-小步前进——由始至终"><a href="#提示42-小步前进——由始至终" class="headerlink" title="提示42 小步前进——由始至终"></a>提示42 小步前进——由始至终</h2><blockquote><p>总是采取经过深思熟虑的小步骤，同时检查反馈，并在推进前不断调整。把反馈的频率当作速度限制，永远不要进行“太大”的步骤或任务。</p></blockquote><blockquote><p>越是必须预测未来会怎样，就越有可能犯错。与其浪费精力为不确定的未来做设计，还不如将代码设计成可替换的。</p></blockquote><h2 id="提示43-避免占卜"><a href="#提示43-避免占卜" class="headerlink" title="提示43 避免占卜"></a>提示43 避免占卜</h2><blockquote><p>很多时候，明天看起来会和今天差不多，但不要指望一定会这样。</p></blockquote><blockquote><p>当我们试着单独挑出一个事物的时候，总会发现它与宇宙中其他一切都有关联。</p></blockquote><h2 id="提示44-解耦代码让改变更容易"><a href="#提示44-解耦代码让改变更容易" class="headerlink" title="提示44 解耦代码让改变更容易"></a>提示44 解耦代码让改变更容易</h2><h2 id="提示45-只管命令不要询问"><a href="#提示45-只管命令不要询问" class="headerlink" title="提示45 只管命令不要询问"></a>提示45 只管命令不要询问</h2><blockquote><p>这个原则说的是，不应该根据对象的内部状态做出决策，然后更新该对象。这样做完全破坏了封装的优势，并且在这样做时，也会把实现相关的知识扩散到整个代码中。</p></blockquote><h2 id="提示46-不要链式调用方法"><a href="#提示46-不要链式调用方法" class="headerlink" title="提示46 不要链式调用方法"></a>提示46 不要链式调用方法</h2><h2 id="提示47-避免全局数据"><a href="#提示47-避免全局数据" class="headerlink" title="提示47 避免全局数据"></a>提示47 避免全局数据</h2><blockquote><p>全局数据包括单件。</p></blockquote><blockquote><p>全局数据包括外部资源。</p></blockquote><h2 id="提示48-如果全局唯一非常重要，那么将它包装到API中"><a href="#提示48-如果全局唯一非常重要，那么将它包装到API中" class="headerlink" title="提示48 如果全局唯一非常重要，那么将它包装到API中"></a>提示48 如果全局唯一非常重要，那么将它包装到API中</h2><blockquote><p>继承增加了耦合。</p></blockquote><blockquote><p>一切都是为了变更。</p></blockquote><blockquote><p>让代码害羞一点：让它只处理直接知道的事情，这将有助于保持应用程序解耦，使其更易于变更。</p></blockquote><blockquote><p>如果你不能将正在做的事情描述为一个流程，那表示你不知道自己正在做什么。</p></blockquote><h2 id="提示49-编程讲的是代码，而程序谈的是数据"><a href="#提示49-编程讲的是代码，而程序谈的是数据" class="headerlink" title="提示49 编程讲的是代码，而程序谈的是数据"></a>提示49 编程讲的是代码，而程序谈的是数据</h2><h2 id="提示50-不要囤积状态，传递下去"><a href="#提示50-不要囤积状态，传递下去" class="headerlink" title="提示50 不要囤积状态，传递下去"></a>提示50 不要囤积状态，传递下去</h2><h2 id="提示51-不要付继承税"><a href="#提示51-不要付继承税" class="headerlink" title="提示51 不要付继承税"></a>提示51 不要付继承税</h2><h2 id="提示52-尽量用接口来表达多态"><a href="#提示52-尽量用接口来表达多态" class="headerlink" title="提示52 尽量用接口来表达多态"></a>提示52 尽量用接口来表达多态</h2><h2 id="提示53-用委托提供服务：“有一个”胜过“是一个”"><a href="#提示53-用委托提供服务：“有一个”胜过“是一个”" class="headerlink" title="提示53 用委托提供服务：“有一个”胜过“是一个”"></a>提示53 用委托提供服务：“有一个”胜过“是一个”</h2><h2 id="提示54-利用mixin共享功能"><a href="#提示54-利用mixin共享功能" class="headerlink" title="提示54 利用mixin共享功能"></a>提示54 利用mixin共享功能</h2><blockquote><p>物归其所，事定期限。</p></blockquote><h2 id="提示55-使用外部配置参数化应用程序"><a href="#提示55-使用外部配置参数化应用程序" class="headerlink" title="提示55 使用外部配置参数化应用程序"></a>提示55 使用外部配置参数化应用程序</h2><h2 id="提示56-通过分析工作流来提高并发性"><a href="#提示56-通过分析工作流来提高并发性" class="headerlink" title="提示56 通过分析工作流来提高并发性"></a>提示56 通过分析工作流来提高并发性</h2><blockquote><p>共享状态是不正确的状态</p></blockquote><h2 id="提示57-共享状态是不正确的状态"><a href="#提示57-共享状态是不正确的状态" class="headerlink" title="提示57 共享状态是不正确的状态"></a>提示57 共享状态是不正确的状态</h2><h2 id="提示58-随机故障通常是并发问题"><a href="#提示58-随机故障通常是并发问题" class="headerlink" title="提示58 随机故障通常是并发问题"></a>提示58 随机故障通常是并发问题</h2><blockquote><p>角色是一个独立的虚拟处理单元，具有自己的本地（且私有的）状态。</p></blockquote><blockquote><p>进程通常代表一种更通用的虚拟处理机，它一般由操作系统实现，可以让并发处理更容易。进程也能（根据约定）被约束为以角色的形式运转，我们在这里说的就是这类进程。</p></blockquote><h2 id="提示59-用角色实现并发性时不必共享状态"><a href="#提示59-用角色实现并发性时不必共享状态" class="headerlink" title="提示59 用角色实现并发性时不必共享状态"></a>提示59 用角色实现并发性时不必共享状态</h2><h2 id="提示60-使用黑板来协调工作流"><a href="#提示60-使用黑板来协调工作流" class="headerlink" title="提示60 使用黑板来协调工作流"></a>提示60 使用黑板来协调工作流</h2><h2 id="提示61-倾听你内心的蜥蜴"><a href="#提示61-倾听你内心的蜥蜴" class="headerlink" title="提示61 倾听你内心的蜥蜴"></a>提示61 倾听你内心的蜥蜴</h2><blockquote><p>首先，停止正在做的事情。给自己一点时间和空间，让大脑自我组织。</p></blockquote><blockquote><p>让想法自己从大脑的各个层面渗透出来：对此不用很刻意。最终这些想法可能会上升到有意识的水平，这样你就能抓住一个“啊哈！”的时刻。</p></blockquote><blockquote><p>学会在编码时听从直觉是一项需要培养的重要技能。</p></blockquote><blockquote><p> 不要假设，要证明。</p></blockquote><blockquote><p>找到恰好能用的答案和找到正确的答案不是一回事。</p></blockquote><h2 id="提示62-不要依赖巧合编程"><a href="#提示62-不要依赖巧合编程" class="headerlink" title="提示62 不要依赖巧合编程"></a>提示62 不要依赖巧合编程</h2><blockquote><p>如果希望花费更少的时间来编写代码，就要在开发周期中尽可能早地捕获并修复错误，这样可以一开始就少犯错。</p></blockquote><blockquote><p>不要成为历史的奴隶。不要让现有的代码去支配未来的代码。如果不再合适，所有代码都可以替换。即使一个程序正在进展中，也不要让已经做完的事情限制下一步要做的事情——准备好重构。</p></blockquote><blockquote><p>所以下次碰到有什么事情看起来可行，但你不知道为什么，确保它不是一个巧合。</p></blockquote><h2 id="提示63-评估算法的级别"><a href="#提示63-评估算法的级别" class="headerlink" title="提示63 评估算法的级别"></a>提示63 评估算法的级别</h2><h2 id="提示64-对估算做测试"><a href="#提示64-对估算做测试" class="headerlink" title="提示64 对估算做测试"></a>提示64 对估算做测试</h2><blockquote><p>最好的不会永远最好。</p></blockquote><blockquote><p>在投入宝贵的时间尝试改进算法之前，确保算法确实是瓶颈，总是最为可取。</p></blockquote><h2 id="提示65-尽早重构，经常重构"><a href="#提示65-尽早重构，经常重构" class="headerlink" title="提示65 尽早重构，经常重构"></a>提示65 尽早重构，经常重构</h2><blockquote><p>重构的核心是重新设计。</p><ol><li><p>不要试图让重构和添加功能同时进行。</p></li><li><p>在开始重构之前，确保有良好的测试。</p></li><li><p>采取简短而慎重的步骤</p></li></ol></blockquote><h2 id="提示66-测试与找Bug无关"><a href="#提示66-测试与找Bug无关" class="headerlink" title="提示66 测试与找Bug无关"></a>提示66 测试与找Bug无关</h2><blockquote><p>测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是在运行测试的时候。</p></blockquote><h2 id="提示67-测试是代码的第一个用户"><a href="#提示67-测试是代码的第一个用户" class="headerlink" title="提示67 测试是代码的第一个用户"></a>提示67 测试是代码的第一个用户</h2><blockquote><p>测试驱动开发。</p></blockquote><blockquote><p>TDD的基本循环是：</p><ol><li><p>决定要添加一小部分功能。</p></li><li><p>编写一个测试。</p></li><li><p>运行所有测试。</p></li><li><p>尽量少写代码，只需保证测试通过即可。</p></li><li><p>重构代码：看看是否有办法改进刚刚编写的代码（测试或函数）。</p></li></ol></blockquote><blockquote><p>务必实践一下TDD。但真这样做时，不要忘记时不时停下来看看大局。</p></blockquote><h2 id="提示68-既非自上而下，也不自下而上，基于端对端构建"><a href="#提示68-既非自上而下，也不自下而上，基于端对端构建" class="headerlink" title="提示68 既非自上而下，也不自下而上，基于端对端构建"></a>提示68 既非自上而下，也不自下而上，基于端对端构建</h2><blockquote><p>我们坚信，构建软件的唯一方法是增量式的。构建端到端功能的小块，一边工作一边了解问题。应用学到的知识持续充实代码，让客户参与每一个步骤并让他们指导这个过程。</p></blockquote><blockquote><p>测试对开发的驱动绝对能有帮助。但是，就像每次驱动汽车一样，除非心里有一个目的地，否则就可能会兜圈子。</p></blockquote><h2 id="提示69-为测试做设计"><a href="#提示69-为测试做设计" class="headerlink" title="提示69 为测试做设计"></a>提示69 为测试做设计</h2><blockquote><p>如果代码出过一次问题，就有再出问题的可能性。不要将创建出来的测试扔掉，把它添加到现有的单元测试库中。</p></blockquote><blockquote><p>我的个性坚持认为，当开始觉得舒适的时候，就应该去尝试别的东西。</p></blockquote><blockquote><p>我相信这个原因就是，（对我来说）测试的好处更主要来自于思考测试，以及思考测试会对代码造成怎样的影响。在长时间坚持这样做之后，我写不写测试都会这样思考。代码仍然是可测试的，只是无须真的写出测试而已。</p></blockquote><h2 id="提示70-要对软件做测试，否则只能留给用户去做"><a href="#提示70-要对软件做测试，否则只能留给用户去做" class="headerlink" title="提示70 要对软件做测试，否则只能留给用户去做"></a>提示70 要对软件做测试，否则只能留给用户去做</h2><h2 id="提示71-使用基于特性的测试来校验假设"><a href="#提示71-使用基于特性的测试来校验假设" class="headerlink" title="提示71 使用基于特性的测试来校验假设"></a>提示71 使用基于特性的测试来校验假设</h2><blockquote><p>当基于特性的测试失败时，找出传递给测试函数的参数，然后使用这些值创建一个单独的、常规的单元测试。</p></blockquote><blockquote><p>基于特性的测试让你从不变式和契约的角度来考虑代码；你会思考什么不能改变，什么必须是真实的。这种额外的洞察力会对代码产生神奇的影响，可以消除边界情况，并突显使数据处于不一致状态的函数。</p></blockquote><blockquote><p>安全性的基本原则</p><ol><li><p>将攻击面的面积最小化</p></li><li><p>最小特权原则</p></li><li><p>安全的默认值</p></li><li><p>敏感数据要加密</p></li><li><p>维护安全更新</p></li></ol></blockquote><h2 id="提示72-保持代码简洁，让攻击面最小"><a href="#提示72-保持代码简洁，让攻击面最小" class="headerlink" title="提示72 保持代码简洁，让攻击面最小"></a>提示72 保持代码简洁，让攻击面最小</h2><h2 id="提示73-尽早打上安全补丁"><a href="#提示73-尽早打上安全补丁" class="headerlink" title="提示73 尽早打上安全补丁"></a>提示73 尽早打上安全补丁</h2><blockquote><p>不要禁用浏览器中的粘贴功能。破坏浏览器和密码管理器的功能，并不能使系统更安全。实际上，它会促使用户创建更简单、更短、更容易破解的密码。</p></blockquote><blockquote><p>当涉及加密时，第一条也是最重要的一条规则是，永远不要自己做。</p></blockquote><blockquote><p>名不正，则言不顺；言不顺，则事不成。</p></blockquote><h2 id="提示74-好好取名；需要时更名"><a href="#提示74-好好取名；需要时更名" class="headerlink" title="提示74 好好取名；需要时更名"></a>提示74 好好取名；需要时更名</h2><blockquote><p>所谓完美境界，亦非加无可加，而是减无可减……</p></blockquote><h2 id="提示75-无人确切知道自己想要什么"><a href="#提示75-无人确切知道自己想要什么" class="headerlink" title="提示75 无人确切知道自己想要什么"></a>提示75 无人确切知道自己想要什么</h2><h2 id="提示76-程序员帮助人们理解他们想要什么"><a href="#提示76-程序员帮助人们理解他们想要什么" class="headerlink" title="提示76 程序员帮助人们理解他们想要什么"></a>提示76 程序员帮助人们理解他们想要什么</h2><h2 id="提示77-需求是从反馈循环中学到的"><a href="#提示77-需求是从反馈循环中学到的" class="headerlink" title="提示77 需求是从反馈循环中学到的"></a>提示77 需求是从反馈循环中学到的</h2><blockquote><p>每次迭代都以客户的直接反馈结束。这样可使我们走上正轨，并确保如果走错了方向，损失的时间是最少的。</p></blockquote><h2 id="提示78-和用户一起工作以便从用户角度思考"><a href="#提示78-和用户一起工作以便从用户角度思考" class="headerlink" title="提示78 和用户一起工作以便从用户角度思考"></a>提示78 和用户一起工作以便从用户角度思考</h2><h2 id="提示79-策略即元数"><a href="#提示79-策略即元数" class="headerlink" title="提示79 策略即元数"></a>提示79 策略即元数</h2><h2 id="针对更普遍的情况做实现，至于系统需要支持的那种特定类型的东西，只是通用实现在加入策略信息后的示例。"><a href="#针对更普遍的情况做实现，至于系统需要支持的那种特定类型的东西，只是通用实现在加入策略信息后的示例。" class="headerlink" title="针对更普遍的情况做实现，至于系统需要支持的那种特定类型的东西，只是通用实现在加入策略信息后的示例。"></a>针对更普遍的情况做实现，至于系统需要支持的那种特定类型的东西，只是通用实现在加入策略信息后的示例。</h2><h2 id="提示80-使用项目术语表"><a href="#提示80-使用项目术语表" class="headerlink" title="提示80 使用项目术语表"></a>提示80 使用项目术语表</h2><h2 id="提示81-不要跳出框框思考——找到框框"><a href="#提示81-不要跳出框框思考——找到框框" class="headerlink" title="提示81 不要跳出框框思考——找到框框"></a>提示81 不要跳出框框思考——找到框框</h2><blockquote><p>简单地说，注意力分散的人在解决复杂问题时比有意识的人做得更好。</p></blockquote><blockquote><p>打造代码，而非打造自我。这与谁最聪明无关；我们都有许多闪光的瞬间，也有糟糕的时刻。</p></blockquote><blockquote><ul><li><p>批评要针对代码，而不针对人。“让我们看看这一块”听起来比“你搞错了”好得多。</p></li><li><p>倾听他人的观点并试着理解。观点不同不是错误。</p></li><li><p>频繁进行回顾，为下一次做好准备。</p></li></ul></blockquote><h2 id="提示82-不要一个人埋头钻进代码中"><a href="#提示82-不要一个人埋头钻进代码中" class="headerlink" title="提示82 不要一个人埋头钻进代码中"></a>提示82 不要一个人埋头钻进代码中</h2><h2 id="提示83-敏捷不是一个名词；敏捷有关你如何做事"><a href="#提示83-敏捷不是一个名词；敏捷有关你如何做事" class="headerlink" title="提示83 敏捷不是一个名词；敏捷有关你如何做事"></a>提示83 敏捷不是一个名词；敏捷有关你如何做事</h2><blockquote><p>所以下面是我们以敏捷方式工作的秘诀：</p><ol><li><p>弄清楚你在哪里。</p></li><li><p>朝想去的方向迈出有意义的最小一步。</p></li><li><p>评估在哪里终结，把弄坏的东西修好。</p></li></ol></blockquote><blockquote><p>由“魔法三连”：版本控制、测试和自动化组成的务实的入门套件。</p></blockquote><h2 id="提示84-维持小而稳定的团队"><a href="#提示84-维持小而稳定的团队" class="headerlink" title="提示84 维持小而稳定的团队"></a>提示84 维持小而稳定的团队</h2><blockquote><p>质量是一个团队问题。即使是最勤奋的开发者，只要身处一个什么都不在乎的团队中，也会发现自己很难保持修复琐碎问题所需的热情。如果团队不鼓励开发者在这些修复工作上花费时间，那么问题就会进一步恶化。</p></blockquote><blockquote><p>对项目范围扩大、时间缩短、额外特性、新的环境——任何在最初的理解中没有的东西，都要留心。</p></blockquote><blockquote><p>“只要有空闲时间”就去做，意味着这件事永远不会发生。</p></blockquote><h2 id="提示85-排上日程以待其成"><a href="#提示85-排上日程以待其成" class="headerlink" title="提示85 排上日程以待其成"></a>提示85 排上日程以待其成</h2><blockquote><p>良好的沟通是避免这些问题的关键。这里所说的“良好”，指的是即时、无摩擦力。</p></blockquote><blockquote><p>保持清醒，留意DRY 。</p></blockquote><h2 id="提示86-组织全功能的团队"><a href="#提示86-组织全功能的团队" class="headerlink" title="提示86 组织全功能的团队"></a>提示86 组织全功能的团队</h2><blockquote><p>记住团队是由个人组成的。赋予每个成员能力，让他们以自己的方式发光发热。要提供完善的架构来支持他们，并确保项目交付的价值。</p></blockquote><h2 id="提示87-做能起作用的事，别赶时髦"><a href="#提示87-做能起作用的事，别赶时髦" class="headerlink" title="提示87 做能起作用的事，别赶时髦"></a>提示87 做能起作用的事，别赶时髦</h2><blockquote><p>怎样才能知道“什么能起作用”？有一个最基本的实用技巧可以依靠，那就是：<br>试一试。</p></blockquote><blockquote><p>请注意，能够即期交付并不意味着你必须每天每分钟都交付。只有当这样做在业务上有意义时，才有必要在用户需要时即期交付。</p></blockquote><h2 id="提示88-在用户需要时交付"><a href="#提示88-在用户需要时交付" class="headerlink" title="提示88 在用户需要时交付"></a>提示88 在用户需要时交付</h2><blockquote><p>过度投资于任何一种特定的方法，会让你对其他方法视而不见。当你习惯于一种方法时，很快就看不到其他的出路了。你已经僵化，变得不再能快速适应。</p></blockquote><h2 id="提示89-使用版本控制来驱动构建、测试和发布"><a href="#提示89-使用版本控制来驱动构建、测试和发布" class="headerlink" title="提示89 使用版本控制来驱动构建、测试和发布"></a>提示89 使用版本控制来驱动构建、测试和发布</h2><h2 id="提示90-尽早测试，经常测试，自动测试"><a href="#提示90-尽早测试，经常测试，自动测试" class="headerlink" title="提示90 尽早测试，经常测试，自动测试"></a>提示90 尽早测试，经常测试，自动测试</h2><h2 id="提示91-直到所有的测试都已运行，编码才算完成"><a href="#提示91-直到所有的测试都已运行，编码才算完成" class="headerlink" title="提示91 直到所有的测试都已运行，编码才算完成"></a>提示91 直到所有的测试都已运行，编码才算完成</h2><blockquote><p>构建可能包括几种主要的软件测试类型：单元测试、集成测试、确认和验证，以及性能测试。</p></blockquote><h2 id="提示92-使用破坏者检测你的测试"><a href="#提示92-使用破坏者检测你的测试" class="headerlink" title="提示92 使用破坏者检测你的测试"></a>提示92 使用破坏者检测你的测试</h2><h2 id="提示93-测试状态覆盖率，而非代码覆盖率"><a href="#提示93-测试状态覆盖率，而非代码覆盖率" class="headerlink" title="提示93 测试状态覆盖率，而非代码覆盖率"></a>提示93 测试状态覆盖率，而非代码覆盖率</h2><h2 id="提示94-每个Bug只找一次"><a href="#提示94-每个Bug只找一次" class="headerlink" title="提示94 每个Bug只找一次"></a>提示94 每个Bug只找一次</h2><h2 id="提示95-不要使用手动程序"><a href="#提示95-不要使用手动程序" class="headerlink" title="提示95 不要使用手动程序"></a>提示95 不要使用手动程序</h2><blockquote><p>一切都要依赖于自动化。</p></blockquote><blockquote><p>用户真正要的不是代码，他们只是遇到某个业务问题，需要在目标和预算范围内解决。他们的信念是，通过与你的团队合作，能够做到这一点。</p></blockquote><blockquote><p>“需求”实际上只是对用技术可以完成哪些工作的猜测——它实际上是一个业余的实现计划，只是伪装成需求文档。如果你能证明有方法会使项目更接近目标，那么就不要害怕，大胆提出改变需求的建议。</p></blockquote><h2 id="提示96-取悦用户，而不要只是交付代码"><a href="#提示96-取悦用户，而不要只是交付代码" class="headerlink" title="提示96 取悦用户，而不要只是交付代码"></a>提示96 取悦用户，而不要只是交付代码</h2><blockquote><p>或许你的头衔只是“软件开发者”或“软件工程师”的某种变体，而事实上这个头衔应该是“解决问题的人”。这就是我们所做的，也是一个务实的程序员的本质。</p></blockquote><h2 id="提示97-在作品上签名"><a href="#提示97-在作品上签名" class="headerlink" title="提示97 在作品上签名"></a>提示97 在作品上签名</h2><blockquote><p>过去的工匠很自豪地为他们的作品签名。你也应该这样。</p></blockquote><blockquote><p>保持匿名会滋生粗心、错误、懒惰和糟糕的代码，特别是在大型项目中——很容易把自己看成只是大齿轮上的一个小齿，在无休止的工作汇报中制造蹩脚的借口，而不是写出好的代码。</p></blockquote><blockquote><p>我们这些开发者，拥有令人难以置信的特权——我们真正在建设未来，这是一股巨大的力量。伴随着这种力量而来的，是一种非同寻常的责任。</p></blockquote><h2 id="提示98-先勿伤害"><a href="#提示98-先勿伤害" class="headerlink" title="提示98 先勿伤害"></a>提示98 先勿伤害</h2><blockquote><p>有一些创造性的想法，开始打道德行为界限的擦边球，如果你参与了这类项目，就和出资者一样负有责任。</p></blockquote><h2 id="提示99-不要助纣为虐"><a href="#提示99-不要助纣为虐" class="headerlink" title="提示99 不要助纣为虐"></a>提示99 不要助纣为虐</h2><p><img src="https://wyiyi.github.io/amber/contents/2025/the-pragmatic-programmer.png"></p>]]></content>
    
    
    <summary type="html">如果想让自己的软件既领先于时代又易于维护，就在手边摆放一本《程序员修炼之道：通向务实的最高境界（第2版）。本书充满实用建议，有技术方面的，也有专业方面的，无不能让你和你的项目受益多年。</summary>
    
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/categories/Books/"/>
    
    
    <category term="Java" scheme="https://wyiyi.github.io/amber/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Chat2DB - AI驱动的数据库管理工具</title>
    <link href="https://wyiyi.github.io/amber/2025/03/20/chat2db/"/>
    <id>https://wyiyi.github.io/amber/2025/03/20/chat2db/</id>
    <published>2025-03-20T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>随着人工智能技术的飞速发展，数据库管理领域也迎来了全新的变革。<a href="https://chat2db-ai.com/"><strong>Chat2DB</strong></a>，一款基于<code>AI</code>的智能数据库管理工具，正在彻底改变我们与数据库交互的方式。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>目前，<code>Chat2DB</code> 在 <a href="https://github.com/codePhiliaX/chat2db">Github</a> 上已经累计了 21k Star，在开发者社区中很受欢迎和认可。</p><p><code>Chat2DB</code> 是一款开源的、<code>AI</code>驱动的数据库工具和<code>SQL</code>客户端，它提供现代化的图形界面，旨在加速<code>SQL</code>查询的编写、简化数据库管理、促进报告生成、数据探索以及与多种数据库的交互。该工具的核心宗旨是使数据库管理更加智能高效，同时降低技术门槛，让数据处理变得触手可及。</p><h2 id="支持多数据库"><a href="#支持多数据库" class="headerlink" title="支持多数据库"></a>支持多数据库</h2><p><code>Chat2DB</code> 不仅与主流数据库类型兼容，还全面支持国产数据库，为国内用户提供了更多选择和兼容性，满足了对数据安全和本地化服务的需求。以下是 <code>Chat2DB</code> 支持的数据库类型：</p><ul><li><p>关系型数据库（RDBMS）：<code>MySQL</code>、<code>PostgreSQL</code>、<code>Oracle</code>、<code>SQL Server</code>、<code>SQLite</code>、<code>DB2</code>、<code>达梦数据库（DM）</code>、<code>人大金仓（KingbaseES）</code>、<code>神舟通用（Shenzhou）</code>、<code>南大通用（GBase）</code>、<code>华为高斯数据库（GaussDB）</code>；</p></li><li><p>非关系型数据库（NoSQL）：<code>MongoDB</code>、<code>Redis</code>、<code>Cassandra</code>、<code>阿里云表格存储（Table Store）</code>、<code>腾讯云 TDSQL</code>、<code>华为云 GeminiDB</code>；</p></li><li><p>数据仓库与大数据平台：<code>ClickHouse</code>、<code>BigQuery</code>、<code>Snowflake</code>、<code>阿里云 AnalyticDB</code>、<code>腾讯云 CDW</code>、<code>华为云 DWS</code>；</p></li></ul><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_multi_db.png"></p><h2 id="AI-驱动的核心功能"><a href="#AI-驱动的核心功能" class="headerlink" title="AI 驱动的核心功能"></a>AI 驱动的核心功能</h2><ul><li>SQL 智能生成：仅需以自然语言描述需求，<code>Chat2DB</code>便能自动生成并执行相应的<code>SQL</code>查询。</li><li>智能报表生成：通过简单的指令，即可生成数据报表、绘制图表，甚至进行趋势预测。</li><li>智能表结构生成：利用 AI 快速设计和生成数据库表结构，方便数据建模。</li></ul><h1 id="Chat2DB-3-0-实战"><a href="#Chat2DB-3-0-实战" class="headerlink" title="Chat2DB 3.0 实战"></a>Chat2DB 3.0 实战</h1><p>在传统的数据库管理中，从手动建表到后端开发再到测试，需要逐个输入字段，同时还要考虑命名、长度设置和索引建立等问题，用 <code>Chat2DB</code> 实践实际操作，将传统数据库管理工具升级为智能工具。</p><h2 id="1-帮我创建表结构：AI-一键建表"><a href="#1-帮我创建表结构：AI-一键建表" class="headerlink" title="1. 帮我创建表结构：AI 一键建表"></a>1. 帮我创建表结构：AI 一键建表</h2><p>点击 <code>Table Copilot</code>，用户只需输入自定义的表名及列名并回车执行，点击<code>Run</code>执行<code>sql</code>语句，即可快速生成表结构。<br>在执行过程中，若遇到格式不支持的情况，<code>Chat2DB</code>会自动转换对应数据库格式进行处理。</p><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_create_table.png"></p><h2 id="2-帮我生成后端代码：代码自动生成"><a href="#2-帮我生成后端代码：代码自动生成" class="headerlink" title="2. 帮我生成后端代码：代码自动生成"></a>2. 帮我生成后端代码：代码自动生成</h2><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_code_generate.png"></p><ul><li>能够根据数据库表结构，自动生成增删改查<code>（CRUD）</code>操作的代码，覆盖常见开发场景，助力开发者快速构建基础功能。</li><li>支持<code>Java</code>、<code>Python</code>、<code>C</code>、<code>C++</code>等多种语言，满足不同开发需求。</li><li>无论是<code>DAO</code>层代码还是实体类，<code>Chat2DB</code>都能一键生成，显著提升开发效率。</li></ul><h2 id="3-帮我写查询：自然语言查询"><a href="#3-帮我写查询：自然语言查询" class="headerlink" title="3. 帮我写查询：自然语言查询"></a>3. 帮我写查询：自然语言查询</h2><p>用户只需以自然语言描述查询需求，Chat2DB便能智能生成SQL语句，并自动生成图表。</p><p>例如，描述“PERSON表与ORG表按ORG_ID关联，分组统计人员姓名name的数量，并生成折线图”，<code>Chat2DB</code>即可实现。</p><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_sql.gif"></p><h2 id="4-帮我优化SQL语句"><a href="#4-帮我优化SQL语句" class="headerlink" title="4. 帮我优化SQL语句"></a>4. 帮我优化SQL语句</h2><p><code>Chat2DB</code>还能智能分析并优化<code>SQL</code>语句，提高查询效率。用户只需提供原始<code>SQL</code>语句，<code>Chat2DB</code>便会给出优化建议。</p><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_sql_yh.gif"></p><p>AI SQL 优化能够自动调整查询执行计划、索引设计和数据存储方式，以最大程度地减少查询时间和资源消耗。<br>通过机器学习算法的学习能力，系统能够根据历史数据和当前查询模式自动调整这些参数，从而确保查询执行的高效性和准确性。</p><h2 id="5-智能报表生成"><a href="#5-智能报表生成" class="headerlink" title="5. 智能报表生成"></a>5. 智能报表生成</h2><p>在数据展示方面，Chat2DB 提供了图形化报表的自动生成功能，使得数据的呈现更加直观和易于理解。</p><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_dashboard.png"></p><h2 id="6-自动化数据库管理"><a href="#6-自动化数据库管理" class="headerlink" title="6. 自动化数据库管理"></a>6. 自动化数据库管理</h2><p><code>Chat2DB</code> 可以自动执行常见的数据库管理任务，如备份、优化、索引重建等。<br>只需要告诉它：“帮我备份今天的数据库”，剩下的工作就交给<code>Chat2DB</code>吧。</p><h1 id="大模型全家桶"><a href="#大模型全家桶" class="headerlink" title="大模型全家桶"></a>大模型全家桶</h1><p>在<code>Chat2DB 3.0</code>版本中，AI问答功能增加了多种模型选择，用户可一键切换体验代码模型、推理模型和混合模型等10余种先进模型，进一步巩固了<code>Chat2DB</code>在数据库领域的功能性和智能化优势。</p><h1 id="ER-图生成"><a href="#ER-图生成" class="headerlink" title="ER 图生成"></a>ER 图生成</h1><p><code>Chat2DB</code> 还支持自动生成数据库的实体关系图（<code>ER 图</code>），帮助用户直观地理解数据库结构。通过<code>ER</code>图，用户可以快速识别表间关系，优化数据库设计，并可将其直接应用于技术文档。</p><p><img src="https://wyiyi.github.io/amber/contents/2024/chat2db_er.png"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><code>Chat2DB</code> 是一个智能数据库管理工具，它利用人工智能技术，为数据库管理员和开发人员提供更智能、更高效的解决方案。<br>通过自然语言查询、智能表结构创建、智能报表生成、代码生成、自动化数据库管理等核心功能，<code>Chat2DB</code> 极大地提升了数据库管理的效率和开发者的生产力。</p>]]></content>
    
    
    <summary type="html">随着人工智能技术的飞速发展，数据库管理领域也迎来了全新的变革。`Chat2DB` 一款基于`AI`的智能数据库管理工具，正在彻底革新我们与数据库交互的方式。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="DB" scheme="https://wyiyi.github.io/amber/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>博弈论：每个人都能成为决策高手（《人民日报》推荐）</title>
    <link href="https://wyiyi.github.io/amber/2025/02/01/boyilun/"/>
    <id>https://wyiyi.github.io/amber/2025/02/01/boyilun/</id>
    <published>2025-02-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本书的写作目标有三个，分别是：看得懂、记得住、会应用。</p></blockquote><blockquote><p>本书会告诉你如何让自己的策略和行为变得难以被预测或者容易被预测，在什么情况下你会被对手的“真话”所欺骗，是否应该相信他人的承诺或威胁，如何让自己跳出生活或工作中的一些常见陷阱（如囚犯困境、万元陷阱等）。</p></blockquote><h1 id="第1章-田忌赛马：你若是齐王会怎么办"><a href="#第1章-田忌赛马：你若是齐王会怎么办" class="headerlink" title="第1章 田忌赛马：你若是齐王会怎么办"></a>第1章 田忌赛马：你若是齐王会怎么办</h1><blockquote><p>参与约束是指参与者从游戏中获得的期望收益要大于（或不小于）从其他活动中能获得的最大期望收益（该收益可称为“保留效用”）。</p></blockquote><blockquote><p>一个好玩的游戏，往往是80%左右靠实力，20%左右拼运气。80%靠实力才会激励人们去努力；20%拼运气，才能给弱者以希望和机会。</p></blockquote><h1 id="第2章-所罗门王断案：如何一招辨真伪"><a href="#第2章-所罗门王断案：如何一招辨真伪" class="headerlink" title="第2章 所罗门王断案：如何一招辨真伪"></a>第2章 所罗门王断案：如何一招辨真伪</h1><blockquote><p>人类社会的大多数博弈都是不完全信息博弈。</p></blockquote><blockquote><p>信息甄别的关键是“下套”，引诱或逼迫信息优势方采取对策来披露信息，实现信息共享。</p></blockquote><h1 id="第3章-蜈蚣博弈：不做炒房、炒股的接盘侠"><a href="#第3章-蜈蚣博弈：不做炒房、炒股的接盘侠" class="headerlink" title="第3章 蜈蚣博弈：不做炒房、炒股的接盘侠"></a>第3章 蜈蚣博弈：不做炒房、炒股的接盘侠</h1><blockquote><p>投资和投机的差别在于，投资是通过购买物创造新价值来获得收益，投机则是通过赚取差价来获得收益。</p></blockquote><blockquote><p>博傻理论告诉我们的道理是：傻不可怕，只要不是最傻的。只要自己不是那个最大的“笨蛋”，那么自己就一定是赢家，只是赢多赢少的问题。</p></blockquote><blockquote><p>购买一样东西最好不要基于对物品价格变化的判断，而要基于物品本身的效用。</p></blockquote><h1 id="第4章-博弈论的前世今生"><a href="#第4章-博弈论的前世今生" class="headerlink" title="第4章 博弈论的前世今生"></a>第4章 博弈论的前世今生</h1><blockquote><p>对“博弈”的理解，中外基本一致的认识是：博弈是一种双方（多方）的对抗（比赛），对抗总是在一定的规则下进行，参与者必然会考虑应用相应的策略（计谋），并尽可能让自己获胜。</p></blockquote><blockquote><p>博弈论不同于博弈，博弈论是对博弈的理论研究，通过对博弈的理论分析从而提升人们的博弈能力。</p></blockquote><blockquote><p>小生产者之间的充分竞争日益被大企业之间的寡头竞争所取代。</p></blockquote><blockquote><p>原来对抗的博弈，可以因为重复进行而达到默契的合作，给博弈各方都带来好处。</p></blockquote><blockquote><p>我们有理由相信，博弈论将成为解释冲突、建立合作、增进信任、促进社会经济发展的重要理论。</p></blockquote><h1 id="第5章-博弈类型和结构化思维"><a href="#第5章-博弈类型和结构化思维" class="headerlink" title="第5章 博弈类型和结构化思维"></a>第5章 博弈类型和结构化思维</h1><blockquote><p>博弈的分类最常见的有两种，一种是分为静态博弈和动态博弈，另一种是分为完全信息博弈与不完全信息博弈。</p><blockquote><ul><li>静态博弈是指在博弈中，参与者同时选择或虽非同时选择但后行动者并不知道先行动者采取了什么具体行动（虽然在物理时间上不是同时的，但是在逻辑时间上是同时的）。</li><li>动态博弈是指在博弈中，参与者的行动有先后顺序，且后行动者能够观察到先行动者所选择的行动。</li></ul></blockquote></blockquote><blockquote><p>无论是个体还是群体，只有多参与正和博弈，才能推动社会财富和个人财富的持续增长。这也是市场经济能够迅速创造社会财富的根本奥秘之所在。</p></blockquote><h1 id="第6章-术语解读：让你的思考与众不同"><a href="#第6章-术语解读：让你的思考与众不同" class="headerlink" title="第6章 术语解读：让你的思考与众不同"></a>第6章 术语解读：让你的思考与众不同</h1><blockquote><p>纳什均衡的释义就是：给定你的策略，我的策略就是对我而言最好的策略（或之一）；给定我的策略，你的策略也是对你来说最好的策略（或之一），即双方在对方给定的策略下已经没有积极性调整自己已选的策略。</p></blockquote><blockquote><p>资源多寡和能力大小决定了行动空间的范围，不采取行动也是一种行动选择，没有人是别无选择的。</p></blockquote><blockquote><p>损益是每个参与者最关心的内容。参与者所有选择的目标是实现利益的最大化。</p></blockquote><h1 id="第7章-策略探究：让你学会有备无患"><a href="#第7章-策略探究：让你学会有备无患" class="headerlink" title="第7章 策略探究：让你学会有备无患"></a>第7章 策略探究：让你学会有备无患</h1><blockquote><p>策略的定义：策略是指参与者在行动之前所准备好的一套完整的行动方案或行动预案。</p></blockquote><blockquote><p>策略的作用就在于，让你尽可能多地想到各种各样的可能性，以便于做到无论发生什么事情，你都能够快速做出反应。</p></blockquote><blockquote><p>你永远不可能别无选择，因为你至少可以选择什么都不做。</p></blockquote><blockquote><p>一个人可以选择不行善，但一定不能选择去作孽；一个人可以选择不说真话，但一定不要去说假话。</p></blockquote><blockquote><p>一个人的成长意味着懂得了越来越多的策略，只有这样，我们才能有备无患，万无一失。</p></blockquote><blockquote><p>好的应急预案包括四要素：明确的信息分类、责任到人、措施具体、时效性。</p></blockquote><h1 id="第8章-理性假设：驴也是这么想的"><a href="#第8章-理性假设：驴也是这么想的" class="headerlink" title="第8章 理性假设：驴也是这么想的"></a>第8章 理性假设：驴也是这么想的</h1><blockquote><p>我们只是想象着人是理性的，然后去推理和判断人在理性的状态下会怎么做选择，以及最后的结果又会是什么。</p></blockquote><blockquote><p>人的理性意味着“知好歹、能传递、取中间”。</p></blockquote><h2 id="1-偏好的完备性和情境理性"><a href="#1-偏好的完备性和情境理性" class="headerlink" title="1. 偏好的完备性和情境理性"></a>1. 偏好的完备性和情境理性</h2><blockquote><p>从博弈论的角度来看，一个理性的人，首先是一个有判断能力的人。一个有判断能力的人，首先能够分得清楚好坏。如果给你两样东西，你能够分辨出更喜欢哪一个。人的理性首先意味着他的偏好是完备的。</p></blockquote><blockquote><p>人对事物的偏好既取决于自身，也取决于具体的情境。</p></blockquote><blockquote><p>没有人能够在“真空”中做决策，一个人凭什么这么说，凭什么这么做，所有的判断和选择都基于某个参照系，不同的参照系会导致不同的判断和不同的选择。</p></blockquote><h2 id="2-偏好的可传递性"><a href="#2-偏好的可传递性" class="headerlink" title="2. 偏好的可传递性"></a>2. 偏好的可传递性</h2><blockquote><p>偏好的可传递性可以确保一个人能在一堆东西中区分出好坏，选出自己最喜欢的东西。</p></blockquote><h2 id="3-偏好的中庸性"><a href="#3-偏好的中庸性" class="headerlink" title="3. 偏好的中庸性"></a>3. 偏好的中庸性</h2><blockquote><p>偏好的中庸性告诉我们，虽然每个人的偏好不同，但如果两端是一样的，那中间就是更好的。</p></blockquote><blockquote><p>在管理中，物质激励是员工所需要的，而精神激励也是员工所需要的。给予偏好物质的员工更多的物质激励，给予偏好精神的员工更多的精神激励。</p></blockquote><blockquote><p>人在博弈中追求利益最大化，并不是指人只追求金钱数量的最大化，否则我们连对花钱去消费的行为都无法给出一个合理的解释。</p></blockquote><h1 id="第9章-共同知识：教你避免被误会"><a href="#第9章-共同知识：教你避免被误会" class="headerlink" title="第9章 共同知识：教你避免被误会"></a>第9章 共同知识：教你避免被误会</h1><blockquote><p>博弈决策与单人决策之间最大的区别在于博弈具有互动性，即你的决策收益取决于你和对方的共同决策。你无法独自直接决定自己的收益。在这种情况下，若想自己的收益最大化，必须基于对对方决策行为的预测分析，并在此基础上选择最大化自己收益的策略。</p></blockquote><blockquote><p>大家一定要明白，当两个人面对面交谈时，至少是6个人在交谈：你以为的你，他以为的你，真正的你；他以为的他，你以为的他，真正的他。</p></blockquote><blockquote><p>共同知识只能是一种理想状态的假设。</p></blockquote><blockquote><p>人与人之间彼此发生误会是常态，你要学会接受这一点。</p></blockquote><blockquote><p>反复交流和多渠道沟通是避免被误会的最有效手段。</p></blockquote><h1 id="第10章-博弈描述：真正的入门在这里"><a href="#第10章-博弈描述：真正的入门在这里" class="headerlink" title="第10章 博弈描述：真正的入门在这里"></a>第10章 博弈描述：真正的入门在这里</h1><blockquote><p>描述一个博弈的关键要素是：参与人、策略（行动）和损益。</p></blockquote><blockquote><p>建立博弈模型后，可以通过不同结局之间的相互比较对均衡结果进行深入分析。</p></blockquote><h1 id="第11章-懦夫博弈：大国博弈的均衡解"><a href="#第11章-懦夫博弈：大国博弈的均衡解" class="headerlink" title="第11章 懦夫博弈：大国博弈的均衡解"></a>第11章 懦夫博弈：大国博弈的均衡解</h1><blockquote><p>只要资源稀缺，利益冲突不可避免。</p></blockquote><blockquote><p>懦夫博弈中的先动优势既是基于行动的先动优势，又是基于信息传递的先动优势。</p></blockquote><blockquote><p> 在懦夫博弈中，精神层面的损失也需要考虑到损益中去，这样才能更好地理解现实中的博弈结果。</p></blockquote><blockquote><p>过度激励会导致过度竞争。重赏之下会出现勇夫，也会出现莽夫。组织的管理者必须把握好激励的力度。</p></blockquote><blockquote><p>赢者通吃同样会导致过度竞争。在这种博弈中，请反复估量自己胜出的可能性有多大。一般情况下的理性选择是不参与博弈的。</p></blockquote><h1 id="第12章-夫妻博弈：明年过年去谁家"><a href="#第12章-夫妻博弈：明年过年去谁家" class="headerlink" title="第12章 夫妻博弈：明年过年去谁家"></a>第12章 夫妻博弈：明年过年去谁家</h1><blockquote><p>在所有的合作关系中，都会涉及合作收益的分配问题。如果一方独享合作收益，另一方一定没有参与合作的积极性，所以双方都能从中获益是每一方参与合作的前提。</p></blockquote><blockquote><p>提前约定合作收益的分配是避免矛盾冲突的有效手段。</p></blockquote><h1 id="第13章-囚犯困境：没人愿意坐以待毙"><a href="#第13章-囚犯困境：没人愿意坐以待毙" class="headerlink" title="第13章 囚犯困境：没人愿意坐以待毙"></a>第13章 囚犯困境：没人愿意坐以待毙</h1><blockquote><p>囚犯困境描述的是这么一种博弈类型：每个人追求自己利益最大化的行为选择，导致双方利益最终被损害。</p></blockquote><blockquote><p>囚犯困境的原因在于：每个人让自己利益增加，是以他人利益的更大损失为代价。</p></blockquote><blockquote><p>囚犯困境给了我们一个非常重要的启示是：博弈的均衡结果和事实的真相无关，只取决于博弈的规则！</p></blockquote><blockquote><p>走出囚犯困境的途径包括制度创新、道德教化、历史记忆和不断地重复博弈。</p></blockquote><h1 id="第14章-万元陷阱：你必须有一种归零心态"><a href="#第14章-万元陷阱：你必须有一种归零心态" class="headerlink" title="第14章 万元陷阱：你必须有一种归零心态"></a>第14章 万元陷阱：你必须有一种归零心态</h1><blockquote><p>第一，确立你投入的极限及预先的约定。譬如你计划花多少钱或多少时间去做一件事。第二，极限一经确立，就要坚持到底，一定不要轻易改变。第三，自己打定主意，尽量不受他人影响，避免出现“从众心理”。第四，不断提醒自己继续投入的代价。</p></blockquote><blockquote><p>第一，不要指望天上掉馅饼，就算真的掉馅饼，也要起得早才有机会捡到。</p></blockquote><blockquote><p>第二，尽快传递“势在必得”的信号。</p></blockquote><blockquote><p>第三，建立愿意与他人共享利益的声誉。</p></blockquote><blockquote><p>避免万元陷阱的最有效策略是及时止损。相信你一定可以从胡玮炜（摩拜单车创始人）和戴威（ofo小黄车创始人）的不同结局中充分体会到及时止损的重要性和必要性。</p></blockquote><h1 id="第15章-智猪博弈：富人行善，穷人点赞"><a href="#第15章-智猪博弈：富人行善，穷人点赞" class="headerlink" title="第15章 智猪博弈：富人行善，穷人点赞"></a>第15章 智猪博弈：富人行善，穷人点赞</h1><blockquote><p>解决个体理性与集体理性之间的冲突不是靠否定个体理性，而是靠修改制度（游戏规则），从而在满足个体理性的基础上实现集体理性。</p></blockquote><blockquote><p>正如电影《蜘蛛侠》中的一句台词：“能力越大，责任越大。”选择做大猪，虽然很多时候有委屈，但是，当他意识到自己对群体的贡献时，内心想必也是充满自豪感的。</p></blockquote><blockquote><p>智猪博弈是一种搭便车博弈，允许搭便车有利于社会总福利的增加。</p></blockquote><blockquote><p> 富人愿意行善，离不开穷人的点赞。是穷人，请多点赞；是富人，请多行善。能力越大，责任越大。</p></blockquote><blockquote><p>山寨产品是厂家的搭便车行为。网络购物让买家也变得容易搭便车，从而降低了我们的购物成本。</p></blockquote><h1 id="第16章-猜谜博弈：散户如何赢庄家"><a href="#第16章-猜谜博弈：散户如何赢庄家" class="headerlink" title="第16章 猜谜博弈：散户如何赢庄家"></a>第16章 猜谜博弈：散户如何赢庄家</h1><blockquote><p>如果一个策略规定参与者在每一个给定信息情况下只选择一种特定的行动，我们称该策略为“纯策略”。如果一个策略规定参与者在给定信息情况下，以某种概率分布随机地选择不同的行动，我们称该策略为“混合策略”。</p></blockquote><blockquote><p>正如股市里庄家和散户的博弈中，散户就算猜对庄家的概率超过50%（具体的数值是34/64。具体的计算方法是我写“黑”你猜“黑”的概率是9÷64=3÷83÷8，加上我写“白”你猜“白”的概率是25÷64=5÷85÷8），博弈到最后散户依然是亏的。</p></blockquote><blockquote><p>学会求解混合策略是提高博弈能力的有效途径。</p></blockquote><blockquote><p>很多看似公平的游戏隐含着对你不利的结果。</p></blockquote><blockquote><p>懂得了混合策略的道理，我们会相对看淡博弈的输赢，而看重如何在重复博弈中最终胜出。</p></blockquote><h1 id="第17章-猎鹿博弈：怎么才能更好地合作"><a href="#第17章-猎鹿博弈：怎么才能更好地合作" class="headerlink" title="第17章 猎鹿博弈：怎么才能更好地合作"></a>第17章 猎鹿博弈：怎么才能更好地合作</h1><blockquote><p>这种通过协调找到均衡点的博弈不仅仅局限于猎鹿博弈、夫妻博弈这样的合作关系中，即便是之前介绍的懦夫博弈也同样如此。两个人同时站在一个门口要进去，这个门很小，每次只能进去一个人。这个时候为了避免出现碰撞，总会有人先进去，有人后进去。靠什么来协调呢？一般是靠文化、道德或习俗。</p></blockquote><blockquote><p>猎鹿博弈描述了合作比单干好的博弈关系。</p></blockquote><blockquote><p>猎鹿博弈中沟通有用，囚犯困境中沟通没用。</p></blockquote><blockquote><p>人类挤在城市的重要原因是可以降低人与人之间的协调成本。</p></blockquote><blockquote><p>人类文明一定会朝着不断降低协调成本的方向演进。</p></blockquote><h1 id="第18章-石头、剪子、布：胜留败走的制胜之道"><a href="#第18章-石头、剪子、布：胜留败走的制胜之道" class="headerlink" title="第18章 石头、剪子、布：胜留败走的制胜之道"></a>第18章 石头、剪子、布：胜留败走的制胜之道</h1><blockquote><p>人不可能做到真正的随机，只有机器才能做到真正的随机</p></blockquote><blockquote><p>在“石头、剪子、布”的游戏中，人们的习惯性策略是：胜留败走。</p></blockquote><blockquote><p>目标或利益一致是彼此信任的基础。</p></blockquote><blockquote><p>小得失相信人，大得失怀疑人。</p></blockquote><h1 id="第19章-监督博弈：老板与员工的斗智斗勇"><a href="#第19章-监督博弈：老板与员工的斗智斗勇" class="headerlink" title="第19章 监督博弈：老板与员工的斗智斗勇"></a>第19章 监督博弈：老板与员工的斗智斗勇</h1><blockquote><p>由于不确定性（无法对合作的总收益进行准确预期）和团队生产（team–production，每个成员的投入和对整体收益的贡献难以准确度量），使得企业难以完全依每个成员对整体收益的贡献分配报酬。</p></blockquote><blockquote><p>工资高低既取决于贡献也取决于监督成本。</p></blockquote><blockquote><p>降低监督成本可以让雇主少付工资。</p></blockquote><blockquote><p>在知识经济时代，雇主和员工共享利润是大势所趋。</p></blockquote><h1 id="第20章-征税博弈：政府如何进行税收检查"><a href="#第20章-征税博弈：政府如何进行税收检查" class="headerlink" title="第20章 征税博弈：政府如何进行税收检查"></a>第20章 征税博弈：政府如何进行税收检查</h1><blockquote><p>虽然这个征税博弈不存在纯策略纳什均衡，但是它存在一个混合策略的纳什均衡。也就是说，税务机关会以一定的概率来检查（称之为抽查），纳税人以一定的概率来逃税（称之为抽逃税款）。</p></blockquote><blockquote><p>这恰恰充分体现了博弈的特点，你在考虑自己策略选择的时候必须先考虑对方的反应是什么。只有把对方的反应也作为自己决策依据的时候，我们才能做出对自己最有利的选择。</p></blockquote><blockquote><p>税收通过某种强制性，来避免出现类似“囚犯困境”的糟糕结局。</p></blockquote><blockquote><p>借助博弈论的分析工具，从游戏规则的角度去透视社会现象背后的奥秘，是本书最想教给你的博弈思维。</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>计算机之父、博弈论创始人之一冯·诺伊曼曾言：人生是永不停息的博弈过程，博弈意味着通过选择合适策略达到合意结果。作为博弈者，最佳策略是如何最大限度地利用游戏规则；作为社会的最佳策略，是如何通过规则引导社会整体福利的增加。</p></blockquote>]]></content>
    
    
    <summary type="html">本书会告诉你如何让自己的策略和行为变得难以被预测或者容易被预测，在什么情况下你会被对手的“真话”所欺骗，是否应该相信他人的承诺或威胁，如何让自己跳出生活或工作中的一些常见陷阱（如囚犯困境、万元陷阱等）。</summary>
    
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/categories/Books/"/>
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>解析 Spring 计划任务执行多次之谜及解决方案</title>
    <link href="https://wyiyi.github.io/amber/2024/11/01/Scheduled/"/>
    <id>https://wyiyi.github.io/amber/2024/11/01/Scheduled/</id>
    <published>2024-11-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.616Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Spring</code>项目中，<code>@Scheduled</code>注解配置的计划任务（<code>Scheduled Tasks</code>）可能会出现执行多次的情况，尤其是在以下场景中：</p><ul><li>一个父类定义了<code>@Scheduled</code>注解的方法，且被多个子类继承。</li><li>父类或子类被<code>Spring</code>容器错误地实例化为多个<code>Bean</code>实例。</li></ul><p>本文将针对该特定场景，剖析导致计划任务重复执行的原因，并针对性地提出解决措施。</p><h2 id="一、现象描述"><a href="#一、现象描述" class="headerlink" title="一、现象描述"></a>一、现象描述</h2><p>在<code>Spring</code>项目中，我们定义了一个计划任务类<code>ScheduledTaskParent</code>，以及两个继承该类的子类<code>FirstChild</code>和<code>SecondChild</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTaskParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ScheduledTaskParent 执行计划任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstChild</span> <span class="keyword">extends</span> <span class="title class_">ScheduledTaskParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FirstChild 执行特定的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondChild</span> <span class="keyword">extends</span> <span class="title class_">ScheduledTaskParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">secondTak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SecondChild 执行计划任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用启动后，发现<code>ScheduledTaskParent</code>中的计划任务被执行了多次，具体表现为每个子类实例都执行了父类的计划任务，导致执行次数为子类数目加1。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FirstChild 执行特定的操作</span><br><span class="line">ScheduledTaskParent 执行计划任务</span><br><span class="line">ScheduledTaskParent 执行计划任务</span><br><span class="line">SecondChild 执行计划任务</span><br><span class="line">ScheduledTaskParent 执行计划任务</span><br></pre></td></tr></table></figure><h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h2><blockquote><p>As of Spring Framework 4.3, @Scheduled methods are supported on beans of any scope.</p><p>Make sure that you are not initializing multiple instances of the same @Scheduled annotation class at runtime, unless you do want to schedule callbacks to each such instance. Related to this, make sure that you do not use @Configurable on bean classes that are annotated with @Scheduled and registered as regular Spring beans with the container. Otherwise, you would get double initialization (once through the container and once through the @Configurable aspect), with the consequence of each @Scheduled method being invoked twice.</p></blockquote><p><a href="https://docs.spring.io/spring-framework/reference/integration/scheduling.html">Spring 官方文档 </a>提到，从<code>Spring Framework 4.3</code>开始，<code>@Scheduled</code>注解支持任何作用域的<code>bean</code>。但是，文档也警告，不应该在运行时初始化同一<code>@Scheduled</code>注解类的多个实例，除非希望每个实例都调度回调。</p><p>在例子中，<code>ScheduledTaskParent</code>被标记为<code>@Component</code>，因此<code>Spring</code>容器会为其创建一个<code>bean</code>。由于<code>FirstChild</code>和<code>SecondChild</code>都继承了<code>ScheduledTaskParent</code>，并且它们也被标记为<code>@Component</code>，<code>Spring</code>容器为每个子类也创建了<code>bean</code>。每个<code>bean</code>都包含<code>performTask</code>方法上的<code>@Scheduled</code>注解，因此每个<code>bean</code>都会触发该任务的调度。</p><p>这就是为什么<code>performTask</code>被执行了三次：<br>一次来自<code>ScheduledTaskParent</code>的<code>bean</code>，一次来自<code>FirstChild</code>的<code>bean</code>，还有一次来自<code>SecondChild</code>的<code>bean</code>。</p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>为了防止计划任务在子类中被重复执行，我们可以在父类中定义一个抽象方法，并在子类中实现具体的计划任务。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ScheduledTaskParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstChild</span> <span class="keyword">extends</span> <span class="title class_">ScheduledTaskParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FirstChild 执行特定的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondChild</span> <span class="keyword">extends</span> <span class="title class_">ScheduledTaskParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SecondChild 执行计划任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，确保每个计划任务只被调度一次，即使有多个子类继承了父类。</p>]]></content>
    
    
    <summary type="html">在`Spring`项目中，`@Scheduled`注解配置的计划任务（`Scheduled Tasks`）可能会出现执行多次的情况</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://wyiyi.github.io/amber/tags/Java/"/>
    
    <category term="Spring" scheme="https://wyiyi.github.io/amber/tags/Spring/"/>
    
    <category term="Scheduled" scheme="https://wyiyi.github.io/amber/tags/Scheduled/"/>
    
  </entry>
  
  <entry>
    <title>非暴力沟通</title>
    <link href="https://wyiyi.github.io/amber/2024/10/01/nonviolent/"/>
    <id>https://wyiyi.github.io/amber/2024/10/01/nonviolent/</id>
    <published>2024-10-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/30640828/">豆瓣评分 7.8</a></p><blockquote><p>使用暴力的人其实是因为他们内心的宁静遭到了破坏，所以他们才会用暴力的方式维护或寻求心灵的和平。这或许是暴力的蝴蝶效应吧。”</p></blockquote><blockquote><p>非暴力沟通提醒我们人性是相通的——虽然每个人的价值观和生活方式或许不同，但作为人却有着共同的感受和需要。这样，在发生矛盾和冲突的时候，运用非暴力沟通，我们将能专注于彼此的感受和需要，从而促进倾听、理解以及由衷的互助。</p></blockquote><h1 id="第一章-让爱融入生活"><a href="#第一章-让爱融入生活" class="headerlink" title="第一章 让爱融入生活"></a>第一章 让爱融入生活</h1><blockquote><p>也许我们并不认为自己的谈话方式是“暴力”的，但我们的语言确实常常引发自己和他人的痛苦。后来，我发现了一种沟通方式，依照它来谈话和聆听，能使我们情意相通，乐于互助。我称之为“非暴力沟通”。</p></blockquote><blockquote><p>非暴力沟通指导我们转变谈话和聆听的方式。我们不再条件反射式地反应，而是去明了自己的观察、感受和愿望，有意识地使用语言。我们既诚实、清晰地表达自己，又尊重与倾听他人。这样，在每一次互动中，我们都能聆听到自己和他人心灵深处的呼声。同时，它还促使我们仔细观察，发现正影响我们的行为和事件，并提出明确的请求。</p></blockquote><blockquote><p>非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。有些人用非暴力沟通理解自己，有些人用它改善人际关系，还有人借助它改进工作。在世界各地，非暴力沟通被用来协调各个层面的争论和冲突。</p></blockquote><h1 id="第二章-是什么蒙蔽了爱？"><a href="#第二章-是什么蒙蔽了爱？" class="headerlink" title="第二章 是什么蒙蔽了爱？"></a>第二章 是什么蒙蔽了爱？</h1><blockquote><p>对他人的评价实际上反映了我们的需要和价值观。</p></blockquote><blockquote><p>重要的是，在这里，我们不要将价值判断与道德评判混为一谈。什么是可贵的品质，我们每个人都有自己的看法。例如，我们也许会欣赏诚实、自由以及和平的价值。价值判断反映了我们的信念——生命的需要怎样才能得到最好的满足。</p></blockquote><blockquote><p>暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方——至少大部分暴力的根源都是如此，不论是语言、精神或身体的暴力，还是家庭、部落以及国家的暴力。</p></blockquote><blockquote><p>一旦意识不到我们是自己的主人，我们就成了危险人物。</p></blockquote><blockquote><p>人天生热爱生命，乐于互助。可是，异化的沟通方式使我们难以体会到心中的爱。道德评判就是其中的一种，它将不符合我们价值观的人看作是不道德的或邪恶的。进行比较也是一种评判，它会蒙蔽对人对己的爱意。异化的沟通方式还淡化了我们对自己的思想、情感和行为的责任意识。此外，强人所难也会造成心灵的隔阂。</p></blockquote><h1 id="第三章-区分观察和评论"><a href="#第三章-区分观察和评论" class="headerlink" title="第三章 区分观察和评论"></a>第三章 区分观察和评论</h1><blockquote><p>非暴力沟通的第一个要素是观察。</p></blockquote><blockquote><p>不带评论的观察是人类智力的最高形式。</p></blockquote><blockquote><p>如果我们的表达言过其实，别人就可能产生逆反心理，而不愿作出友善的回应。</p></blockquote><h1 id="第四章-体会和表达感受"><a href="#第四章-体会和表达感受" class="headerlink" title="第四章 体会和表达感受"></a>第四章 体会和表达感受</h1><blockquote><p>非暴力沟通的第二个要素是感受。</p></blockquote><blockquote><p>区分感受和自我评价。</p></blockquote><blockquote><p>区分感受和判断。</p></blockquote><blockquote><p>通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。在表达感受时，示弱有助于解决冲突。</p></blockquote><h1 id="第五章-感受的根源"><a href="#第五章-感受的根源" class="headerlink" title="第五章 感受的根源"></a>第五章 感受的根源</h1><blockquote><p>“困扰人的不是事情本身，而是对事情的看法。”——爱比克泰德（Epictetus）</p></blockquote><blockquote><p>听到不中听的话的四种选择：<br>1.责备自己 2.指责他人 3.体会自己的感受和需要 4.体会他人的感受和需要</p></blockquote><blockquote><p>对于大多数人来说，个人成长一般会经历三个阶段：<br>（1）“情感的奴隶”——我们认为自己有义务使他人快乐；<br>（2）“面目可憎”时期——此时，我们拒绝考虑他人的感受和需要；<br>（3）“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。</p></blockquote><h1 id="第六章-请求帮助"><a href="#第六章-请求帮助" class="headerlink" title="第六章 请求帮助"></a>第六章 请求帮助</h1><blockquote><p>首先，清楚地告诉对方，我们希望他们做什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底想要什么。而且，这样的请求还容易引起别人的反感。</p></blockquote><blockquote><p>参加集体讨论时，说清楚我们希望得到怎样的反馈，是至关重要的。如果不清楚发言的目的，我们的讨论也许只是在浪费时间，而无法满足任何人的需要。</p></blockquote><blockquote><p>如果我们在过去常常指责他人，那么，我们的请求很可能就会被看作是命令。而一个经常受到指责的人也会倾向于将请求解读为命令。</p></blockquote><blockquote><p>如何区分命令和请求：<br>请求没有得到满足时，提出请求的人如果批评和指责，那就是命令；<br>如果想利用对方的内疚来达到目的，也是命令。</p></blockquote><blockquote><p>在发言时，我们将自己想要的回应讲得越清楚，就越有可能得到理想的回应。由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。特别是在集体讨论中发言时，我们需要清楚地表明自己的期待。否则，讨论可能只是在浪费大家的时间。</p></blockquote><blockquote><p>非暴力沟通的目的不是为了改变他人来迎合我们。相反，非暴力沟通重视每个人的需要，它的目的是帮助我们在诚实和倾听的基础上与人联系。</p></blockquote><h1 id="第七章-用全身心倾听"><a href="#第七章-用全身心倾听" class="headerlink" title="第七章 用全身心倾听"></a>第七章 用全身心倾听</h1><blockquote><p>为了倾听他人，我们需要先放下已有的想法和判断，全神贯注地体会对方。</p></blockquote><blockquote><p>在非暴力沟通中，倾听他人意味着，放下已有的想法和判断，一心一意地体会他人。倾听的这种品质体现了它与理解以及同情之间的区别。</p></blockquote><blockquote><p>体会他人的感受和需要</p></blockquote><blockquote><p>给他人反馈</p><blockquote><p>如果人们常常怀疑我们的诚意，那么，我们就需要好好审视自己的动机。也许，我们只是在机械地运用非暴力沟通，而忘记其目的。</p></blockquote></blockquote><blockquote><p>保持关注</p></blockquote><blockquote><p>当我们痛苦得无法倾听</p><blockquote><p>当我们痛苦得无法倾听他人时，我们需要<br>​（1）体会自己的感受和需要；<br>​（2）大声地提出请求；<br>​（3）换一个环境。</p></blockquote></blockquote><h1 id="第八章-倾听的力量"><a href="#第八章-倾听的力量" class="headerlink" title="第八章 倾听的力量"></a>第八章 倾听的力量</h1><blockquote><p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时也许会发现运用非暴力沟通是富有挑战性的。然而，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达变得容易些。我们越是倾听他人语言背后的感受和需要，就越不怕与他们坦诚地沟通。我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的时候。</p></blockquote><blockquote><p>如果我们能够体会他人的感受和需要，我们也许就会发现是什么使他们无法答应我们的请求。</p></blockquote><blockquote><p>倾听使我们勇于面对自己的弱点。它还可以帮助我们预防潜在的暴力，使谈话生动有趣，并了解“不！”和沉默所反映的感受和需要。一次又一次，我见证了，倾听帮助人们治愈心灵的创伤。</p></blockquote><h1 id="第九章-爱惜自己"><a href="#第九章-爱惜自己" class="headerlink" title="第九章 爱惜自己"></a>第九章 爱惜自己</h1><blockquote><p>自责是尚未满足的需要的可悲表达。</p></blockquote><blockquote><p>非暴力沟通认为，对他人的指责反映了我们遇到了挫折——他人的行为不符合我们的需要。</p></blockquote><blockquote><p>非暴力沟通的忧伤：当我们的行为无法满足自身的需要，我们体会着人生的悲哀和内心的渴望。</p></blockquote><blockquote><p>非暴力沟通自我宽恕：感到遗憾时，我们试图了解过去的行为所要满足的需要。</p></blockquote><blockquote><p>不论你选择做什么，了解自己为什么要那样做。</p></blockquote><blockquote><p>非暴力沟通最重要的应用也许在于培育对自己的爱。当我们的表现不完美时，我们可以通过体会忧伤和自我宽恕，来看清个人成长的方向，以及避免自我惩罚。评价自己的行为时，我们专注于尚未满足的需要；这样，我们就不再依赖羞愧、内疚、恼怒或沮丧的心理来寻求改变，而让爱主导我们的学习和成长。</p></blockquote><blockquote><p>通过深入理解我们行为的动机，并用“选择做”来取代“不得不”，我们的生活将变得和谐并充满欢乐。</p></blockquote><h1 id="第十章-充分表达愤怒"><a href="#第十章-充分表达愤怒" class="headerlink" title="第十章 充分表达愤怒"></a>第十章 充分表达愤怒</h1><blockquote><p>生气的原因在于我们的想法——对他人的评判和指责。</p></blockquote><blockquote><p>愤怒驱使我们去惩罚他人。</p></blockquote><blockquote><p>我生气的原因不在于别人做了什么，而在于我怎么看待对方及其行为。</p></blockquote><blockquote><p>当我们意识到自己的需要，愤怒就转变为服务需要的情感。</p></blockquote><blockquote><p>表达愤怒的步骤：1.停下来。呼吸。2.留意我们的指责。3.体会我们的需要。4.表达感受和尚未满足的需要。</p></blockquote><blockquote><p>越是能够倾听他人，也越有机会被倾听。</p></blockquote><blockquote><p>在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把注意力放在自己的感受和需要上。与批评和指责他人相比，直接说出我们的需要更有可能使我们的愿望得到满足。</p></blockquote><blockquote><p>表达愤怒的四个步骤是：<br>​（1）停下来，除了呼吸，什么都别做；<br>​（2）想一想是什么想法使我们生气了；<br>​（3）体会自己的需要；<br>​（4）表达感受和尚未满足的需要。<br>有时，在第3步和第4步之间，我们需要先倾听他人。<br>在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要。</p></blockquote><h1 id="第十一章-运用强制力避免伤害"><a href="#第十一章-运用强制力避免伤害" class="headerlink" title="第十一章 运用强制力避免伤害"></a>第十一章 运用强制力避免伤害</h1><blockquote><p>使用防卫性的强制力，是为了保护自己或他人，而不是为了惩罚、羞辱或谴责他人。</p></blockquote><blockquote><p>如果我们威胁他人或实施惩罚，人们常常会产生敌意和抵触心理。</p></blockquote><blockquote><p>惩罚还可能使人忽视事情本身的意义，而把注意力放在不服从的后果上。</p></blockquote><h1 id="第十二章-重获生活的热情"><a href="#第十二章-重获生活的热情" class="headerlink" title="第十二章 重获生活的热情"></a>第十二章 重获生活的热情</h1><blockquote><p>人类一直在沉睡，而且仍然在沉睡，沉迷在自己封闭的爱所带来的那种非常局限的快乐中。</p></blockquote><blockquote><p>专注于我们想要做的，而不是追究错在哪里。</p></blockquote><blockquote><p>体会自己的感受和需要可以释放压力。</p></blockquote><blockquote><p>一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。</p></blockquote><h1 id="第十三章-表达感激"><a href="#第十三章-表达感激" class="headerlink" title="第十三章 表达感激"></a>第十三章 表达感激</h1><blockquote><p>生活在商品社会中，我们也许不太习惯单纯地付出与接受。</p></blockquote><blockquote><p>在表达感激时，我们说出：<br>​（1）对我们有益的行为；<br>​（2）我们的哪些需要得到了满足；<br>​（3）我们的需要得到满足后，我们是什么样的心情。</p></blockquote><blockquote><p>当别人以这样的方式表达对我们的感激时，我们可以与对方一起庆祝生命的美——既不自大，也不假谦虚。</p></blockquote>]]></content>
    
    
    <summary type="html">开始时，我并不指望能学到多少东西。可是，读完这本书后，我发现，我激励自己的方式无意中促成了自我憎恨。由于认为自己‘应该’做到许多事情，我不停地指责自己、命令自己、要求自己。这不可避免地导致内在的分裂与不满。而非暴力沟通提醒我倾听内心中不同的声音，以及它们所反映的需要——这促进了自我理解和内心的和谐。</summary>
    
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/categories/Books/"/>
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>掌握 Java 反射机制</title>
    <link href="https://wyiyi.github.io/amber/2024/09/01/Reflection/"/>
    <id>https://wyiyi.github.io/amber/2024/09/01/Reflection/</id>
    <published>2024-09-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wyiyi.github.io/amber/contents/2024/reflection.JPEG"></p><h2 id="反射机制概述"><a href="#反射机制概述" class="headerlink" title="反射机制概述"></a>反射机制概述</h2><p><code>Java</code> 反射机制允许程序在运行时取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><h3 id="反射机制常用的类"><a href="#反射机制常用的类" class="headerlink" title="反射机制常用的类"></a>反射机制常用的类</h3><ul><li><code>java.lang.Class</code>：代表类和接口，提供了获取类信息的方法。</li><li><code>java.lang.reflect.Constructor</code>：代表类的构造函数。</li><li><code>java.lang.reflect.Field</code>：代表类的成员变量。</li><li><code>java.lang.reflect.Method</code>：代表类的方法。</li><li><code>java.lang.reflect.Modifier</code>：访问修饰符的查询。</li></ul><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>在 <code>Java</code> 中，<code>Class</code> 类用于表示类的字节码。它是反射的入口，包含了与类有关的信息。</p><p><code>Class</code> 对象在类加载时由 <code>Java</code> 虚拟机自动创建。</p><p>可以通过以下几种方式获取：</p><ol><li><p>使用<code>Class.forName()</code> 通过类的全限定名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>.class</code>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = String.class;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>object.getClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line">Class&lt;?&gt; cls = s.getClass();</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><p>可以通过以下方式创建对象：</p><ol><li><p><code>Class.newInstance()</code>：使用 <code>Class</code> 对象的 <code>newInstance()</code> 方法，要求类有一个无参的构造器，并且构造器是可访问的。</p></li><li><p> <code>Class.getConstructor()</code> 和 <code>newInstance()</code>：使用 <code>Class</code> 对象的 <code>getConstructor()</code> 方法获取指定的构造器，在调用 <code>newInstance()</code> 方法，可以传递参数给构造器。</p></li><li><p><code>Constructor.newInstance(Object... initargs)</code>：适用于已经存在<code>Constructor</code> 对象，使用 <code>Constructor</code> 对象的 <code>newInstance()</code> 方法，可以直接传递参数给构造器。</p></li></ol><h2 id="通过反射操作属性和方法"><a href="#通过反射操作属性和方法" class="headerlink" title="通过反射操作属性和方法"></a>通过反射操作属性和方法</h2><p>反射允许访问和操作类的私有属性和方法：</p><h3 id="访问字段：使用-Field-类的-get-和-set-方法。"><a href="#访问字段：使用-Field-类的-get-和-set-方法。" class="headerlink" title="访问字段：使用 Field 类的 get 和 set 方法。"></a>访问字段：使用 <code>Field</code> 类的 <code>get</code> 和 <code>set</code> 方法。</h3><ol><li><p>获取目标类的 <code>Class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.TargetClass&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Class</code> 对象的 <code>getDeclaredField()</code> 方法来获取指定的私有字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;fieldName&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>Field</code> 对象的可访问性（如果字段是私有的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建目标类的实例（如果字段不是静态的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>Field</code> 对象读取字段的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj);</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>Field</code> 对象修改字段的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 newValue 是要设置的新值</span></span><br><span class="line">field.set(obj, newValue); </span><br></pre></td></tr></table></figure></li></ol><h3 id="访问方法：使用-Method-类的-invoke-方法。"><a href="#访问方法：使用-Method-类的-invoke-方法。" class="headerlink" title="访问方法：使用 Method 类的 invoke 方法。"></a>访问方法：使用 <code>Method</code> 类的 <code>invoke</code> 方法。</h3><ol><li><p>获取目标类的 <code>Class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.TargetClass&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Class</code> 对象的 <code>getDeclaredMethod()</code> 方法来获取指定的私有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;privateMethodName&quot;</span>, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>Method</code> 对象的可访问性（如果方法是私有的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建目标类的实例（如果方法不是静态的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>Method</code> 对象调用目标对象的方法，可以传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj, <span class="number">10</span>); <span class="comment">// 假设方法需要一个 int 类型的参数</span></span><br></pre></td></tr></table></figure><h2 id="反射应用场景"><a href="#反射应用场景" class="headerlink" title="反射应用场景"></a>反射应用场景</h2></li><li><p>框架开发：如 Spring 框架使用反射来实现依赖注入（DI）和面向切面编程（AOP）。</p></li><li><p>动态代理：Java 的代理模式可以通过反射实现动态代理，这在许多框架中也十分常见。</p></li><li><p>对象序列化与反序列化：在序列化和反序列化过程中，可能会用到反射来创建对象和恢复对象状态。</p></li><li><p>数据库访问框架：如 Hibernate、MyBatis 等框架，通过反射来映射数据库表和 Java 对象。</p></li><li><p>工具类开发：例如 JavaBean 的属性拷贝工具，通过反射来获取和设置属性值。</p></li><li><p>测试工具：如 JUnit，通过反射来运行测试用例。</p></li></ol><h2 id="反射应用实例"><a href="#反射应用实例" class="headerlink" title="反射应用实例"></a>反射应用实例</h2><h3 id="获得自定义注解标记点属性并赋值"><a href="#获得自定义注解标记点属性并赋值" class="headerlink" title="获得自定义注解标记点属性并赋值"></a>获得自定义注解标记点属性并赋值</h3><ol><li><p>自定义注解类 <code>MyAnnotation</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个类，在类的属性上使用注解 <code>MyClass</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;initialValue&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String annotatedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotatedField = <span class="string">&quot;initialValue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAnnotatedField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> annotatedField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAnnotatedField</span><span class="params">(String annotatedField)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.annotatedField = annotatedField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得自定义注解标记点属性并赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 MyClass 中所有声明的字段</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 检查字段是否带有 MyAnnotation 注解</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">                <span class="comment">// 获取注解</span></span><br><span class="line">                <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(MyAnnotation.class);</span><br><span class="line">                <span class="comment">// 获取注解的值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">                System.out.println(<span class="string">&quot;Annotation value: &quot;</span> + value); <span class="comment">//输出：Annotation value: initial_value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置字段可访问（如果字段是私有的）</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 修改字段的值</span></span><br><span class="line">                field.set(obj, <span class="string">&quot;newValue&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;New field value: &quot;</span> + field.get(obj)); <span class="comment">// 输出：New field value: newValue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用反射创建接口的动态代理类"><a href="#使用反射创建接口的动态代理类" class="headerlink" title="使用反射创建接口的动态代理类"></a>使用反射创建接口的动态代理类</h3><ol><li><p>定义一个接口（不定义实现类）<code>SimpleInterface</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SimpleInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建动态代理类，实现SimpleProxyHandler 接口，用于修改方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleProxyHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;After method call: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用反射创建接口的动态代理类，并调用接口方法得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleInterface</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (SimpleInterface) Proxy.newProxyInstance(</span><br><span class="line">                SimpleInterface.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;SimpleInterface.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SimpleProxyHandler</span>(<span class="keyword">new</span> <span class="title class_">SimpleInterface</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 匿名内部类实现SimpleInterface接口</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> proxyInstance.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(greeting); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用动态代理修改接口实现"><a href="#使用动态代理修改接口实现" class="headerlink" title="使用动态代理修改接口实现"></a>使用动态代理修改接口实现</h3><ol><li><p>自定义接口 <code>SimpleInterface</code> 和实现类 <code>SimpleInterfaceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SimpleInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">SimpleInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个动态代理类，实现<code>InvocationHandler</code>接口，用于修改方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleInterfaceHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleInterfaceHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改返回值：将结果 * 2</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            result = (Integer) result * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用动态代理来修改实现类中的方法行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleInterface</span> <span class="variable">implementation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleInterfaceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleInterface</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (SimpleInterface) Proxy.newProxyInstance(</span><br><span class="line">                SimpleInterface.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;SimpleInterface.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SimpleInterfaceHandler</span>(implementation)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> proxyInstance.performOperation(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result of operation: &quot;</span> + result); <span class="comment">// 输出: Result of operation: 16</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">掌握 Java 反射机制</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="反射" scheme="https://wyiyi.github.io/amber/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>构造 ApacheBench 可用的 postfile</title>
    <link href="https://wyiyi.github.io/amber/2024/08/01/ApacheBench/"/>
    <id>https://wyiyi.github.io/amber/2024/08/01/ApacheBench/</id>
    <published>2024-08-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在 <code>Web</code> 开发过程中，文件上传功能是常见的需求。对于开发者而言，确保上传功能的稳定性和性能至关重要。</p><p>本文将带你了解如何使用<code>ApacheBench</code>性能测试工具对文件上传功能进行性能测试，特别是如何按照规范构造上传文件的请求体，以便评估和提高服务器在高并发情况下的处理能力。</p><h2 id="ApacheBench-简介"><a href="#ApacheBench-简介" class="headerlink" title="ApacheBench 简介"></a>ApacheBench 简介</h2><p><code>ApacheBench</code>（简称<code>ab</code>）是 <code>Apache</code> 服务器自带的一个性能测试工具，它能够模拟多用户并发请求，从而评估服务器在高负载下的性能表现。<br>若系统中未安装 <code>Apache</code> 服务器，可前往 <a href="https://httpd.apache.org/">Apache 官网</a>下载和安装。<br>更多关于 ApacheBench 的信息，请参考：<a href="https://mp.weixin.qq.com/s/5lqaOphTwsWhGHT-VSH0Tg">ApacheBench 简介</a>。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>假设有一个文件上传 <code>POST</code> 接口 <code>http://localhost:8080/upload</code> ，在请求体中接受 <code>key</code> 为 <code>file</code> 的文件，并返回上传的文件名和文件大小：</p><p><img src="https://wyiyi.github.io/amber/contents/2024/apache-bench.png"></p><p>通过 <code>Postman</code> 等工具，我们可以直观地看到上传文件的请求内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /upload HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Length: 204</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;/C:/Users/admin/Desktop/test.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">(data)</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当需要使用 <code>ApacheBench</code> 测试上传文件的 <code>POST</code> 接口时，<code>ab -h</code> 中只写到了通过 <code>-p</code> 参数指定 <code>postfile</code>：</p><blockquote><p>-p postfile     File containing data to POST. Remember also to set -T</p></blockquote><p>那么这个 <code>postfile</code> 中包含哪些内容呢？应该如何构造一个 <code>ApacheBench</code> 可用的 <code>postfile</code> 呢？</p><h2 id="有关-multipart-form-data-的规范"><a href="#有关-multipart-form-data-的规范" class="headerlink" title="有关 multipart/form-data 的规范"></a>有关 <code>multipart/form-data</code> 的规范</h2><p><a href="https://www.rfc-editor.org/rfc/rfc7578#section-4">RFC 7578 第4节</a> 中关于 <code>multipart/form-data</code> 的定义提到：<code>multipart/form-data</code> 遵循 <a href="https://www.rfc-editor.org/rfc/rfc2046#section-5.1">RFC 2046 第 5.1 节</a> 中定义的多部分 <code>MIME</code> 数据流结构，并有一些变化，大致的结构要求如下：</p><ol><li>请求头必须包含 <code>Content-Type: multipart/form-data; boundary=边界分隔符</code>；</li><li>多部分文件需要组合成一个单个的请求体，<code>边界分隔符</code> 字符串需保证在整个请求体内唯一，不会出现在分割行以外的其他部分；</li><li>请求体必须包含一个或多个部分，每部分一个实体（如：文件）；</li><li>各部分使用 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CRLF">CRLF</a> +<code>--</code> +<code>边界分隔符</code>作为一个<code>边界分割行</code>进行分隔，最后一部分后面使用 <code>边界分隔行</code> +<code>--</code>表示结束；换行符均需使用 CRLF（即 <code>\r\n</code>，即使在非 Windows 环境中）；</li><li>每部分在边界分隔行之间，又由三部分组成：头区域、空白行、内容区域；</li><li>每部分头区域必须包含 <code>Content-Disposition</code>  头字段，类型为 <code>form-data</code>；同时必须包含 <code>name</code> 参数，值为 <code>form</code> 中的原始字段名；当内容区域表示的是文件时，还应该提供 <code>filename</code> 参数。</li></ol><p>更详细的内容可参考上面引用的 <code>RFC</code> 规范文档。</p><h2 id="构造-postfile"><a href="#构造-postfile" class="headerlink" title="构造 postfile"></a>构造 postfile</h2><p>下面依照规范中格式要求，构造一个只发送一个文件的 <code>postfile</code>。</p><h3 id="1-准备-postfile-文件"><a href="#1-准备-postfile-文件" class="headerlink" title="1. 准备 postfile 文件"></a>1. 准备 postfile 文件</h3><ul><li>准备要上传的文件：如：<code>test.jpg</code>；</li><li>新建一个文本文件，命名为<code>postfile.txt</code>。</li></ul><h3 id="2-确定边界分隔符"><a href="#2-确定边界分隔符" class="headerlink" title="2. 确定边界分隔符"></a>2. 确定边界分隔符</h3><p>选择一个不会在文件内容中出现的字符串作为边界分隔符，例如：<code>----WebKitFormBoundary7MA4YWxkTrZu0gW</code>。</p><h3 id="3-编写-postfile-头区域及空白行"><a href="#3-编写-postfile-头区域及空白行" class="headerlink" title="3. 编写 postfile 头区域及空白行"></a>3. 编写 postfile 头区域及空白行</h3><p>在 <code>postfile.txt</code> 中写入以下内容，这些内容构成了请求体的头部信息，<br>其中 <code>name</code> 应该与服务器端接收的字段名一致，<code>filename</code> 是要上传的文件的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>依据规范描述，Content-Type 头字段非必要。</p></blockquote><p><strong>此处需注意：</strong></p><p>因为规范要求使用<code>CRLF</code>作为换行符，在<code>非 Windows</code> 环境中，不能直接使用文本编辑器输入上面内容，可以按如下方式通过命令构造此部分内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&#x27;------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.jpg&quot;\r\nContent-Type: image/jpeg\r\n\r&#x27;</span> &gt; postfile.txt</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>&gt;</code>、<code>&gt;&gt;</code>向文件中添加内容时，会自动在最后追加一个 LR（<code>\n</code>），所以省略最后一个 <code>\n</code>。</p></blockquote><p>使用 <code>cat -e</code> 可验证换行符，每行结尾是 <code>^M$</code> 代表 <code>CRLF</code>换行符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> -e postfile.txt</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW^M$</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;test.jpg&quot;</span>^M$</span><br><span class="line">Content-Type: image/jpeg^M$</span><br><span class="line">^M$</span><br></pre></td></tr></table></figure><h3 id="4-添加文件内容至-postfile-内容区域"><a href="#4-添加文件内容至-postfile-内容区域" class="headerlink" title="4. 添加文件内容至 postfile 内容区域"></a>4. 添加文件内容至 postfile 内容区域</h3><p>由于文件内容通常是二进制数据，不能直接在文本编辑器中粘贴，可使用 <code>cat</code> 命令将文件内容追加至 <code>postfile</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 test.jpg 文件内容追加到 postfile.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> test.jpg &gt;&gt; postfile.txt</span><br></pre></td></tr></table></figure><blockquote><p>Windows 系统中可在 <code>git bash</code> 中使用 <code>cat</code> 命令。</p></blockquote><h3 id="5-添加结束标记"><a href="#5-添加结束标记" class="headerlink" title="5. 添加结束标记"></a>5. 添加结束标记</h3><p>最后以 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CRLF">CRLF</a>+<code>--</code> +<code>边界分隔符</code>+<code>--</code> 标记结束：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将结束标记添加到 postfile.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW--&quot;</span> &gt;&gt; postfile.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>因为在将文件流内容追加至 <code>postfile.txt</code> 文件后，已无法使用文本编辑器直接打开此文件，故继续使用命令追加文件内容，同样在 Windows 环境中可以通过 <code>git bash</code> 使用 <code>echo</code> 命令。</p></blockquote><h2 id="执行-ab-命令"><a href="#执行-ab-命令" class="headerlink" title="执行 ab 命令"></a>执行 ab 命令</h2><p>使用以下命令执行文件上传测试：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ab -n 1 -c 1 -p postfile.txt -v 2 \</span><br><span class="line">-T &quot;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&quot; \</span><br><span class="line">http://localhost:8080/upload \</span><br><span class="line">-v 2</span><br></pre></td></tr></table></figure><ul><li><code>-n 1</code> 表示总共发送 1 个请求（根据实际测试需求进行调整）。</li><li><code>-c 1</code> 表示同时并发 1 个请求（根据实际测试需求进行调整）。</li><li><code>-p postfile.txt</code> 指定包含<code>POST</code>数据的文件。</li><li><code>-T &quot;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&quot;</code> 指定请求的内容类型，包括之前定义的边界分隔符。</li><li><code>-v verbosity</code>用于设置 <code>ApacheBench</code> 的详细输出级别。在详细输出级别 <code>2</code> 下，<code>ApacheBench</code>会打印出警告信息和信息信息，如：请求和响应的头部信息。</li></ul><p>执行命令后，在控制台中，可以在 <code>LOG: header received:</code> 消息之后找到响应状态码和响应内容。如果状态码为 <code>200</code>且和预期值一致，表示服务器成功处理了请求。</p><p>在控制台中还会提供一系列关键指标，如每秒请求数、请求平均响应时间等关键指标。这些数据可以帮助分析文件上传的性能表现，并为优化提供依据。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1901567 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)...INFO: POST header ==</span><br><span class="line">---</span><br><span class="line">POST /upload HTTP/1.0</span><br><span class="line">Content-length: 24223</span><br><span class="line">Content-type: multipart/form-data; boundary=---WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">secret-id: 3e6bec50-3bbd-4443-b141-82aaee645cc7</span><br><span class="line">secret-key: f1596671ce4d30a7847a91b8c674f43c</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: ApacheBench/2.3</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">LOG: header received:</span><br><span class="line">HTTP/1.1 200</span><br><span class="line">Content-Type: text/plain;charset=UTF-8</span><br><span class="line">Content-Length: 113</span><br><span class="line">Date: Wed, 31 Jul 2024 13:37:18 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">File uploaded successfully: postfile.txt with size: 24072 bytes</span><br><span class="line">..done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /upload</span><br><span class="line">Document Length:        113 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      1</span><br><span class="line">Time taken for tests:   0.056 seconds</span><br><span class="line">Complete requests:      1</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      247 bytes</span><br><span class="line">Total body sent:        24512</span><br><span class="line">HTML transferred:       113 bytes</span><br><span class="line">Requests per second:    17.73 [#/sec] (mean)</span><br><span class="line">Time per request:       56.388 [ms] (mean)</span><br><span class="line">Time per request:       56.388 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          4.28 [Kbytes/sec] received</span><br><span class="line">                        424.51 kb/s sent</span><br><span class="line">                        428.79 kb/s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.0      0       0</span><br><span class="line">Processing:    56   56   0.0     56      56</span><br><span class="line">Waiting:       53   53   0.0     53      53</span><br><span class="line">Total:         56   56   0.0     56      56</span><br></pre></td></tr></table></figure><h2 id="扩展-putfile"><a href="#扩展-putfile" class="headerlink" title="扩展 putfile"></a>扩展 putfile</h2><p><code>ApacheBench (ab)</code> 同样适用于测试 <code>PUT</code>接口。构造<code>putfile</code>的方法与<code>POST</code>接口类似，只需确保请求体的内容和头部信息符合<code>PUT</code>请求的要求。</p><blockquote><p>-u putfile File containing data to PUT. Remember also to set -T</p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h3><p>构造命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;file1.jpg&quot;\r\n\r&#x27;</span> &gt; postfile.txt</span><br><span class="line"><span class="built_in">cat</span> 1.jpg &gt;&gt; postfile.txt</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW--&quot;</span> &gt;&gt; postfile.txt</span><br></pre></td></tr></table></figure><p>发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1 -c 1 -p postfile.txt -v 2 \</span><br><span class="line">-T <span class="string">&quot;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&quot;</span> \</span><br><span class="line">http://localhost:8080/upload</span><br></pre></td></tr></table></figure><h3 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h3><p>构造命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;file1.jpg&quot;\r\n\r&#x27;</span> &gt; postfile.txt</span><br><span class="line"><span class="built_in">cat</span> 1.jpg &gt;&gt; postfile.txt</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r&quot;</span> &gt;&gt; postfile.txt</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;Content-Disposition: form-data; name=&quot;file2&quot;; filename=&quot;file2.zip&quot;\r\n\r&#x27;</span> &gt;&gt; postfile.txt</span><br><span class="line"><span class="built_in">cat</span> demo.zip &gt;&gt; postfile.txt</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW--&quot;</span> &gt;&gt; postfile.txt</span><br></pre></td></tr></table></figure><p>发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1 -c 1 -p postfile.txt -v 2 \</span><br><span class="line">-T <span class="string">&quot;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&quot;</span> \</span><br><span class="line">http://localhost:8080/upload2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">构造 ApacheBench 可用的 postfile</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Postman" scheme="https://wyiyi.github.io/amber/tags/Postman/"/>
    
    <category term="Apache Bench" scheme="https://wyiyi.github.io/amber/tags/Apache-Bench/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 In Action Lambda</title>
    <link href="https://wyiyi.github.io/amber/2024/07/01/lambda/"/>
    <id>https://wyiyi.github.io/amber/2024/07/01/lambda/</id>
    <published>2024-07-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在优化代码的过程中，通过使用<code>Java 8 lambda</code>表达式，减少代码量，提高代码可读性。</p><h2 id="lambda-表达式简介"><a href="#lambda-表达式简介" class="headerlink" title="lambda 表达式简介"></a>lambda 表达式简介</h2><p>Lambda 表达式可以理解为一种匿名函数，它没有名称，但有参数列表、函数体、返回类型，并且可能还有一个可能抛出的异常列表。<br>Lambda 表达式可以作为参数传递给方法，也可以存储在变量中。<br>与匿名内部类相比，Lambda 表达式更加简洁。</p><p>从一个例子入手：写一个比较苹果的重量的逻辑：</p><ul><li><p>传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; byWeight = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple a1, Apple a2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用 lambda 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure></li></ul><p>必须承认，代码看起来变得更清晰了。</p><p><a href="https://book.douban.com/subject/25912747/">引用 Java 8 inAction：</a></p><blockquote><p>A lambda expression is composed of parameters, an arrow, and a body.</p></blockquote><p><img src="https://wyiyi.github.io/amber/contents/2024/lambda.png"></p><ul><li>参数列表：在这个例子中，它反映了<code>Comparator</code>的<code>compare</code>方法的参数（两个<code>Apple</code>对象）。</li><li>箭头：箭头<code>-&gt;</code>将参数列表与<code>lambda</code>的函数体分隔开。</li><li><code>Lambda</code>的函数体：使用它们的重量比较两个<code>Apple</code>对象。这个表达式被认为是<code>lambda</code>的返回值。</li></ul><h3 id="Lambda-的基本语法"><a href="#Lambda-的基本语法" class="headerlink" title="Lambda 的基本语法"></a>Lambda 的基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression <span class="comment">// 表达式风格</span></span><br><span class="line"><span class="comment">// 或者（注意使用花括号表示语句）</span></span><br><span class="line">(parameters) -&gt;&#123; statements; &#125; <span class="comment">// 块风格</span></span><br></pre></td></tr></table></figure><h3 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个布尔表达式</span></span><br><span class="line">(List&lt;String&gt; list) -&gt; list.isEmpty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">10</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从对象中消费</span></span><br><span class="line">(Apple a) -&gt; &#123; System.out.println(a.getWeight()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从对象中选择/提取 </span></span><br><span class="line">(String s) -&gt; s.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合两个值 </span></span><br><span class="line">(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a * b; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个对象 </span></span><br><span class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>在<code>Java 8</code>的<code>java.util.function</code>包中引入了一系列的函数式接口，如：<code>Predicate</code>，<code>Consumer</code>，和 <code>Function</code>等。<br>函数式接口是一种特殊的接口，它只定义了一个抽象方法，这样的接口可以用来表示<code>Lambda</code>表达式。</p><h3 id="函数式接口特点："><a href="#函数式接口特点：" class="headerlink" title="函数式接口特点："></a>函数式接口特点：</h3><ul><li>函数式接口可以有一个或多个默认方法（<code>default methods</code>），这些默认方法可以有实现。</li><li>函数式接口可以有多个静态方法（<code>static methods</code>），这些静态方法也可以有实现。</li><li>函数式接口可以有多个从父接口继承的抽象方法，但这些方法必须都是唯一的，也就是说，函数式接口里只能有一个抽象方法。</li><li>函数式接口可以用<code>@FunctionalInterface</code>注解来标记，但这不是必须的。这个注解的作用是帮助编译器检查接口是否符合函数式接口的定义。</li></ul><h3 id="For-a-Example"><a href="#For-a-Example" class="headerlink" title="For a Example"></a>For a Example</h3><ul><li><p><code>Predicate&lt;T&gt;</code>：接受一个泛型<code>T</code>的对象，并返回一个布尔值。常用于条件判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = s -&gt; s.isEmpty();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> predicate.test(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Consumer&lt;T&gt;</code>：接受一个泛型<code>T</code>的对象，并执行一些操作，但没有返回值。常用于数据消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Function&lt;T, R&gt;</code>：接受一个泛型<code>T</code>的对象，并返回一个泛型<code>R</code>的对象。常用于转换数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; function = String::valueOf;</span><br><span class="line"><span class="type">String</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Supplier&lt;T&gt;</code>：提供一个泛型<code>T</code>的对象，但不接受任何参数。常用于提供数据源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> supplier.get();</span><br></pre></td></tr></table></figure></li><li><p><code>Runnable</code>：定义一个无参数无返回值的执行块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用是<code>lambda</code>表达式的更简洁的语法，它允许我们引用类中的现有方法。</p><p>当使用方法引用时，目标引用放在分隔符<code>::</code>之前，方法名称在它之后提供，即：目标引用<code>::</code>方法。</p><p>使用 <code>::</code> 运算符作为 <code>Lambda</code> 调用特定方法的缩写，并且拥有更好的可读性。</p><p>lambda 表达式与方法引用等价示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(Apple a) -&gt; a.getWeight() Apple::getWeight</span><br><span class="line">        </span><br><span class="line">() -&gt; Thread.currentThread().dumpStack() Thread.currentThread()::dumpStack</span><br><span class="line">        </span><br><span class="line">(str, i) -&gt; str.substring(i) String::substring</span><br><span class="line">        </span><br><span class="line">(String s) -&gt; System.out.println(s) System.out::println</span><br></pre></td></tr></table></figure><h3 id="方法引用的三种类型"><a href="#方法引用的三种类型" class="headerlink" title="方法引用的三种类型"></a>方法引用的三种类型</h3><ol><li><strong>静态方法引用</strong>：如：</li></ol><ul><li>lambda表达式: <code>(s) -&gt; Integer.parseInt(s)</code></li><li>方法引用: <code>Integer::parseInt</code></li></ul><ol start="2"><li><strong>任意类型的实例方法引用</strong>：引用一个类型的实例方法，并且这个实例作为参数传递给<code>lambda</code>表达式时使用。如：</li></ol><ul><li>lambda表达式: <code>(s) -&gt; s.toUpperCase()</code></li><li>方法引用: <code>String::toUpperCase</code></li></ul><ol start="3"><li><strong>现有对象的实例方法引用</strong>：在<code>lambda</code>表达式中调用一个已经存在的对象的方法时使用。如：</li></ol><ul><li>lambda表达式: <code>() -&gt; expensiveTransaction.getValue()</code></li><li>方法引用: <code>expensiveTransaction::getValue</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Java 8</code> 中的 <code>Lambda</code> 表达式可以让代码更加简洁、易读，并且提高开发效率。</p>]]></content>
    
    
    <summary type="html">代码优化的过程中通过使用 lambda 表达式，减少代码量，提高代码可读性。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Java8" scheme="https://wyiyi.github.io/amber/tags/Java8/"/>
    
    <category term="Lambda" scheme="https://wyiyi.github.io/amber/tags/Lambda/"/>
    
    <category term="Stream" scheme="https://wyiyi.github.io/amber/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>月亮与六便士</title>
    <link href="https://wyiyi.github.io/amber/2024/06/01/the-moon-and-sixpence/"/>
    <id>https://wyiyi.github.io/amber/2024/06/01/the-moon-and-sixpence/</id>
    <published>2024-06-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了让灵魂受益，每天应该做两件自己不喜欢的事。</p></blockquote><blockquote><p>世界上只有极少数的人才能实现理想。</p></blockquote><blockquote><p>只有诗人和圣徒才矢志不渝地相信，在沥青路上勤勤恳恳地浇水就可以培育出百合花的说法。</p></blockquote><blockquote><p>一个人的个性是个复杂体，卑劣和伟大、邪恶与善良、仇恨和热爱是可以共存的。</p></blockquote><blockquote><p>有人说，悲惨遭遇会让人性高贵，这句话其实是错的。让人高贵的其实是满满的幸福，遭遇不幸在很多情况下，只能让人变得自私，狭隘，更具有报复心。</p></blockquote><blockquote><p>卑鄙与伟大、恶毒与善良、仇恨与热爱，是可以互不排斥地并存在同一颗心里的。</p></blockquote><blockquote><p>感到残酷的是，这种幸福生活被一次无情的偶发事件折腾成了碎片。最残酷的是，他们幸福生活的破碎事实上并没有让这个世界有什么不同。这世界继续运转，没有人因为这件可悲的事情生活得更糟糕。</p></blockquote><blockquote><p>去做你最想做的事情，在你喜欢的环境里生活，自己宁静致远，就是把生活糟蹋了吗？做一个闻名遐迩的外科医生，一年一万镑收入，娶一个漂亮妻子，这就是成功吗？我看这取决于你对生活赋予什么意义，取决于你对社会承担什么责任、对个人有什么要求。</p></blockquote><blockquote><p>皈依能以不同的形态出现，也可以通过不同的途径实现。有些人通过激变，有如愤怒的激流把石块一下子冲击成粉末；另些人则由于日积月累，好像不断的水滴，迟早要把石块磨穿。</p></blockquote><blockquote><p>世界上只有少数人能够最终实现自己的理想。我们的生活很简单，很单纯。我们没有什么雄心壮志，我们引以为傲的只有用双手创造的劳动成果。人世的恶毒奈何不了我们，我们也不嫉妒世人。</p></blockquote><blockquote><p>仿佛他在宇宙的混沌中找到了一种崭新的图案，在笨拙地尝试着描绘出来，灵魂因此极度苦恼。我看见了一个饱受折磨的灵魂拼尽全力寻找表达的释放。</p></blockquote>]]></content>
    
    
    <summary type="html">因“满地都是六便士，他却抬头看见了月亮”读了《月亮与六便士》。</summary>
    
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/categories/Books/"/>
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>Git Commit Tree Browser</title>
    <link href="https://wyiyi.github.io/amber/2024/04/01/git-commit-tree/"/>
    <id>https://wyiyi.github.io/amber/2024/04/01/git-commit-tree/</id>
    <published>2024-04-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wyiyi.github.io/amber/contents/2024/git-cover.png"></p><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>在<code>Git</code>项目中，代码的频繁迭代会使得追踪项目文件结构变化的过程异常艰难，尤其是历史 <code>commit</code> 中存在、当前最新版本中已经不存在的文件/文件夹。</p><p>为了解决这个问题，<code>Git Commit Tree Browser</code> 提供了一个高效的解决方案。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/AlphaHinex/git-commit-tree-browser">Git Commit Tree Browser</a> 是基于<code>Bash</code>的脚本工具，通过为每个 <code>commit</code> 生成文件目录树，并配备交互式的浏览界面，可视化展示 <code>Git</code> 仓库各个 <code>commit</code> 状态下的文件树结构。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://wyiyi.github.io/amber/contents/2024/git-demo.gif"></p><h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><ul><li>为指定 <code>Git</code> 仓库中每个 <code>commit</code> 生成文件目录树文件</li><li>提供终端交互界面，通过左右箭头键切换查看不同 <code>commit</code> 的文件目录树状态；按回车后激活跳转到指定 <code>commit</code> 模式，输入 <code>commit</code> ID（加文件扩展名 <code>.txt</code>）完成跳转</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ol><li>工具使用 Bash 脚本实现，需可执行 Bash 脚本的终端环境（<code>Windows</code> 操作系统可在 <code>Git Bash</code> 中使用）</li><li>工具依赖 <code>tree</code> 命令生成文件树结构，如终端中无法使用需提前安装（<code>Windows</code> 用户可以在 <code>Git Bash</code> 中安装 <a href="https://gnuwin32.sourceforge.net/packages/tree.htm">Tree for Windows</a>）</li></ol><h3 id="执行-prepare-sh-脚本"><a href="#执行-prepare-sh-脚本" class="headerlink" title="执行 prepare.sh 脚本"></a>执行 prepare.sh 脚本</h3><p>执行 <code>prepare.sh</code> 脚本，传入 <code>Git</code> 仓库的路径作为参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/AlphaHinex/git-commit-tree-browser</span><br><span class="line">$ <span class="built_in">cd</span> git-commit-tree-browser</span><br><span class="line">$ ./prepare.sh /path/to/your/git/repo</span><br></pre></td></tr></table></figure><p>脚本将遍历指定 Git 仓库的所有 <code>commit</code>，并为每个 <code>commit</code> 在当前路径生成文件目录树文本文件 <code>&lt;commit_id&gt;.txt</code>。</p><blockquote><p>当前生成目录树使用的命令是 <a href="https://github.com/AlphaHinex/git-commit-tree-browser/blob/main/prepare.sh#L18">tree -N -d -L 3</a>，即只显示文件夹，最多显示三级路径。可根据实际需要进行调整。</p></blockquote><h3 id="执行-browser-sh-脚本"><a href="#执行-browser-sh-脚本" class="headerlink" title="执行 browser.sh 脚本"></a>执行 browser.sh 脚本</h3><p>执行 <code>browser.sh</code> 脚本，开始按 <code>commit</code> 从老到新的顺序进行文件目录树浏览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./browser.sh</span><br></pre></td></tr></table></figure><p>终端中将显示第一个<code>commit</code>的文件目录树，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">File: 20df792.txt</span><br><span class="line">.</span><br><span class="line">|-- bronze</span><br><span class="line">|   |-- gradle</span><br><span class="line">|   |   `-- wrapper</span><br><span class="line">|   `-- src</span><br><span class="line">|       |-- main</span><br><span class="line">|       `-- <span class="built_in">test</span></span><br><span class="line">`-- git-commit-tree-browser</span><br><span class="line"></span><br><span class="line">7 directories</span><br><span class="line">20df792</span><br><span class="line">Press left/right arrow to navigate, or Enter to jump to a file:</span><br></pre></td></tr></table></figure><p>可以使用以下方式导航：</p><ul><li>使用左右箭头键在不同的 <code>commit</code> 之间切换</li><li>按 <code>Enter</code> 键，然后输入 <code>&lt;commit_id&gt;.txt</code> 文件名，直接跳转到特定的<code>commit</code></li></ul><p><strong>小工具会继续丰富功能，请期待~~~</strong></p>]]></content>
    
    
    <summary type="html">安利一个小工具：Git 仓库 Commit 文件树查看器。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Git" scheme="https://wyiyi.github.io/amber/tags/Git/"/>
    
    <category term="Tools" scheme="https://wyiyi.github.io/amber/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>程序员的README</title>
    <link href="https://wyiyi.github.io/amber/2024/03/01/cxy-readme/"/>
    <id>https://wyiyi.github.io/amber/2024/03/01/cxy-readme/</id>
    <published>2024-03-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wyiyi.github.io/amber/contents/2024/README.jpg"></p><p><a href="https://book.douban.com/subject/36457109/">豆瓣评分 8.7</a></p><blockquote><p>无论你处于职业生涯的哪个阶段，这本书都非常实用。请保持开放的心态，好学深思，渴望提高，不惧破旧习，不惧提问题。</p></blockquote><blockquote><p>本书第1～2章讲解当你在公司开启你的职业生涯时会发生什么；</p><p>第3～11章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call时的事故和构建可演进的架构等；</p><p>剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。</p><p>本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。</p></blockquote><h1 id="1-1-你的目的地"><a href="#1-1-你的目的地" class="headerlink" title="1.1 你的目的地"></a>1.1 你的目的地</h1><blockquote><p>核心领域中所需要的能力：</p><ul><li>技术知识</li><li>执行力</li><li>沟通能力</li><li>领导力</li></ul></blockquote><h1 id="2-1-学习如何学习"><a href="#2-1-学习如何学习" class="headerlink" title="2.1 学习如何学习"></a>2.1 学习如何学习</h1><blockquote><ul><li>前置学习</li><li>在实践中学习</li><li>运行实例代码</li><li>阅读</li><li>观看讲座</li><li>适度地参加会议和聚会</li><li>跟班学习并同有经验的工程师结对</li><li>用副业项目实践</li></ul></blockquote><h1 id="2-2-提出问题"><a href="#2-2-提出问题" class="headerlink" title="2.2 提出问题"></a>2.2 提出问题</h1><blockquote><p>在“万事都求人”和“独行侠”之间取得平衡</p></blockquote><h1 id="3-1-软件的熵"><a href="#3-1-软件的熵" class="headerlink" title="3.1 软件的熵"></a>3.1 软件的熵</h1><blockquote><p>走向无序的趋势被称为软件的熵。</p></blockquote><h1 id="3-2-技术债"><a href="#3-2-技术债" class="headerlink" title="3.2 技术债"></a>3.2 技术债</h1><blockquote><p>技术债(technical debt)是造成软件的熵的一个主要原因。<br>技术债是为了修复现有的代码不足而欠下的未来工作。</p></blockquote><p><img src="https://wyiyi.github.io/amber/contents/2024/readme-jishuzhai.png" alt="技术债矩阵"></p><blockquote><p>解决技术债：</p><p>1.按事实陈述情况；</p><p>2.描述技术债的风险和成本；</p><p>3.提出解决方案；</p><p>4.讨论备选方案（不采取行动也是备选方案）；</p><p>5.权衡利弊。</p></blockquote><h1 id="3-5-行为准则"><a href="#3-5-行为准则" class="headerlink" title="3.5 行为准则"></a>3.5 行为准则</h1><p><img src="https://wyiyi.github.io/amber/contents/2024/readme-3.5.png"></p><h1 id="第7章-代码评审"><a href="#第7章-代码评审" class="headerlink" title="第7章 代码评审"></a>第7章 代码评审</h1><blockquote><p>高质量的代码评审文化有助于所有具有不同经验水平的工程师的成长，并促进他们对代码库的共同理解。<br>糟糕的代码评审文化会抑制创新，减慢开发速度，并且导致滋生怨恨情绪。</p></blockquote><h1 id="7-2-当你的代码被评审时"><a href="#7-2-当你的代码被评审时" class="headerlink" title="7.2 当你的代码被评审时"></a>7.2 当你的代码被评审时</h1><blockquote><ul><li>准备工作</li><li>用评审草案降低风险</li><li>提交评审请勿触发测试</li><li>预排大体量的代码修改</li><li>不要太在意</li><li>保持同理心，但不要容忍粗鲁</li><li>保持主动</li></ul></blockquote><h1 id="7-3-评审别人的代码时"><a href="#7-3-评审别人的代码时" class="headerlink" title="7.3 评审别人的代码时"></a>7.3 评审别人的代码时</h1><blockquote><ul><li>分流评审请求</li><li>给评审预留时间</li><li>理解修改的意图</li><li>提供全面的反馈</li><li>要承认优点</li><li>区分问题、建议和挑剔</li><li>不要只做橡皮图章</li><li>不要只局限于使用网页版的评审工具</li><li>不要忘记评审测试代码</li><li>推动决断</li></ul></blockquote><h1 id="9-2-On-Call技能包"><a href="#9-2-On-Call技能包" class="headerlink" title="9.2 On-Call技能包"></a>9.2 On-Call技能包</h1><blockquote><p>一般来说，人们希望On-Call工程师能做出快速反应，但不一定需要快速解决问题。</p></blockquote><h1 id="9-3-事故处理"><a href="#9-3-事故处理" class="headerlink" title="9.3 事故处理"></a>9.3 事故处理</h1><blockquote><p>任何回顾总结文档的关键部分是根本原因分析(root-cause analysis，RCA)。<br>根本原因分析是利用5个“Why”进行的。这种技巧非常简单：不断地追问为什么。<br>以一个问题为例，问它为什么会发生。<br>当你得到一个答案时，再问一次为什么；一直问为什么，直到你找到根本原因。<br>“5W”只是口口相传的经验——大多数问题要经过5次反复才能找到根本原因。</p></blockquote><h1 id="10-5-协作设计"><a href="#10-5-协作设计" class="headerlink" title="10.5 协作设计"></a>10.5 协作设计</h1><blockquote><p>提出问题和给予建议一样重要，问题会帮助你成长。就像在课堂上一样，你可能不是唯一对某项设计决定感到疑惑的人，所以你的问题也会帮助其他人成长。</p></blockquote><h1 id="10-6-行为准则"><a href="#10-6-行为准则" class="headerlink" title="10.6 行为准则"></a>10.6 行为准则</h1><p><img src="https://wyiyi.github.io/amber/contents/2024/readme-10.6.png"></p><h1 id="12-3-Scrum框架"><a href="#12-3-Scrum框架" class="headerlink" title="12.3 Scrum框架"></a>12.3 Scrum框架</h1><blockquote><p>团队的工作能力是以故事点来衡量的，这是一个约定好的尺度单位（以小时、天或“复杂性”来度量）。</p></blockquote><h1 id="12-7-路线图"><a href="#12-7-路线图" class="headerlink" title="12.7 路线图"></a>12.7 路线图</h1><blockquote><p>“在准备战斗时，我总是发现计划是无用的，但计划是不可缺少的。”</p></blockquote><h1 id="13-与管理者合作"><a href="#13-与管理者合作" class="headerlink" title="13 与管理者合作"></a>13 与管理者合作</h1><blockquote><p>与你的管理者构建工作关系将有助于你发展你的职业生涯、减少压力，甚至交付可靠的软件。</p></blockquote><h1 id="13-2-沟通、目标与成长"><a href="#13-2-沟通、目标与成长" class="headerlink" title="13.2 沟通、目标与成长"></a>13.2 沟通、目标与成长</h1><blockquote><p>一对一面谈(1∶1)和进展、计划与问题(progress-plans-problems，PPP)报告用于沟通和更新项目状态，而目标和关键结果(OKR)以及绩效评估则管理目标和成长。</p><p>你要在一对一面谈中设置议程，一对一面谈不是用来更新工作状态的。</p></blockquote><blockquote><p>PPP是一种常用的更新工作状态的格式。更新工作状态并不是为了计算你的时间，它是为了帮助你的管理者发现问题，找到你需要背景信息的领域，以及提供将你与正确的人联系起来的机会。</p><p>顾名思义，PPP中的每个P（进展、计划与问题）都有自己的小节。每个小节应该有3到5个要点，每个要点应该很简短，只有1到3个句子。</p></blockquote><h1 id="13-3-向上管理"><a href="#13-3-向上管理" class="headerlink" title="13.3 向上管理"></a>13.3 向上管理</h1><blockquote><ul><li>接受反馈</li><li>给予反馈</li><li>讨论你的目标</li><li>事情不顺时要采取行动</li></ul></blockquote><h1 id="14-2-职业生涯建议"><a href="#14-2-职业生涯建议" class="headerlink" title="14.2 职业生涯建议"></a>14.2 职业生涯建议</h1><blockquote><ul><li>T型人才<blockquote><p>“T型”工程师在大多数领域内都能有效地工作，并且至少是某一个领域的专家。</p><p>请从构建你的基本盘开始。构建基本盘会让你接触到不同的子领域，这样你就能找到自己的激情所在。</p></blockquote></li><li>参加工程师训练营</li><li>主导你自己的晋升<blockquote><p>一旦你了解了评估标准和晋升流程，就进行自我评估，并获得他人的反馈。</p><p>如果你收到了不认同的反馈，试着理解这些反馈来自哪里。其他人可能对你的工作有不完整的视角，或者你工作的价值可能不被认可。</p></blockquote></li><li>换工作需谨慎</li><li>自我调节</li></ul></blockquote><h1 id="14-3-结尾寄语"><a href="#14-3-结尾寄语" class="headerlink" title="14.3 结尾寄语"></a>14.3 结尾寄语</h1><blockquote><p>软件工程师是一个伟大的职业，充满了迷人的挑战。<br>你可以为任何行业做出贡献，从科学到农业、健康、娱乐，甚至是太空探索。<br>你的工作可以改善数十亿人的生活。与你喜欢的人一起工作并解决你所热衷的问题，你就可以完成伟大的事情。<br>我们为你加油，祝你好运！~~</p></blockquote>]]></content>
    
    
    <summary type="html">这本书针对如何改进、如何学习、如何推进职业生涯发展，以及如何成为一名更好的开发者提供不同的方法和步骤。这本书包含适应团队的工作流程、处理会议、如期交付、善用学习工具和技术领域的最佳实践，并指导人们如何成为团队中有价值的成员。</summary>
    
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/categories/Books/"/>
    
    
    <category term="Books" scheme="https://wyiyi.github.io/amber/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>基于 MyBatis 拦截器机制实现一个敏感数据处理组件</title>
    <link href="https://wyiyi.github.io/amber/2024/02/01/mybatis-interceptor/"/>
    <id>https://wyiyi.github.io/amber/2024/02/01/mybatis-interceptor/</id>
    <published>2024-02-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>MyBatis</code> 作为一个流行的持久层框架，提供了拦截器 <code>Interceptor</code> 机制，允许开发者在 <code>SQL</code> 执行过程中插入自定义逻辑。本文将深入探讨 <code>MyBatis</code> 拦截器的用法和使用场景，并以处理敏感数据场景为例实现了一个自定义拦截器。</p><h1 id="Interceptor-介绍"><a href="#Interceptor-介绍" class="headerlink" title="Interceptor 介绍"></a>Interceptor 介绍</h1><p><a href="https://mybatis.org/mybatis-3/zh_CN/configuration.html#%E6%8F%92%E4%BB%B6%EF%BC%88plugins%EF%BC%89">MyBatis 官网中 Interceptor 的介绍：</a></p><blockquote><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p></blockquote><h2 id="Signature-介绍"><a href="#Signature-介绍" class="headerlink" title="Signature 介绍"></a>Signature 介绍</h2><p>在 <a href="https://book.douban.com/subject/27074809/">《MyBatis从入门到精通》</a> 一书中，关于拦截器签名 <code>@Signature</code> 注解中可以使用的接口和方法相关描述如下：</p><ol><li><p><strong>Executor</strong>：</p><ul><li>update: 当执行 INSERT、UPDATE、DELETE 操作时调用。</li><li>query: 在 SELECT 查询方法执行时调用。</li><li>flushStatements: 在通过 SqlSession 方法调用 flushStatements 方法或执行的接口方法中带有 @Flush 注解时才被调用。</li><li>commit: 在通过 SqlSession 方法调用 commit 方法时被调用。</li><li>rollback: 在通过 SqlSession 方法调用 rollback 方法时被调用。</li><li>getTransaction: 在通过 SqlSession 方法获取数据库连接时被调用。</li><li>close: 在延迟加载获取新的 Executor 后才会被执行。</li><li>isClosed: 在延迟加载执行查询方法前被执行。</li></ul></li><li><p><strong>ParameterHandler</strong>：</p><ul><li>getParameterObject: 在执行存储过程处理出参的时候被调用。</li><li>setParameters: 在所有数据库方法设置 SQL 参数时被调用。</li></ul></li><li><p><strong>ResultSetHandler</strong>：</p><ul><li>handleResultSets: 处理查询结果集。</li><li>handleOutputParameters: 使用存储过程处理出参时被调用。</li></ul></li><li><p><strong>StatementHandler</strong>：</p><ul><li>prepare: 在数据库执行前被调用，优先于当前接口中其他方法而被执行。</li><li>parameterize: 在 prepare 方法后执行，用于处理参数信息。</li><li>batch: 在全局设置配置 defaultExecutorType=”BATCH” 时执行数据操作才会调用。</li><li>update: 用于执行更新类型的 SQL 语句。</li><li>query: 用于获取查询返回的结果集。</li></ul></li></ol><h2 id="Interceptor-接口"><a href="#Interceptor-接口" class="headerlink" title="Interceptor 接口"></a>Interceptor 接口</h2><p>通过实现 <code>Interceptor</code> 接口并指定想要拦截的方法签名，可以轻松地实现对 SQL 执行过程的拦截。<br><code>Interceptor</code> 接口包含以下方法：（Mybatis-3.5.1 版本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">plugin</span><span class="params">(Object target)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>intercept(Invocation invocation)</code>: 这个方法用于拦截目标方法并执行自定义逻辑。获取目标方法的参数、方法等信息，并进行处理。</li><li><code>plugin(Object target)</code>: 这个方法用于生成一个代理对象。需要判断目标对象是否需要被拦截，如果需要则返回一个代理对象，否则返回 null。</li><li><code>setProperties(Properties properties)</code>: 这个方法用于设置属性。获取配置文件中的属性，并进行相应的设置。</li></ul><p>在 <code>MyBatis</code> 的配置文件中注册自定义 <code>Interceptor</code> 后，框架会在执行相应的操作时自动调用自定义逻辑。</p><h2 id="Simple-Example"><a href="#Simple-Example" class="headerlink" title="Simple Example"></a>Simple Example</h2><ol><li>创建 <code>ExamplePlugin</code> 类实现 <code>org.apache.ibatis.plugin.Interceptor</code> 接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">   @Signature(type= Executor.class,</span></span><br><span class="line"><span class="meta">              method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">              args = &#123;MappedStatement.class,Object.class&#125;),</span></span><br><span class="line"><span class="meta">   @Signature(type = ResultSetHandler.class, </span></span><br><span class="line"><span class="meta">              method = &quot;handleResultSets&quot;, </span></span><br><span class="line"><span class="meta">              args = &#123;Statement.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnObject</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong>：在 <a href="https://github.com/mybatis/mybatis-3/blob/mybatis-3.5.2/src/main/java/org/apache/ibatis/plugin/Interceptor.java">Mybatis-3.5.2 版本后 Interceptor</a> 接口中定义的方法已给出了默认实现，如无特殊需求，只需实现 <code>intercept</code> 方法，这是 <code>Java 8</code> 默认方法特性的一种应用，旨在简化接口的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code>MyBatis</code> 的配置文件中注册 <code>ExamplePlugin</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><h1 id="敏感数据处理组件"><a href="#敏感数据处理组件" class="headerlink" title="敏感数据处理组件"></a>敏感数据处理组件</h1><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>在持久化的数据涉及敏感内容时，假设有如下三种场景：</p><ol><li>为避免拖库造成的数据泄露风险，敏感数据希望以密文形式存储在数据库中，通过系统读取时可以读取到明文；</li><li>密码类数据在存储前希望进行不可逆的加密处理，读取时也是使用密文进行对比，无需恢复出明文内容；</li><li>展示如手机号等数据时，希望对部分内容进行遮挡，使数据仅保留核对用途。</li></ol><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>上面假设的三种场景可以分为数据的 <code>读取</code> 和 <code>写入</code> 两类操作：</p><ul><li>场景 1 需要在数据写入时加密，读取数据时解密；</li><li>场景 2 在数据写入时加密，读取时无需处理；</li><li>场景 3 在数据读取时进行遮挡，写入时无需处理。</li></ul><p><code>MyBatis</code> 的拦截器签名中，可以选择 <code>Executor</code> 的 <code>update</code> 方法拦截 <code>写入</code> 动作，<code>ResultSetHandler</code> 的 <code>handleResultSets</code> 方法拦截 <code>读取</code> 动作。</p><p>为满足不同类型的敏感数据处理需求，设计一个 <code>DataSensitiveHandler</code> 接口，接口中包含两个方法：</p><ul><li><code>encrypt</code>：实现写入数据前要执行的操作</li><li><code>decrypt</code>：实现读取数据后（返回数据前）要执行的操作</li></ul><p>可以注册不同的 <code>DataSensitiveHandler</code> 实现类，并为实体中的属性（表中字段）配置使用哪个实现进行敏感数据的处理。</p><p>为了尽可能少地修改原有代码，以统一的配置方式实现属性（字段）和处理类的映射。</p><p>具体配置形式参考日志级别配置方式（如：<code>logging.level.com.example.demo.mapper=debug</code>），<br>以 <code>固定前缀</code>.<code>实体package.实体名.属性名</code> = <code>具体处理类唯一标识</code> 进行设置。</p><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><h3 id="自定义敏感数据处理拦截器-DataSensitiveInterceptor"><a href="#自定义敏感数据处理拦截器-DataSensitiveInterceptor" class="headerlink" title="自定义敏感数据处理拦截器 DataSensitiveInterceptor"></a>自定义敏感数据处理拦截器 <code>DataSensitiveInterceptor</code></h3><p>在 <code>intercept</code> 方法中根据配置找到需要处理的属性的处理类（<code>dataSensitiveHandler-</code> 为前缀的 <code>Bean</code>），并根据拦截的写入和读取操作调用对应处理方法，以实现敏感数据处理的要求（如中间部分用*代替、显示密文处理后的结果等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span></span><br><span class="line"><span class="meta">        @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSensitiveInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; configs;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取配置文件中需要加密的属性</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> config DataSensitiveConfig</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DataSensitiveInterceptor</span><span class="params">(DataSensitiveConfig config)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.configs = config.getSensitive();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过拦截器处理</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> invocation invocation</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Object</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="keyword">if</span> (invocation.getTarget() <span class="keyword">instanceof</span> Executor) &#123;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> invocation.getArgs()[<span class="number">1</span>];</span><br><span class="line">         <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) object;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!entry.getKey().startsWith(<span class="string">&quot;param&quot;</span>)) &#123;</span><br><span class="line">                  handleEncrypt(entry.getValue());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleEncrypt(object);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invocation.getTarget() <span class="keyword">instanceof</span> ResultSetHandler) &#123;</span><br><span class="line">         <span class="type">ResultSetHandler</span> <span class="variable">resultSetHandler</span> <span class="operator">=</span> (ResultSetHandler) invocation.getTarget();</span><br><span class="line">         <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> (Statement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">         List&lt;Object&gt; resultList = resultSetHandler.handleResultSets(statement);</span><br><span class="line">         resultList.forEach(<span class="built_in">this</span>::handleDecrypt);</span><br><span class="line">         <span class="keyword">return</span> resultList;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleEncrypt</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">      handleObject(object, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleDecrypt</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">      handleObject(object, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleObject</span><span class="params">(Object object, <span class="type">boolean</span> encrypt)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; config : configs.entrySet()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">lastPoint</span> <span class="operator">=</span> config.getKey().lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> config.getKey().substring(<span class="number">0</span>, lastPoint);</span><br><span class="line">         <span class="keyword">if</span> (object.getClass().getName().equals(className)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> config.getKey().substring(lastPoint + <span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> config.getValue();</span><br><span class="line">            <span class="type">DataSensitiveHandler</span> <span class="variable">handler</span> <span class="operator">=</span> SpringContextHolder.getBean(<span class="string">&quot;dataSensitiveHandler-&quot;</span> + handlerName);</span><br><span class="line">            <span class="type">BeanWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(object);</span><br><span class="line">            wrapper.setPropertyValue(property,</span><br><span class="line">                    wrapper.getPropertyValue(property) == <span class="literal">null</span> ? <span class="literal">null</span> :</span><br><span class="line">                            encrypt ? handler.encrypt(String.valueOf(wrapper.getPropertyValue(property))) :</span><br><span class="line">                                    handler.decrypt(String.valueOf(wrapper.getPropertyValue(property)))</span><br><span class="line">            );</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置类-DataSensitiveConfig"><a href="#配置类-DataSensitiveConfig" class="headerlink" title="配置类 DataSensitiveConfig"></a>配置类 <code>DataSensitiveConfig</code></h3><p>配置参数以前缀 <code>com.amber.common.sensitive</code> 开头，以 Map 形式存储相关参数配置，其中：</p><ul><li><code>key</code> 设置为 MyBatis Mapper 实体类全名及要处理敏感数据的属性，如 <code>UserDO</code> 的 <code>phone</code> 属性设置为：<code>com.amber.common.sensitive.mock.entity.UserDO.phone</code></li><li><code>value</code> 设置为敏感数据处理类 <code>bean name</code> 的后缀，查找 bean 时加上 <code>dataSensitiveHandler-</code> 前缀组成完整 <code>bean name</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;com.amber.common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSensitiveConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; sensitive = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getSensitive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sensitive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="敏感数据处理接口-DataSensitiveHandler"><a href="#敏感数据处理接口-DataSensitiveHandler" class="headerlink" title="敏感数据处理接口 DataSensitiveHandler"></a>敏感数据处理接口 <code>DataSensitiveHandler</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSensitiveHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在写入数据时对数据做的处理</span></span><br><span class="line"><span class="comment">    * 默认为不进行任何操作</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> str 将要写入的数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 实际写入的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">default</span> String <span class="title function_">encrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在读取数据时对数据做的处理</span></span><br><span class="line"><span class="comment">    * 默认为不进行任何操作</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> str 实际读到的数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回给调用者的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">default</span> String <span class="title function_">decrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置敏感数据处理实现"><a href="#内置敏感数据处理实现" class="headerlink" title="内置敏感数据处理实现"></a>内置敏感数据处理实现</h3><p>为每类场景提供一个内置敏感数据处理实现：</p><ul><li><code>abb</code>：对字符串中间部分使用 <code>*</code> 遮挡，仅在读取数据时执行操作</li><li><code>md5</code>：对字符串进行 md5 摘要，仅在写入数据时执行操作</li><li><code>sm4hex</code>：使用国密 SM4 算法进行对称加解密，以 16 进制表示加密结果，在写入及读取时均执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 敏感数据处理器：使用 * 遮挡明文中间部分，保留前后内容。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 仅在读取明文数据并返回时，进行遮挡处理；</span></span><br><span class="line"><span class="comment"> * 存入明文数据时，不对存入内容进行变更。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 遮挡方式为：&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1. 明文长度为 1 时，不遮挡&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 2. 明文长度为 2 时，遮挡第二位&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 3. 明文长度大于 2 时，将明文分成三部分，遮挡中间部分；不能整除时，尽可能使遮挡部分较多&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 遮挡后内容长度与明文保持一致。</span></span><br><span class="line"><span class="comment"> * 如：&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 明文                   | 遮挡后&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;a&#x27;                   | &#x27;a&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;ab&#x27;                  | &#x27;a*&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;abc&#x27;                 | &#x27;a*c&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;abcd&#x27;                | &#x27;a**d&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;13012345678&#x27;         | &#x27;130*****678&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;123456789012345678&#x27;  | &#x27;123456******345678&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#x27;这是一段测试文字&#x27;       | &#x27;这是****文字&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注册 bean 使用 ”dataSensitiveHandler-“ 固定前缀，abb 为后缀，意为 abbreviation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;dataSensitiveHandler-abb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSensitiveAbbHandler</span> <span class="keyword">implements</span> <span class="title class_">DataSensitiveHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">MASK</span> <span class="operator">=</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现解密方法，对字符串中间部分使用 `*` 遮挡</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> str str</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">decrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(str)) &#123;</span><br><span class="line">         <span class="keyword">return</span> str;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">      <span class="keyword">switch</span> (len) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> str.substring(<span class="number">0</span>, <span class="number">1</span>) + MASK;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="type">int</span> <span class="variable">oriLen</span> <span class="operator">=</span> len / <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maskLen</span> <span class="operator">=</span> len - oriLen * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> str.substring(<span class="number">0</span>, oriLen) +</span><br><span class="line">                    StringUtils.repeat(MASK, maskLen) +</span><br><span class="line">                    str.substring(oriLen + maskLen);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义处理器注册 bean，”dataSensitiveHandler-“ 为固定前缀</span></span><br><span class="line"><span class="comment"> * 自定义后缀：对字符串进行 md5 摘要，仅在写入数据时执行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;dataSensitiveHandler-md5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSensitiveMd5Handler</span> <span class="keyword">implements</span> <span class="title class_">DataSensitiveHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义处理器注册 bean，”dataSensitiveHandler-“ 为固定前缀</span></span><br><span class="line"><span class="comment"> * 自定义后缀：sm4 使用国密 SM4 算法进行对称加解密，在写入及读取时均执行</span></span><br><span class="line"><span class="comment"> * 条件注册 Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &#123;&quot;org.bouncycastle.crypto.Digest&quot;, &quot;org.bouncycastle.asn1.gm.GMNamedCurves&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component(&quot;dataSensitiveHandler-sm4hex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSensitiveSm4HexHandler</span> <span class="keyword">implements</span> <span class="title class_">DataSensitiveHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SymmetricCrypto</span> <span class="variable">SM4</span> <span class="operator">=</span> SmUtil.sm4();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用国密 SM4 算法进行加密</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> str 明文</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 密文 16 进制表示</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> SM4.encryptHex(str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用国密 SM4 算法进行解密</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> str 密文</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 明文</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">decrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> SM4.decryptStr(str, CharsetUtil.CHARSET_UTF_8);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要其他类型的处理类时，注册一个实现了 <code>DataSensitiveHandler</code> 的 bean 即可。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>支持 <code>yml</code> 和 <code>properties</code> 文件格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com:</span></span><br><span class="line">  <span class="attr">amber:</span></span><br><span class="line">    <span class="attr">common:</span></span><br><span class="line">      <span class="attr">sensitive:</span></span><br><span class="line">        <span class="attr">com.amber.common.sensitive.mock.entity.UserDO.phone:</span> <span class="string">abb</span></span><br><span class="line">        <span class="attr">com.amber.common.sensitive.mock.entity.UserDO.idCard:</span> <span class="string">sm4hex</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.amber.common.sensitive.com.amber.common.sensitive.mock.entity.UserDO.password</span>=<span class="string">md5</span></span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul><li>加密和解密：确保敏感数据在写入数据库时被正确加密，并在从数据库读取时被正确解密。</li><li>配置解析：验证配置文件中的敏感字段是否正确地被解析并应用到拦截器中。</li><li>不同处理器的应用：测试不同的敏感数据处理器（如 abb、md5、sm4）是否按照预期工作。</li><li>非敏感字段的不处理：确保非敏感字段在拦截器中不被错误地处理。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sql</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSensitiveTest</span> <span class="keyword">extends</span> <span class="title class_">BaseApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   UserDAO userDAO</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   RoleDAO roleDAO</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   UserService userService</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   RoleService roleService</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   UserRoleService userRoleService</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   UserHistoryService userHistoryService</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   JdbcTemplate jdbcTemplate</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="keyword">static</span> <span class="keyword">final</span> MD5_LEN = <span class="number">32</span></span><br><span class="line">   <span class="keyword">def</span> name = <span class="string">&#x27;user name&#x27;</span></span><br><span class="line">   <span class="keyword">def</span> phone = <span class="string">&#x27;12345678901&#x27;</span></span><br><span class="line">   <span class="keyword">def</span> idCard = <span class="string">&#x27;234098uzxcv&#x27;</span></span><br><span class="line">   <span class="keyword">def</span> pwd = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="type">void</span> cruTest() &#123;</span><br><span class="line">      <span class="keyword">def</span> user = testCreate()</span><br><span class="line">      <span class="keyword">def</span> retrievedUser = testRetrieve(user.getId())</span><br><span class="line">      testUpdate(retrievedUser)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> testCreate() &#123;</span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select count(*) from userinfo&#x27;</span>, Integer) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      UserDO user = <span class="keyword">new</span> UserDO()</span><br><span class="line">      user.setName(name)</span><br><span class="line">      user.setPhone(phone)</span><br><span class="line">      user.setIdCard(idCard)</span><br><span class="line">      user.setPassword(pwd)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> userDAO.insert(user) == <span class="number">1</span></span><br><span class="line">      <span class="keyword">assert</span> user.getId() &gt; <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="comment">// abb handler</span></span><br><span class="line">      <span class="keyword">assert</span> user.getPhone() == phone</span><br><span class="line">      <span class="comment">// md5 handler</span></span><br><span class="line">      <span class="keyword">assert</span> user.getPassword().length() == MD5_LEN</span><br><span class="line">      <span class="comment">// sm4hex handler</span></span><br><span class="line">      <span class="keyword">assert</span> user.getIdCard() != idCard &amp;&amp; user.getIdCard().length() == getSm4HexLen(idCard)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select count(*) from userinfo&#x27;</span>, Integer) == <span class="number">1</span></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select phone from userinfo&#x27;</span>, String) == phone</span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select password from userinfo&#x27;</span>, String).length() == MD5_LEN</span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select id_card from userinfo&#x27;</span>, String) != <span class="string">&#x27;234098uzxcv&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select id_card from userinfo&#x27;</span>, String).length() == getSm4HexLen(idCard)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> user</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> getSm4HexLen(String str) &#123;</span><br><span class="line">      <span class="comment">// SM4算法的块大小为16字节</span></span><br><span class="line">      <span class="type">int</span> blockSize = <span class="number">16</span></span><br><span class="line">      str &gt; <span class="string">&#x27;&#x27;</span> ?</span><br><span class="line">              ((int) (str.getBytes(StandardCharsets.UTF_8).length / blockSize) + <span class="number">1</span>) * blockSize * <span class="number">2</span> :</span><br><span class="line">              <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> testRetrieve(String userId) &#123;</span><br><span class="line">      UserDO retrievedUser = userDAO.selectById(userId)</span><br><span class="line">      <span class="keyword">assert</span> retrievedUser.getPhone() != phone</span><br><span class="line">      <span class="keyword">assert</span> retrievedUser.getPhone() == <span class="string">&#x27;123*****901&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUser.getIdCard() == idCard</span><br><span class="line">      <span class="keyword">return</span> retrievedUser</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> testUpdate(UserDO userToUpdate) &#123;</span><br><span class="line">      <span class="keyword">def</span> newPhone = <span class="string">&#x27;01234567890&#x27;</span></span><br><span class="line">      <span class="keyword">def</span> newIdCard = <span class="string">&#x27;12345678901234567&#x27;</span></span><br><span class="line"></span><br><span class="line">      userToUpdate.setPhone(newPhone)</span><br><span class="line">      userToUpdate.setIdCard(newIdCard)</span><br><span class="line">      userDAO.updateById(userToUpdate)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> userToUpdate.getPhone() == newPhone</span><br><span class="line">      <span class="keyword">assert</span> userToUpdate.getIdCard() != newIdCard</span><br><span class="line">      <span class="keyword">assert</span> userToUpdate.getIdCard().length() == getSm4HexLen(newIdCard)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select phone from userinfo&#x27;</span>, String) == newPhone</span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select id_card from userinfo&#x27;</span>, String) != newIdCard</span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> retrievedUser = userDAO.selectById(userToUpdate.getId())</span><br><span class="line">      <span class="keyword">assert</span> retrievedUser.getPhone() == <span class="string">&#x27;012*****890&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUser.getIdCard() == newIdCard</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="type">void</span> batchTest() &#123;</span><br><span class="line">      testBatchInsert()</span><br><span class="line">      List&lt;UserDO&gt; retrievedUsers = testBatchRetrieve()</span><br><span class="line">      testBatchUpdate(retrievedUsers)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> testBatchInsert() &#123;</span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select count(*) from userinfo&#x27;</span>, Integer) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      List&lt;UserDO&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">      <span class="number">3.</span>times &#123;</span><br><span class="line">         UserDO user = <span class="keyword">new</span> UserDO()</span><br><span class="line">         user.setName(<span class="string">&quot;$&#123;name&#125;$&#123;it+1&#125;&quot;</span>)</span><br><span class="line">         user.setPhone(<span class="string">&quot;$&#123;phone&#125;$&#123;it+1&#125;&quot;</span>)</span><br><span class="line">         user.setPassword(<span class="string">&quot;$&#123;pwd&#125;$&#123;it+1&#125;&quot;</span>)</span><br><span class="line">         user.setIdCard(<span class="string">&quot;$&#123;idCard&#125;$&#123;it+1&#125;&quot;</span>)</span><br><span class="line">         users.add(user)</span><br><span class="line">      &#125;</span><br><span class="line">      userService.saveBatch(users)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&#x27;select count(*) from userinfo&#x27;</span>, Integer) == <span class="number">3</span></span><br><span class="line">      <span class="comment">// sm4hex handler</span></span><br><span class="line">      <span class="keyword">assert</span> users.get(<span class="number">0</span>).getIdCard() != idCard</span><br><span class="line">      <span class="keyword">assert</span> users.get(<span class="number">0</span>).getIdCard().length() == getSm4HexLen(idCard)</span><br><span class="line">      <span class="comment">// abb handler</span></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForList(<span class="string">&#x27;select phone from userinfo&#x27;</span>, String) == [<span class="string">&quot;$&#123;phone&#125;1&quot;</span>, <span class="string">&quot;$&#123;phone&#125;2&quot;</span>, <span class="string">&quot;$&#123;phone&#125;3&quot;</span>]</span><br><span class="line">      <span class="keyword">assert</span> users.get(<span class="number">0</span>).getPhone() == <span class="string">&quot;$&#123;phone&#125;1&quot;</span></span><br><span class="line">      <span class="comment">// sm4hex handler</span></span><br><span class="line">      <span class="keyword">def</span> queriedIdCard = jdbcTemplate.queryForObject(<span class="string">&quot;select id_card from userinfo where user_name=&#x27;$&#123;name&#125;2&#x27;&quot;</span>, String)</span><br><span class="line">      <span class="keyword">assert</span> queriedIdCard != <span class="string">&quot;$&#123;idCard&#125;2&quot;</span></span><br><span class="line">      <span class="keyword">assert</span> queriedIdCard.length() == getSm4HexLen(<span class="string">&quot;$&#123;idCard&#125;2&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> testBatchRetrieve() &#123;</span><br><span class="line">      List&lt;UserDO&gt; retrievedUsers = userService.list()</span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers.size() == <span class="number">3</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">0</span>].getPhone() == <span class="string">&#x27;1234****9011&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">1</span>].getPhone() == <span class="string">&#x27;1234****9012&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">2</span>].getPhone() == <span class="string">&#x27;1234****9013&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">0</span>].getIdCard() == <span class="string">&quot;$&#123;idCard&#125;1&quot;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">1</span>].getIdCard() == <span class="string">&quot;$&#123;idCard&#125;2&quot;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">2</span>].getIdCard() == <span class="string">&quot;$&#123;idCard&#125;3&quot;</span></span><br><span class="line">      <span class="keyword">return</span> retrievedUsers</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> testBatchUpdate(List&lt;UserDO&gt; retrievedUsers) &#123;</span><br><span class="line">      List&lt;UserDO&gt; usersToUpdate = <span class="keyword">new</span> ArrayList&lt;UserDO&gt;()</span><br><span class="line">      <span class="keyword">for</span> (UserDO <span class="attr">user :</span> retrievedUsers) &#123;</span><br><span class="line">         user.setPhone(phone.reverse())</span><br><span class="line">         user.setIdCard(idCard.reverse())</span><br><span class="line">         usersToUpdate.add(user)</span><br><span class="line">      &#125;</span><br><span class="line">      userService.updateBatchById(usersToUpdate)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from userinfo where phone = &#x27;$&#123;phone.reverse()&#125;&#x27;&quot;</span>, Integer) == <span class="number">3</span></span><br><span class="line">      <span class="keyword">assert</span> jdbcTemplate.queryForObject(<span class="string">&quot;select id_card from userinfo where user_name=&#x27;$&#123;name&#125;3&#x27;&quot;</span>, String).length() == getSm4HexLen(<span class="string">&quot;$&#123;idCard.reverse()&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">      QueryWrapper&lt;UserDO&gt; wrapper = <span class="keyword">new</span> QueryWrapper()</span><br><span class="line">      wrapper.eq(<span class="string">&#x27;phone&#x27;</span>, phone.reverse())</span><br><span class="line">      retrievedUsers = userService.list(wrapper)</span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers.size() == <span class="number">3</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">0</span>].getPhone() == <span class="string">&#x27;109*****321&#x27;</span></span><br><span class="line">      <span class="keyword">assert</span> retrievedUsers[<span class="number">1</span>].getIdCard() == idCard.reverse()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整实例可见<a href="https://github.com/wyiyi/bronze">仓库</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>通过 MyBatis 新增或保存实体时，传入的实体在方法调用后，配置为敏感数据的属性会变成应用了敏感处理器 <code>encrypt</code> 方法之后的值</li><li>通过 MyBatis 查询实体时，检索出的实体对象中，配置了敏感数据的属性会变成应用了敏感处理器 <code>decrypt</code> 方法之后的值</li><li>不通过 MyBatis 操作的数据，不会应用敏感数据处理器处理数据</li><li><strong>存入数据库中的数据在执行了敏感处理后将丧失按照处理前的数据进行查询的能力，只能按照处理后的数据进行查询</strong></li></ul>]]></content>
    
    
    <summary type="html">本文探讨了 MyBatis 拦截器的用法和使用场景，并以处理敏感数据场景为例实现了一个自定义拦截器。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://wyiyi.github.io/amber/tags/Java/"/>
    
    <category term="Mybatis" scheme="https://wyiyi.github.io/amber/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>离线环境下 Maven 编译打包</title>
    <link href="https://wyiyi.github.io/amber/2024/01/01/maven-offline-build/"/>
    <id>https://wyiyi.github.io/amber/2024/01/01/maven-offline-build/</id>
    <published>2024-01-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某些离线场景下我们可能无法连接 Maven 中央库或其他内网私服，又想通过 Maven 对源码进行编译打包。</p><p>本文给出了在离线环境下使用 Maven 编译打包的方案。</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>假设目标环境已经安装好了 JDK 和 Maven，并且将要编译的源码工程 <code>demo-project</code> 放置在了 <code>/maven-offline/build</code> 路径下。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="准备编译所需依赖"><a href="#准备编译所需依赖" class="headerlink" title="准备编译所需依赖"></a>准备编译所需依赖</h2><p>先在联网环境成功执行一次编译，保证使用的 Maven 本地缓存仓库（默认路径 <code>~/.m2/repository</code>）中包含了编译所需的依赖。</p><p>将本地缓存仓库目录 <code>repository</code> 发送至离线环境 <code>/maven-offline/build</code> 路径下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── demo-project</span><br><span class="line">└── repository</span><br></pre></td></tr></table></figure><h3 id="清理所有-remote-repositories-文件"><a href="#清理所有-remote-repositories-文件" class="headerlink" title="清理所有 _remote.repositories 文件"></a>清理所有 <code>_remote.repositories</code> 文件</h3><p><strong><code>repository</code> 目录中可能包含了很多 <code>_remote.repositories</code> 文件，需先将这些文件进行清理，否则还是会去中央库查找依赖。</strong></p><ul><li>Windows：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /r %i <span class="keyword">in</span> (_remote.repositories) <span class="keyword">do</span> <span class="built_in">del</span> %i</span><br></pre></td></tr></table></figure><ul><li>Linux：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./repository -name <span class="string">&quot;_remote.repositories&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="Maven-离线编译配置"><a href="#Maven-离线编译配置" class="headerlink" title="Maven 离线编译配置"></a>Maven 离线编译配置</h2><p>在 <code>/maven-offline/build/</code> 下新建 <code>settings.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/maven-offline/build/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">offline</span>&gt;</span>true<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件中只需设定两个 <a href="https://maven.apache.org/settings.html#simple-values">Simple Values</a>：</p><ol><li><code>localRepository</code>：指定清理过 <code>_remote.repositories</code> 文件的路径</li><li><code>offline</code>：使用离线模式</li></ol><h2 id="指定配置文件执行编译"><a href="#指定配置文件执行编译" class="headerlink" title="指定配置文件执行编译"></a>指定配置文件执行编译</h2><p>以在 <code>/maven-offline/build/</code> 路径下执行命令为例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── demo-project</span><br><span class="line">├── repository</span><br><span class="line">└── settings.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -s settings.xml -f demo-project/pom.xml clean package</span><br></pre></td></tr></table></figure><p><img src="https://wyiyi.github.io/amber/contents/2023/nice.gif"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Remember_Z/article/details/119523295">maven离线环境配置（纯内网）</a></li></ul>]]></content>
    
    
    <summary type="html">本文给出了在离线环境下使用 Maven 编译打包的方案。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://wyiyi.github.io/amber/tags/Java/"/>
    
    <category term="Maven" scheme="https://wyiyi.github.io/amber/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus 中的 IService 和 BaseMapper</title>
    <link href="https://wyiyi.github.io/amber/2023/12/01/mybatis-plus/"/>
    <id>https://wyiyi.github.io/amber/2023/12/01/mybatis-plus/</id>
    <published>2023-12-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mybatis.plus/guide/">MyBatis-Plus</a> 作为一个优秀的 ORM 框架，致力于简化和提高 Java 应用程序对数据库访问的效率。</p><p>在使用的过程中，发现 MyBatis-Plus 提供了 BaseMapper 和 IService 两个核心接口，但有些相似之处：它们如何使用及使用场景分别是什么？</p><p><img src="https://wyiyi.github.io/amber/contents/2023/BaseMapper.png"></p><p><img src="https://wyiyi.github.io/amber/contents/2023/IService.png"></p><h2 id="BaseMapper-接口"><a href="#BaseMapper-接口" class="headerlink" title="BaseMapper 接口"></a>BaseMapper 接口</h2><p><a href="https://baomidou.com/pages/49cc81/#mapper-crud-%E6%8E%A5%E5%8F%A3">BaseMapper</a> 接口是 MyBatis-Plus 提供的通用 Mapper 接口，它继承自 mybatis-plus 的 Mapper 接口，并扩展了一些常用的数据库操作方法。</p><blockquote><p>说明:</p><ul><li>通用 CRUD 封装 <code>BaseMapper</code> 接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为 <code>条件构造器</code></li></ul></blockquote><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-core/src/main/java/com/baomidou/mybatisplus/core/mapper/BaseMapper.java">BaseMapper</a> 接口的主要作用是定义 DAO 层的数据库操作方法，例如数据的增删改查等。</p><p>开发者可以通过继承 BaseMapper 接口，并指定对应的实体类，即可直接使用这些通用方法，无需手动编写 SQL 语句，从而减少了代码量和重复劳动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IService-接口"><a href="#IService-接口" class="headerlink" title="IService 接口"></a>IService 接口</h2><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService</a> 接口是 MyBatis-Plus 提供的通用 Service 接口。</p><blockquote><p>说明:</p><ul><li>通用 <a href="https://baomidou.com/pages/49cc81/#service-crud-%E6%8E%A5%E5%8F%A3">Service CRUD</a> 封装 IService 接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆</li><li>泛型 <code>T</code> 为任意实体对象</li><li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li><li>对象 <code>Wrapper</code> 为 <code>条件构造器</code></li></ul></blockquote><p>开发者可以通过继承 IService 接口，并指定对应的实体类，即可直接使用这些通用方法，无需手动编写业务逻辑代码，使得代码更加简洁和易于维护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义常用的业务逻辑方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServiceImpl"><a href="#ServiceImpl" class="headerlink" title="ServiceImpl"></a>ServiceImpl</h2><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/impl/ServiceImpl.java#L60C22-L60C22">ServiceImpl</a>是 IService 默认实现类，ServiceImpl 是针对业务逻辑层的实现，并调用 BaseMapper 来操作数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span>&lt;M <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;T&gt;, T&gt; <span class="keyword">implements</span> <span class="title class_">IService</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的参数为 M 和 T：</p><ul><li>M：Mapper 接口类型</li><li>T：对应实体类的类型</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>简单的数据库操作可以继承 BaseMapper 并添加新的数据库操作；</li><li>简单的业务逻辑可以只使用 IService，IService 是对 BaseMapper 的扩展但仍需调用 Mapper；</li><li>BaseMapper 和 IService 主要区别： IService 提供批量处理操作（IService 和 BaseMapper 需一起使用），BaseMapper 则没有；</li></ol><p>BaseMapper 、IService、ServiceImpl 三者的类关系从源码中可看出：</p><ul><li>最简单的方式：自定义 Mapper 接口并继承 BaseMapper，则不需要去实现其内部方法，依靠 mybatis 的动态代理即可实现 CRUD 操作；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果自定义 Service 接口并继承 IService，则需实现 IService 中的方法；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateSaveBatch</span><span class="params">(List&lt;User&gt; userList)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.saveBatch(userList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以写成如下方式：则可省略 UserMapper 接口，直接操作数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BaseMapper&lt;User&gt;, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="既用之，则听之"><a href="#既用之，则听之" class="headerlink" title="既用之，则听之"></a>既用之，则听之</h2><p>大家对于 mybatis plus 的 <code>BaseMapper</code>以及 <code>IService</code> 以及 <code>ServiceImpl</code> 还是存在很大争议，并在 <a href="https://github.com/baomidou/mybatis-plus/issues">issue</a> 中火热讨论（如下链接），最后还是以官方为主，若有改动文章在做后续调整。</p><ul><li><a href="https://github.com/baomidou/mybatis-plus/issues/5764">关于改进 IService 和 ServiceImpl 的建议</a></li><li><a href="https://github.com/baomidou/mybatis-plus/issues/59">关于 mybatis plus 中的 BaseMapper<T> 以及 IService<T> 以及 ServiceImpl&lt;M extends <Basemapper>，T&gt; 这几个类</a></li><li><a href="https://github.com/baomidou/mybatis-plus/issues/926">mybatis-plus 的一种很别扭的用法</a></li></ul>]]></content>
    
    
    <summary type="html">MyBatis-Plus 提供了 BaseMapper 和 IService 两个核心接口，但有些相似之处：它们如何使用及使用场景分别是什么？</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Mybatis-plus" scheme="https://wyiyi.github.io/amber/tags/Mybatis-plus/"/>
    
  </entry>
  
  <entry>
    <title>查看依赖树的利器</title>
    <link href="https://wyiyi.github.io/amber/2023/10/01/Dependency%20Tree/"/>
    <id>https://wyiyi.github.io/amber/2023/10/01/Dependency%20Tree/</id>
    <published>2023-10-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.615Z</updated>
    
    <content type="html"><![CDATA[<p>依赖树（Dependency Tree）工具，可以查看和分析项目的依赖关系。</p><p>本文将介绍 maven 和 gradle 两种构建如何查看依赖树。</p><h2 id="使用命令行查看"><a href="#使用命令行查看" class="headerlink" title="使用命令行查看"></a>使用命令行查看</h2><ol><li><p>命令行工具来查看项目的依赖树，执行命令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle dependencies</span><br></pre></td></tr></table></figure></li><li><p>对于大型项目，可以将输出结果保存到文件中：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree &gt; dependency_tree.txt</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle dependencies &gt; dependencies.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-IDEA-查看-Show-dependencies"><a href="#使用-IDEA-查看-Show-dependencies" class="headerlink" title="使用 IDEA 查看 Show dependencies"></a>使用 IDEA 查看 Show dependencies</h2><ol><li>按下图操作：</li></ol><ul><li>找到 Dependencies 选项展开后即可查看项目的编译的依赖树</li><li>点击 show dependencies 显示依赖树结果图三（快捷键（ctrl+alt+shift+u）<br><img src="https://wyiyi.github.io/amber/contents/tree/idea_1.png" alt="图一_maven"><br><img src="https://wyiyi.github.io/amber/contents/tree/gradle_1.png" alt="图一_gradle"></li></ul><ol start="2"><li><p>打开文件（pom.xml 或者 .gradle）右键，如图点击 show dependencies 后显示依赖树结果图三<br><img src="https://wyiyi.github.io/amber/contents/tree/idea_2.png" alt="图二_maven"><br><img src="https://wyiyi.github.io/amber/contents/tree/gradle_2.png" alt="图二_gradle"></p></li><li><p>使用快捷键 ctrl + f 可以搜索要查找的 Jar 定位到依赖关系。（注意：IDEA 版本）<br><img src="https://wyiyi.github.io/amber/contents/tree/idea_3.png" alt="图三_maven"><br><img src="https://wyiyi.github.io/amber/contents/tree/gradle_3.png" alt="图三_gradle"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依赖树功能是项目依赖管理的重要工具，能够帮助我们查看和分析项目的依赖关系，解决依赖冲突问题，并进行优化和调整。</p>]]></content>
    
    
    <summary type="html">依赖树（Dependency Tree）工具，可以查看和分析项目的依赖关系。本文将介绍 maven 和 gradle 两种构建如何查看依赖树。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Maven" scheme="https://wyiyi.github.io/amber/tags/Maven/"/>
    
    <category term="Gradle" scheme="https://wyiyi.github.io/amber/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>探索前端的 this 指向</title>
    <link href="https://wyiyi.github.io/amber/2023/09/01/this/"/>
    <id>https://wyiyi.github.io/amber/2023/09/01/this/</id>
    <published>2023-09-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.618Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，this 是一个常见的概念。<br>它代表了当前执行上下文中的对象或函数，并且在不同的情况下，this 的指向也会有所不同。</p><p>本文将深入探讨 <code>this</code> 在前端开发中的应用场景以及不同情况下的指向规则，更好地理解和运用 <code>this</code> 指向。</p><h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><h2 id="1、普通函数、箭头函数组合使用"><a href="#1、普通函数、箭头函数组合使用" class="headerlink" title="1、普通函数、箭头函数组合使用"></a>1、普通函数、箭头函数组合使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;TOM&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">  <span class="title class_">SayHi</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">//问题1 这个this又指向谁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">SayFoo</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">//问题2 这个this又指向谁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title class_">SayHi</span>()()</span><br><span class="line">obj.<span class="title class_">SayFoo</span>()()</span><br></pre></td></tr></table></figure><h2 id="2、改变-this-指向"><a href="#2、改变-this-指向" class="headerlink" title="2、改变 this 指向"></a>2、改变 this 指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;win&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">a</span>.<span class="title function_">call</span>(obj1);</span><br></pre></td></tr></table></figure><p>别急，答案和解析逐步揭晓。</p><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>在 <code>JavaScript</code> 中，函数的 <code>this</code> 关键字与其他语言有一些不同。<br>它也在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>和非严格模式下有一些区别。</p><p>在大多数情况下，<code>this</code> 的值取决于函数的调用方式（运行时绑定）。<br><code>this</code> 不能在执行期间被赋值，在每次函数被调用时 this 的值也可能会不同。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>this</code> 的值取决于它出现在哪个上下文中：函数、类、或者全局。</p><ul><li><p>在非严格模式下，始终是对象的引用。当函数被调用时，<code>JavaScript</code> 会自动设置 <code>this</code> 的值。</p><ul><li>如果函数作为对象的方法调用，<code>this</code> 指向该对象</li><li>如果函数独立调用，<code>this</code> 指向全局对象</li></ul></li><li><p>在严格模式下，它可以是任何值。<code>this</code> 的值不再是默认绑定到全局对象，而是根据调用方式和上下文来确定。</p><ul><li>如果函数作为对象的方法调用，this 将绑定到该对象</li><li>如果使用 <code>call()</code>、<code>apply()</code> 或 <code>bind()</code> 显示指定 <code>this</code> 值，将绑定到相应的值</li><li>如果函数是使用构造函数调用，<code>this</code> 将绑定到新创建的对象</li><li>对于箭头函数，没有自己的 <code>this</code> 绑定，而是集成了外部函数的 <code>this</code> 值</li></ul></li></ul><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>函数中的 <code>this</code> 的值取决于函数的调用方式，可将 <code>this</code> 视为函数的隐藏参数，就像函数定义中声明的参数一样，当函数体被执行时，会创建这个绑定 <code>this</code>。</p><ul><li><p>对象方法调用：如果函数是作为对象的方法调用时，<code>this</code> 指向调用该方法的对象。换句话说，如果函数调用形式为 <code>obj.f()</code>，那么 <code>this</code> 指向 <code>obj</code>。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>); <span class="comment">// this 指向 obj 对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, John!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>函数调用：如果函数是作为普通函数调用时，this 指向全局对象。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>); <span class="comment">// this 指向全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, undefined!&quot;（假设全局对象的 name 属性未定义）</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>当函数被作为回调传递时，<code>this</code> 的值取决于回调的调用方式，这由 API 实现者决定。</p><p>通常情况下，回调函数会以 <code>undefined</code> 作为 <code>this</code> 值进行调用（直接调用而没有附加到任何对象上），这意味着如果函数是非严格模式的话，<code>this</code> 的值就是全局对象（<code>globalThis</code>）。<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#iterative_methods">迭代数组方法</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise">Promise()</a> 构造函数等都是这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logThis</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">forEach</span>(logThis); <span class="comment">// undefined, undefined, undefined</span></span><br></pre></td></tr></table></figure><p>有些 API 允许你为回调的调用设置 <code>this</code> 值。<br>如：所有迭代数组方法以及相关的方法如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach">Set.prototype.forEach()</a> 都接受一个可选的 <code>thisArg</code> 参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">forEach</span>(logThis, &#123; <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;obj&#x27; &#125;, &#123; name: &#x27;obj&#x27; &#125;, &#123; name: &#x27;obj&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>偶尔，某些回调会以非 <code>undefined</code> 的值作为 <code>this</code> 进行调用。<br>如：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse()</a> 的 <code>reviver</code> 参数和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a> 的 <code>replacer</code> 参数会以当前被解析/序列化属性所属的对象作为 <code>this</code> 进行调用。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> 通过继承封闭上下文的 <code>this</code> 值来简化函数的定义。<br>换句话说，它们不会创建自己的 <code>this</code> 绑定，而是将 <code>this</code> 捕获为函数创建时的值，无论如何调用函数，<code>this</code> 都将保持不变。</p><p>在全局代码中，无论是否使用严格模式，<code>this</code> 始终是 <code>globalThis</code>，这是由于全局上下文的绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalObject = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>() === globalObject); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call()</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply()</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind()</a> 调用箭头函数时，<code>thisArg</code> 参数会被忽略。但仍然可以使用这些方法传递其他参数。</p><p>区别：<br>call 和 apply 调用时候立即执行，bind 调用返回新的函数。<br>当需要传递参数时候，call 直接写多个参数，apply 将多个参数写成数组，<br>bind 在绑定时候需要固定参数时候，也是直接写多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call 设置 this</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">call</span>(obj) === globalObject); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 设置 this</span></span><br><span class="line"><span class="keyword">const</span> boundFoo = foo.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">boundFoo</span>() === globalObject); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>当函数作为构造函数使用（使用 <code>new</code> 关键字），它的 <code>this</code> 会绑定到正在构建的新对象上，而不管构造函数在哪个对象上被访问。<br><code>this</code> 的值将成为 <code>new</code> 表达式的值，除非构造函数返回另一个非原始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function C() &#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o = new C();</span><br><span class="line">console.log(o.a); // 37</span><br><span class="line"></span><br><span class="line">function C2() &#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  return &#123; a: 38 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = new C2();</span><br><span class="line">console.log(o.a); // 38</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面 C2 的例子中，由于构造过程中返回了一个对象，因此绑定到 <code>this</code> 的新对象被丢弃了。<br>（这实际上使语句 <code>this.a = 37</code>; 成为无效代码。虽然它被执行了，但可以被消除而没有外部影响。）</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在使用 <code>super.method()</code> 形式调用函数时，<br>方法函数内部的 <code>this</code> 的值与 <code>super.method()</code> 调用周围的 <code>this</code> 值相同，并且通常与 <code>super</code> 引用的对象不相等。<br>因为 <code>super.method</code> 不是像上述的对象成员访问一样，它是具有不同绑定规则的特殊语法。<br>详细示例，请参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super#calling_methods_from_super">super 的相关文档</a>。</p><p>简而言之，super 可以用来访问和调用父类的内容。</p><h2 id="类上下文"><a href="#类上下文" class="headerlink" title="类上下文"></a>类上下文</h2><p>一个类可以拆分为两个上下文：静态和实例。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">构造函数</a>、方法和实例字段初始值设定项（公共或私有）属于实例上下文。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">静态</a>方法、静态字段初始值设定项和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks">静态初始化块</a>属于静态上下文。<br><code>this</code> 的值在每个上下文中的值都不同。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  instanceField = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">static</span> staticField = <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">instanceField</span> === c); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(C.<span class="property">staticField</span> === C); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>与基类构造函数不同，派生构造函数没有初始的 <code>this</code> 绑定。<br>调用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super">super()</a> 会在构造函数内部创建一个 <code>this</code> 绑定。<br>其中，<code>Base</code> 是基类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span> = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br></pre></td></tr></table></figure><p><strong>警告</strong>：在调用 <code>super()</code> 之前引用 <code>this</code> 将会抛出错误。</p><p>派生类必须在调用 <code>super()</code> 之前不返回任何值，除非构造函数返回一个对象（因此覆盖了 <a href="">this</a> 值），或者该类根本没有构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlsoGood</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Good</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AlsoGood</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bad</span>(); <span class="comment">// 报错：必须在派生类构造函数中调用 super() 才能访问 &#x27;this&#x27; 或返回出派生构造函数。</span></span><br></pre></td></tr></table></figure><h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><p>在全局环境下，<code>this</code> 值取决于脚本执行的上下文中运行。<code>this</code> 指向全局对象（通常是 window 对象）。<br>指在浏览器环境中，全局作用域下使用 this 可以直接访问 window 对象的属性和方法。</p><p>在脚本的顶层，<code>this</code> 引用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis">globalThis</a> 无论是否处于严格模式，这通常与全局对象相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="公布答案及解析，你的战绩如何？"><a href="#公布答案及解析，你的战绩如何？" class="headerlink" title="公布答案及解析，你的战绩如何？"></a>公布答案及解析，你的战绩如何？</h1><h2 id="小试牛刀-1"><a href="#小试牛刀-1" class="headerlink" title="小试牛刀 1"></a>小试牛刀 1</h2><p><strong>答案</strong>：TOM、Jerry</p><p><strong>解析</strong>：<br>问题1：<code>SayHi</code> 函数返回一个新的匿名函数，所以主要看谁调用了它，没人具体的调用者，所以this 指向 window。<br>问题2：<code>SayFoo</code> 函数返回一个新的匿名箭头函数，所以主要看定义该箭头函数其父级的 this，其父级的 this 指向的是该函数的调用者，所以 this 指向 obj。</p><h2 id="小试牛刀-2"><a href="#小试牛刀-2" class="headerlink" title="小试牛刀 2"></a>小试牛刀 2</h2><p><strong>答案</strong>：win。</p><p><strong>解析</strong>：<br>使用箭头函数定义了对象 obj 的属性 a。<br>箭头函数不会绑定自己的 this 值，而是继承外层作用域的 this 值。<br>在全局作用域中，this 指向全局对象（例如浏览器中的 window 对象），所以 this.name 实际上是在全局作用域中查找 name 变量的值。<br>在 obj1 对象上使用了 call 方法来显式设置 obj.a 函数中的 this 值为 obj1，但由于箭头函数不受 this 绑定的影响，它仍然会继承全局作用域中的 this 值。</p><h1 id="Ending…"><a href="#Ending…" class="headerlink" title="Ending…"></a>Ending…</h1><p>要正确理解和使用 this，需要了解当前代码的执行上下文，合理运用 this 指向，使得代码更加灵活和易于维护。</p><p>了解更多请参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#description">文档</a>。<br>希望这篇文章对您理解和使用 this 有所帮助。</p>]]></content>
    
    
    <summary type="html">本文将深入探讨 this 在前端开发中的应用场景以及不同情况下的指向规则，更好地理解和运用 this 指向。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="JS" scheme="https://wyiyi.github.io/amber/tags/JS/"/>
    
    <category term="this" scheme="https://wyiyi.github.io/amber/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>Thymeleaf — 简化 Java Web 开发的强大模板引擎</title>
    <link href="https://wyiyi.github.io/amber/2023/08/01/thymeleaf/"/>
    <id>https://wyiyi.github.io/amber/2023/08/01/thymeleaf/</id>
    <published>2023-08-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.618Z</updated>
    
    <content type="html"><![CDATA[<p>Thymeleaf 是一种用于在服务器端和客户端之间渲染 HTML、XML、JavaScript、CSS 和文本的 Java 模板引擎。</p><p>模板引擎在 Web 领域的主要作用：让网站实现界面和数据分离，这样大大提高了开发效率，提供自然、灵活的模板处理功能，让代码重用更加容易。</p><h1 id="Springboot-官方支持的模板引擎：Thymeleaf"><a href="#Springboot-官方支持的模板引擎：Thymeleaf" class="headerlink" title="Springboot 官方支持的模板引擎：Thymeleaf"></a>Springboot 官方支持的模板引擎：Thymeleaf</h1><ul><li><p>官方支持：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.servlet.spring-mvc.template-engines">Spring Boot 提供对 Thymeleaf 的官方支持</a>，做了很多默认配置，开发者只需编写对应 html 即可，大大减轻了上手难度和配置复杂度。</p></li><li><p>动静分离：Thymeleaf 选用 html 作为模板页，通过一些特定标签语法代表其含义，但并未破坏 html 结构，即使无网络、不通过后端渲染也能在浏览器成功打开，大大方便界面的测试和修改。</p></li><li><p>强大的表达式功能: Thymeleaf 支持强大的表达式语言（SpEL），可以在模板中执行复杂的表达式操作，如变量赋值、条件判断、迭代循环等。</p></li><li><p>易于集成：与 Spring Boot 框架紧密集成，提供了许多与 Spring Boot 相关的特性和扩展。它可以与 Spring MVC、Spring Security 等框架无缝集成。</p></li><li><p>应用广泛：Thymeleaf 是目前应用广泛的模板引擎之一，拥有活跃的社区和丰富的生态系统。它被广泛用于开发各种类型的 Web 应用和邮件模板。</p></li></ul><h1 id="Thymeleaf-的用法"><a href="#Thymeleaf-的用法" class="headerlink" title="Thymeleaf 的用法"></a>Thymeleaf 的用法</h1><p><strong>1、添加 Thymeleaf 依赖</strong></p><p>在项目的构建文件中添加 Thymeleaf 的相关依赖：</p><ul><li>Maven 依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Gradle 依赖<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   implementation <span class="string">&#x27;org.thymeleaf:thymeleaf:3.1.2.RELEASE&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2、编写模板文件</strong></p><p>创建一个以 <code>.html</code> 为后缀的模板文件，在其中使用 Thymeleaf 的模板语法。</p><p>通过使用 Thymeleaf 的标签和表达式，我们可以插入动态数据、进行条件判断、循环迭代等操作。</p><p>示例：引入 <code>www.thymeleaf.org</code> <code>&lt;p&gt;</code> 中 <code>th:text=&quot;&#39;Hello, &#39; + $&#123;name&#125; + &#39;!&#39;&quot;</code> 为 Thymeleaf 语法。</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Hello, &#x27; + $&#123;name&#125; + &#x27;!&#x27;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、控制器中使用 Thymeleaf</strong></p><p>在 Spring MVC 的控制器中，参数的值将添加到 <code>Model</code> 对象，传递给 <code>Thymeleaf 模板</code>。<br>Thymeleaf 会自动根据模板中的表达式来渲染数据，并生成最终的 <code>HTML</code> 页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.servingwebcontent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greeting</span><span class="params">(<span class="meta">@RequestParam(name=&quot;name&quot;, required=false, defaultValue=&quot;World&quot;)</span> String name, Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;greeting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何使用标准方言"><a href="#如何使用标准方言" class="headerlink" title="如何使用标准方言"></a>如何使用标准方言</h1><p>如果你看过使用<a href="https://www.thymeleaf.org/doc/articles/sayhelloextendingthymeleaf5minutes.html">标准方言</a>编写的代码片段，你应该注意到可处理的属性都是以 th: 开头。</p><p>这个 <code>th</code> 被称为方言前缀，它意味着所有由该方言处理的标签和属性都将以这个前缀开始。每个方言可以指定自己的前缀。</p><p>还要注意的是，一个模板引擎可以同时设置多个方言，从而允许处理包含所有指定方言特性的模板（把方言视为一种类似 JSP 标签库的增强功能）。<br>其中一些方言可以共享前缀，实际上充当一个聚合方言的作用。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><p>Thymeleaf 提供了许多 <code>th</code> 属性，用于评估表达式并将这些属性的值设置为其结果。<br>它们的名称与它们所设置的属性的名称相似，用来对应不同的 XHTML 和 HTML5 属性。</p><p>标准方言中的几个最基本的属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 替换了标签的主体</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;msg.welcome&#125;&quot;</span>&gt;</span>Welcome everyone!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 语法等同于 foreach</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;book : $&#123;books&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;book.title&#125;&quot;</span>&gt;</span>En las Orillas del Sar<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 提交表单时，浏览器将向 /createOrder 发送POST请求 </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/createOrder&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">// 使用表达式 #&#123;form.submit&#125; 的求值结果作为按钮的值</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;#&#123;form.submit&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 跳转到 /admin/users 地址</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/admin/users&#125;&quot;</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Thymeleaf-标准表达式"><a href="#Thymeleaf-标准表达式" class="headerlink" title="Thymeleaf 标准表达式"></a>Thymeleaf 标准表达式</h2><p>大多数 Thymeleaf 属性允许将其值设置为或包含表达式，由于它们使用的方言，我们将其称为标准表达式。</p><p>包含以下五种类型：</p><h3 id="…-Variable-expressions"><a href="#…-Variable-expressions" class="headerlink" title="${…} : Variable expressions."></a>${…} : Variable expressions.</h3><p>变量表达式用于在模板中访问和显示变量的值。<br>变量可以是通过控制器传递给模板的模型属性、请求参数、会话属性等。</p><p><strong>1、访问自定义对象</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;user.name&#125;</code> 表达式用于访问模型中名为 “user” 对象的 “name” 的属性，并将其值插入到 <code>&lt;p&gt;</code> 元素中。</p><p><strong>2、访问内置对象</strong></p><p>① 访问请求对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;requestURI&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;#request.requestURI&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#base-objects%22">Thymeleaf 文档</a> 中可通过 ${<code>#ctx.request</code>} 在上下文对象中获取 request，也可以通过简化形式 ${<code>#request</code>} 获得到 request。再通过 request 中的 requestURI 获得。</p><p>② 访问请求参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;param.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;param.email&#125;</code> 表达式用于获取名为 “email” 的请求参数的值，并将其插入到 <code>&lt;p&gt;</code> 元素中。</p><p>③ 访问会话属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;session.user&#125;</span><br></pre></td></tr></table></figure><p><code>$&#123;session.user&#125;</code> 表达式用于获取会话中名为 “user” 的属性的值，并将其插入到 <code>&lt;p&gt;</code> 元素中。</p><p>【注意】：${…} 变量表达式在模板中只能读取变量的值，不能修改变量的值。</p><h3 id="…-Selection-expressions"><a href="#…-Selection-expressions" class="headerlink" title="*{…} : Selection expressions."></a>*{…} : Selection expressions.</h3><p>选择表达式与变量表达式一样，将在选定的对象上执行，而不是在整个上下文变量映射上执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;user&#125;</code> 是一个对象绑定到上下文变量中的用户对象。<code>th:object</code> 指令会将该对象设置为当前选择对象。<br>然后，我们可以使用选择表达式 <code>*&#123;age&#125;</code> 相当于 <code>$&#123;user.age&#125;</code> 来获取对象的属性值。</p><h3 id="…-Message-i18n-expressions"><a href="#…-Message-i18n-expressions" class="headerlink" title="#{…} : Message(i18n) expressions."></a>#{…} : Message(i18n) expressions.</h3><p>#{…} 是一种用于国际化（i18n）的消息表达式。它的主要目的是在软件中支持多语言的消息处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, #&#123;name&#125;!`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br></pre></td></tr></table></figure><p><code>#&#123;name&#125;</code> 表达式用来将变量 name 的值动态地插入到问候消息中，生成适当的本地化文本。</p><h3 id="…-Link-URL-expressions"><a href="#…-Link-URL-expressions" class="headerlink" title="@{…} : Link(URL) expressions."></a>@{…} : Link(URL) expressions.</h3><p><code>@&#123;...&#125;</code> 表达式是链接表达式（Link Expressions），用于生成动态链接（URL）。可以轻松地处理路由和参数传递，无需手动构建 URL。</p><p><strong>1、生成相对路径链接：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/home&#125;&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@&#123;/home&#125;</code> 表达式将生成一个相对于当前上下文路径的链接，指向 “home” 路径。当用户点击链接时，将导航到 “/home” 页面。</p><p><strong>2、生成带参数的链接：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user/details(userId=$&#123;user.id&#125;)&#125;&quot;</span>&gt;</span>View Details<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@&#123;/user/details(userId=$&#123;user.id&#125;)&#125;</code> 表达式生成一个带有参数的链接。<br><code>$&#123;user.id&#125;</code> 是一个变量表达式，表示用户的 ID。生成的链接将包含用户 ID 作为查询参数，例如： “/user/details?userId=123”。</p><p><strong>3、生成 URI 片段链接：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;#section-1&#125;&quot;</span>&gt;</span>Go to Section 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接跳转到具有 ID 为 “section-1” 的页面片段。</p><p>【注意】：</p><ul><li>链接表达式只能在 HTML 标签的属性中使用，用于生成正确的链接。</li><li>片段表达式在 <code>Thymeleaf 3.0</code> 及更高版本中引入。</li></ul><h3 id="…-Fragment-expressions"><a href="#…-Fragment-expressions" class="headerlink" title="~{…} : Fragment expressions."></a>~{…} : Fragment expressions.</h3><p><code>~&#123;...&#125;</code> 表达式是<a href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#template-layout%22">片段表达式（Fragment Expressions）</a>，用于引入和使用模板片段，重用可独立使用的模块或组件。<br>通过引入和参数化片段，在不同的地方使用相同的代码片段，提高了模板的可维护性和重用性。</p><p>通过 <code>th:fragment</code> 定义模板，然后用 <code>th:insert</code> 或 <code>th:replace</code> 使用定义的模板。</p><p><strong>使用格式为：</strong> <code>&#123;templatename::selector&#125;</code>，应用于名为 <code>templatename</code> 的模板上的指定标记选择器所得到的片段。也可以使用：</p><ul><li><code>~&#123;templatename&#125;</code> ：包含名为 templatename 的完整模板。</li><li><code>~&#123;::selector&#125; 或 ~&#123;this::selector&#125;</code> ：插入与选择器匹配的来自同一个模板的片段。</li></ul><p><strong>常见属性：</strong></p><ul><li>th:insert：它将简单地插⼊指定宿主标签的标签体中</li><li>th:replace：⽤指定的⽚段替换其宿主标签</li></ul><p><strong>1、包含模板片段：</strong></p><p>定义了一个名为 <code>copy</code> 的片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">th:fragment</span>=<span class="string">&quot;copy&quot;</span>&gt;</span></span><br><span class="line">        <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>th:insert</code> 或 <code>th:replace</code> 属性在页面中包含该片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;footer :: copy&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;footer :: copy&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>th:insert</code> 或 <code>th:replace</code> 期望一个片段表达式（~{…}），它是一个返回片段的表达式。执行结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">      <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助于标记选择器的强大功能，可以不使用任何 <code>th:fragment</code> 属性的片段。通过 <code>CSS</code> 选择器的方式如：选择器 <code>id</code> 引用它。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;copy-section&quot;</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;footer :: #copy-section&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、参数化片段：</strong></p><p>使用 <code>th:fragment</code> 属性为片段定义参数，并调用带参数的片段。</p><p>代码定义了一个名为 <code>myFragment</code> 的片段，接收两个参数 <code>param1</code> 和 <code>param2</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;myFragment (param1, param2)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;param1&#125; + &#x27; - &#x27; + $&#123;param2&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用带参数的片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123; ::myFragment ($&#123;value1&#125;,$&#123;value2&#125;) &#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123; ::myFragment (param1=$&#123;value1&#125;,param2=$&#123;value2&#125;) &#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>th:replace=&quot;~&#123;::myFragment (param1=$&#123;value1&#125;,param2=$&#123;value2&#125;)&#125;&quot;</code> 这相当于 <code>th:replace</code> 和 <code>th:with</code> 的组合：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;::myFragment&#125;&quot;</span> <span class="attr">th:with</span>=<span class="string">&quot;param1=$&#123;value1&#125;,param2=$&#123;value2&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【注意】：片段表达式在 <code>Thymeleaf 3.0</code> 及更高版本中引入。</p><h3 id="Literals-and-operations"><a href="#Literals-and-operations" class="headerlink" title="Literals and operations"></a>Literals and operations</h3><p>在Thymeleaf模板引擎中，字面量（Literals）和表达式操作（Operations）用于在模板中进行数据处理和计算。<br>这些表达式可以用于文本替换、条件判断、循环迭代等操作，从而使模板更具动态性和灵活性。</p><ul><li>文字：<ul><li>文本文字：’一段文字’，’另一个！’，…</li><li>数字文字：0，34，3.0，12.3，…</li><li>布尔文字：true，false</li><li>空文字：null</li><li>文字标记：one，sometext，main，…</li></ul></li><li>文字操作：<ul><li>字符串连接：+</li><li>文字替换：|The name is ${name}|</li></ul></li><li>算术操作：<ul><li>二元运算符：+，-，*，/，%</li><li>减号（一元运算符）：-</li></ul></li><li>布尔操作：<ul><li>二元运算符：and，or</li><li>布尔否定（一元运算符）：！，not</li></ul></li><li>比较和相等：<ul><li>比较运算符：&gt;，&lt;，&gt;=，&lt;=（gt，lt，ge，le）</li><li>相等运算符：==，!=（eq，ne）</li></ul></li><li>条件运算符：<ul><li>If-then: (if) ? (then)</li><li>If-then-else: (if) ? (then) : (else)</li><li>Default: (value) ?: (defaultvalue)</li></ul></li></ul><p>示例：</p><p><strong>1、字符串字面量：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Hello, Thymeleaf!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&#39;Hello, Thymeleaf!&#39;</code> 是一个字符串字面量，可以在 <code>&lt;p&gt;</code> 元素中显示文本 “Hello, Thymeleaf!”。</p><p><strong>2、数字字面量：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;42&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>42</code> 是一个数字字面量，可以在 <code>&lt;p&gt;</code> 元素中显示数字 42。</p><p><strong>3、变量引用：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;username&#125;</code> 是一个变量引用，通过该表达式可以获取名为 “username” 的变量的值，并在 <code>&lt;p&gt;</code> 元素中显示。</p><p><strong>4、算术操作：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;number1 + number2&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;number1 + number2&#125;</code>是一个算术操作，通过该表达式可以对 number1 和 number2 变量进行加法运算，并在 <code>&lt;p&gt;</code> 元素中显示结果。</p><p><strong>5、逻辑操作：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age &gt;= 18&#125;&quot;</span>&gt;</span>You are an adult.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;age &gt;= 18&#125;</code> 是一个逻辑操作，通过该表达式可以判断 age 变量是否大于或等于 18，如果条件满足，则显示 “You are an adult.”。</p><h3 id="Expression-preprocessing"><a href="#Expression-preprocessing" class="headerlink" title="Expression preprocessing"></a>Expression preprocessing</h3><p>表达式预处理（Expression Preprocessing）是一种用于对表达式进行预处理和修改的机制。可以使用预处理器在表达式求值之前对其进行操作和转换。<br>预处理器提供了一些特殊语法和功能，可以扩展表达式的功能并提供更好的灵活性和可读性。</p><p>预处理的具体用法：</p><p><strong>1、转义表达式：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;|Hello, \$&#123;name&#125;!|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>|\$&#123;name&#125;|</code> 是一个转义表达式，通过在表达式外添加竖线字符 “|”，可以防止表达式被求值，而直接显示为文本 “Hello, ${name}!”。</p><p><strong>2、默认值设置：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125; ?: &#x27;Guest&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;username&#125; ?: &#39;Guest&#39;</code> 是一个默认值设置，如果 username 变量为空或不存在，将使用默认值 “Guest”。</p><p><strong>3、集合选择：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;item : $&#123;items&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;item.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;item.name&#125;</code> 是一个集合选择表达式，用于从 items 集合中选取每个元素的 name 属性并显示在列表项中。</p><p><strong>4、字符串拼接：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Hello &#x27; + $&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&#39;Hello &#39; + $&#123;name&#125;</code> 是一个字符串拼接表达式，可将字符串 “Hello “ 和 name 变量的值进行拼接。</p><p>【注意】：片段表达式在 <code>Thymeleaf 3.0</code> 及更高版本中引入。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Thymeleaf</code> 是一种 Java 模板引擎，大大提高开发效率，提高代码复用率，拥有快速开发网页能力，掌握它还是很有必要的！<br>若想了解更多 <code>Thymeleaf</code> ，请到<a href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#introducing-thymeleaf">Thymeleaf 官网</a>深入学习。</p>]]></content>
    
    
    <summary type="html">Thymeleaf 是一种用于在服务器端和客户端之间渲染 HTML、XML、JavaScript、CSS 和文本的 Java 模板引擎。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Spring" scheme="https://wyiyi.github.io/amber/tags/Spring/"/>
    
    <category term="Java Web" scheme="https://wyiyi.github.io/amber/tags/Java-Web/"/>
    
    <category term="Thymeleaf" scheme="https://wyiyi.github.io/amber/tags/Thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>JSON Lines — 处理大数据集的灵活格式</title>
    <link href="https://wyiyi.github.io/amber/2023/07/01/jsonlines/"/>
    <id>https://wyiyi.github.io/amber/2023/07/01/jsonlines/</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.617Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wyiyi.github.io/amber/contents/2023/json-lines.png"></p><p><a href="https://jsonlines.org/">JSON Lines</a>，顾名思义，就是每行都是一个 JSON，是一种文本格式。</p><p>在处理和分析大型数据集时，JSON Lines 格式成为了一种受欢迎的选择。JSON Lines 通过将每个 JSON 对象放在独立的一行中，使得逐行读取和处理数据变得简单，易于处理大型数据集、容易与现有工具集成，具有灵活性和可扩展性、易于阅读和维护等特点。</p><p>与传统的 JSON 格式相比，JSON Lines 不需要一次性加载整个文件，而是可以逐行读取和处理数据。这种特性使得 JSON Lines 非常适用于处理大型数据集，无需担心内存限制或性能问题。</p><h2 id="JSON-Lines-特点"><a href="#JSON-Lines-特点" class="headerlink" title="JSON Lines 特点"></a>JSON Lines 特点</h2><ol><li>采用 UTF-8 编码；</li><li>每行必须是一个有效的 JSON 对象；</li><li>在每个 JSON 对象，采用 \n 或 \r\n 作为行分隔符；</li><li>建议约定：<ul><li>JSON Lines文件通常使用文件扩展名 <code>.jsonl</code> 保存</li><li>建议使用像 <code>gzip</code> 或 <code>bzip2</code> 这样的流压缩器以节省空间，生成 <code>.jsonl.gz</code> 或 <code>.jsonl.bz2</code> 文件</li><li>MIME 类型可以是 <code>application/jsonl</code>，但这 <a href="https://github.com/wardi/jsonlines/issues/19">还没有被标准化</a></li><li>文本编辑程序将文本文件的第一行称为“第1行”。JSON Lines文件中的第一个值也应称为“第1个值”</li></ul></li></ol><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>一个大小为 1GB 的 JSON 文件，当我们需要读取/写入内容时，需要读取整个文件、存储至内存并将其解析、操作，这是不可取的。</p><p>若采用 JSON Lines 保存该文件，则操作数据时，我们无需读取整个文件后再解析、操作，而可以根据 JSON Lines 文件中每一行便为一个 JSON 值的特性，边读取边解析、操作。例如：在插入 JSON 值时，我们只需要 append 值到文件中即可。因此，操作 JSON Lines 文件时，只需要：</p><ol><li>读取一行值；</li><li>将值解析为 JSON；</li><li>重复 1、2 步骤。</li></ol><p>JSON Lines 格式非常适合处理日志文件等大型数据集。它通过逐行读取和处理数据，方便了大数据场景下的分析和处理。同时，它的灵活性和可扩展性使得我们可以根据需要定义自己的数据结构。</p><figure class="highlight json"><figcaption><span>lines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gilbert&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;wins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="string">&quot;straight&quot;</span><span class="punctuation">,</span> <span class="string">&quot;7♣&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="string">&quot;one pair&quot;</span><span class="punctuation">,</span> <span class="string">&quot;10♥&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alexa&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;wins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="string">&quot;two pair&quot;</span><span class="punctuation">,</span> <span class="string">&quot;4♠&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="string">&quot;two pair&quot;</span><span class="punctuation">,</span> <span class="string">&quot;9♠&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;May&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;wins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Deloise&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;wins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="string">&quot;three of a kind&quot;</span><span class="punctuation">,</span> <span class="string">&quot;5♣&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>JSON Lines 在处理大量类似的嵌套数据结构方面的优势最大。<br>与一个满是XML文件的目录相比，使用一个 <code>.jsonl</code> 文件更容易操作。</p><p>那么如何将 JSON Lines 转换为 JSON 格式呢？下方代码为 JavaScript 示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonLinesString = <span class="string">`&#123;&quot;name&quot;: &quot;Gilbert&quot;, &quot;wins&quot;: [[&quot;straight&quot;, &quot;7♣&quot;], [&quot;one pair&quot;, &quot;10♥&quot;]]&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Alexa&quot;, &quot;wins&quot;: [[&quot;two pair&quot;, &quot;4♠&quot;], [&quot;two pair&quot;, &quot;9♠&quot;]]&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;May&quot;, &quot;wins&quot;: []&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Deloise&quot;, &quot;wins&quot;: [[&quot;three of a kind&quot;, &quot;5♣&quot;]]&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonLines = jsonLinesString.<span class="title function_">split</span>(<span class="regexp">/\n/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonString = <span class="string">&quot;[&quot;</span> + jsonLines.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonValue = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jsonValue);</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果您有大型的嵌套结构，那么不建议直接阅读 JSON Lines 文本。使用 <code>jq</code> 工具可以更轻松地查看大型结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ grep pair winning_hands.jsonl | jq .</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Gilbert&quot;</span>, </span><br><span class="line">  <span class="string">&quot;wins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;straight&quot;</span>, </span><br><span class="line">      <span class="string">&quot;7♣&quot;</span></span><br><span class="line">    ], </span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;one pair&quot;</span>, </span><br><span class="line">      <span class="string">&quot;10♥&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alexa&quot;</span>, </span><br><span class="line">  <span class="string">&quot;wins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;two pair&quot;</span>, </span><br><span class="line">      <span class="string">&quot;4♠&quot;</span></span><br><span class="line">    ], </span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;two pair&quot;</span>, </span><br><span class="line">      <span class="string">&quot;9♠&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="格式校验"><a href="#格式校验" class="headerlink" title="格式校验"></a>格式校验</h2><p><a href="https://jsonlines.org/validator/">https://jsonlines.org/validator/</a> 提供一个在线的格式校验工具，可校验内容是否是合法的 JSON Lines 格式。</p><h2 id="files2jsonl"><a href="#files2jsonl" class="headerlink" title="files2jsonl"></a>files2jsonl</h2><p><a href="https://github.com/AlphaHinex/go-toolkit/tree/main/files2jsonl">files2jsonl</a> 可以将一个路径下的多个文本文件（可按文件类型过滤）内容，输出成一个 JSON Lines 格式文件。输出的文件中，每行表示一个输入文件的 JSON 字符串。</p><p>具体格式如下：</p><figure class="highlight json"><figcaption><span>lines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;content_of_source_file_1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;absolute_path_to_source_file_1&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;content_of_source_file_2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;absolute_path_to_source_file_2&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;content_of_source_file_3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;absolute_path_to_source_file_3&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./files2jsonl -d /path/to/src \</span><br><span class="line">-i xml,pom,java,groovy,yml,yaml,properties,json,sql,htm,vue,json,html,js,md,sh \</span><br><span class="line">-o /path/to/target</span><br></pre></td></tr></table></figure><ul><li><code>-d</code> 指定源文件路径</li><li><code>-i</code> 指定需要包含的文件类型，不区分大小写，可省略，表示包含全部文件</li><li><code>-o</code> 指定输出文件路径，默认输出到当前路径</li></ul><p>在 <a href="https://github.com/AlphaHinex/go-toolkit/releases">Releases</a> 页面可以下载到此工具的预编译版本，如 Windows x86_64 位环境下可用的 <code>files2jsonl_win_amd64.exe</code></p><p>通过如下命令可将 <code>C:/Users/Administrator/Desktop</code> 路径下的所有文件内容输出至一个 JSON Lines 文件内：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files2jsonl_win_amd64.exe -d C:/Users/Administrator/Desktop</span><br></pre></td></tr></table></figure><p>不使用 <code>-o</code> 参数指定输出文件时，默认在当前路径生成一个 <code>data.jsonl</code> 文件和 <code>data.jsonl.gz</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;text&quot;:&quot;#!/bin/bash\nnohup ... \n&quot;,&quot;url&quot;:&quot;C:\\Users\\Administrator\\Desktop\\start.sh&quot;&#125;</span><br><span class="line">&#123;&quot;text&quot;:&quot;package com.xxx.entity;\r\n&quot;,&quot;url&quot;:&quot;C:\\Users\\Administrator\\Desktop\\Test.java&quot;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">格式及相关小工具介绍</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="Go" scheme="https://wyiyi.github.io/amber/tags/Go/"/>
    
    <category term="JSON Lines" scheme="https://wyiyi.github.io/amber/tags/JSON-Lines/"/>
    
    <category term="AI" scheme="https://wyiyi.github.io/amber/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Builder Pattern</title>
    <link href="https://wyiyi.github.io/amber/2023/04/01/builderPattern/"/>
    <id>https://wyiyi.github.io/amber/2023/04/01/builderPattern/</id>
    <published>2023-04-01T00:00:00.000Z</published>
    <updated>2025-08-19T14:07:21.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Builder-Pattern"><a href="#Builder-Pattern" class="headerlink" title="Builder Pattern"></a>Builder Pattern</h1><h2 id="Builder-Pattern-？"><a href="#Builder-Pattern-？" class="headerlink" title="Builder Pattern ？"></a>Builder Pattern ？</h2><p>Builder 设计模式是一种创建型设计模式，旨在处理相对复杂的对象的构造。也称 <strong>建造者模式</strong>。</p><p>Builder 模式可以通过使用另一个对象（生成器）来构造对象来分离实例化过程。</p><p>这样就可以使用相同的构建过程来创建不同类型和表示的对象。</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>在以下情况使用 Builder 模式：</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li><li>当构造过程必须允许被构造的对象有不同的表示时</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://wyiyi.github.io/amber/contents/2023/builder.png"></p><ul><li><p>Product：表示被构造的复杂对象；包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p></li><li><p>Builder：为创建一个 Product 对象的各个部件指定抽象接口。如：制造商、发动机、颜色、轮子、价格属性。</p></li><li><p>ConcreteBuilder: 实现 Builder 的接口以构造和装配该产品的各个部件；定义并明确它所创建的表示；提供一个检索产品的接口。<br>如：梅特赛斯的厂家、V8的引擎、红颜色、4个轮子、50的价格。</p></li><li><p>Director: 构造一个使用 Builder 接口的对象。如：驾车的人员。<br>它包含一个负责组装的方法 void Construct(Builder builder)，<br>在这个方法中调用 builder 的方法，并进行设置 builder，<br>就可以通过 builder的 getProduct() 方法获得最终的产品。</p></li></ul><h2 id="Builder-Pattern-实现"><a href="#Builder-Pattern-实现" class="headerlink" title="Builder Pattern 实现"></a>Builder Pattern 实现</h2><ol><li>当前汽车类 Car 是由制造商、发动机、颜色、轮子、价格组成。</li></ol><p>注意访问修饰符声明为 private，因为不希望外部能直接访问这个类，<br>构造函数也是私有的，只有分配给此类的生成器才能访问它。<br>构造函数中设置的所有属性都是从我们作为参数提供的构建器对象中提取的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String make;</span><br><span class="line">    <span class="keyword">private</span> String engine;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wheels;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// builder code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在类中定义静态内部类 CarBuilder </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CarBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> CarBuilder <span class="title function_">addMake</span><span class="params">(String make)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.car.setMake(make);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> CarBuilder <span class="title function_">addEngine</span><span class="params">(String engine)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.car.setEngine(engine);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> CarBuilder <span class="title function_">addColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.car.setColor(color);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> CarBuilder <span class="title function_">addWheels</span><span class="params">(<span class="type">int</span> wheels)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.car.setWheels(wheels);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> CarBuilder <span class="title function_">addPrice</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.car.setPrice(price);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Car <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.car;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>build 方法调用外部类的私有构造函数，并将自身作为参数传递，<br>输入对应值的信息，最终构建出我们需要的汽车信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>.CarBuilder()</span><br><span class="line">            .addMake(<span class="string">&quot;梅特赛斯&quot;</span>)</span><br><span class="line">            .addEngine(<span class="string">&quot;V8&quot;</span>)</span><br><span class="line">            .addColor(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">            .addWheels(<span class="number">4</span>)</span><br><span class="line">            .addPrice(<span class="number">50</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    System.out.println(car); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car(make=梅特赛斯, engine=V8, color=red, wheels=4, price=50)</span><br></pre></td></tr></table></figure></li></ol><h2 id="简单写法：lombok的-Builder-注解"><a href="#简单写法：lombok的-Builder-注解" class="headerlink" title="简单写法：lombok的 @Builder 注解"></a>简单写法：lombok的 @Builder 注解</h2><p>CarBuilder 内部类似乎有点繁琐，使用 <code>lombok</code> 的 <code>@Builder</code> 注解，即可省去手写 CarBuilder 内部类。</p><p>lombok 的 @Builder 注解是一种实现 builder 设计模式的方式。</p><p>lombok 的 @Builder 注解可以生成一个构造器类，通过这个类使用链式调用的方式就可以初始化该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String make;</span><br><span class="line">    <span class="keyword">private</span> String engine;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wheels;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span>  Car.builder()</span><br><span class="line">            .make(<span class="string">&quot;梅特赛斯&quot;</span>)</span><br><span class="line">            .engine(<span class="string">&quot;V8&quot;</span>)</span><br><span class="line">            .color(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">            .wheels(<span class="number">4</span>)</span><br><span class="line">            .price(<span class="number">50</span>)</span><br><span class="line">            .build();</span><br><span class="line">    System.out.println(car);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解可以看到编译后的代码，输出日志与手写一致，均能获得到汽车相关信息。</p><h2 id="Spring—ResponseEntity-BodyBuilder"><a href="#Spring—ResponseEntity-BodyBuilder" class="headerlink" title="Spring—ResponseEntity.BodyBuilder"></a><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.BodyBuilder.html" title="Spring—ResponseEntity.BodyBuilder">Spring—ResponseEntity.BodyBuilder</a></h2><p>在 Spring 中 Builder 的设计模式也有体现，在 <code>ResponseEntity</code><br>类中提供了 BodyBuilder 接口，用于构建 HTTP 响应，包括：状态码 status()、头信息 header() 和 响应体 body() 等。</p><h3 id="如何构建"><a href="#如何构建" class="headerlink" title="如何构建"></a>如何构建</h3><p>根据请求的不同情况来设置不同的状态码和响应体，以及添加不同的头信息，并使用 builder.build() 方法来构建最终的 ResponseEntity 对象。</p><ol><li><p>创建一个 HTTP 状态码为 200 的响应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity.<span class="type">BodyBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> ResponseEntity.ok();</span><br></pre></td></tr></table></figure></li><li><p> 使用 builder 对象来设置响应体的内容，使用<code>builder.body()</code>方法来设置响应体的主体内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.body(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 builder.header() 方法来设置响应头，自定义设置成响应头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>builder.build() 方法来构建最终的 ResponseEntity 对象。构建一个 HTTP 状态码为 200、响应体为 <code>&quot;Hello World&quot;</code> 、自定义响应头 <code>&quot;Content-Type&quot;, &quot;text/plain&quot;</code> 的响应体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        ResponseEntity.<span class="type">BodyBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> ResponseEntity.ok();</span><br><span class="line">        builder.header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        builder.body(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://book.douban.com/subject/34262305/">设计模式-可复用面向对象软件的基础</a></p><p><a href="https://www.baeldung.com/creational-design-patterns#builder">Builder Design Pattern</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.BodyBuilder.html">ResponseEntity.BodyBuilder</a></p>]]></content>
    
    
    <summary type="html">Builder 设计模式是一种创建型设计模式，它允许您创建不同类型和表示的对象，同时避免构造函数污染和过多的可选参数。在本文中，我们将深入探讨 Builder 设计模式的概念、实现和使用场景。</summary>
    
    
    
    <category term="Technology" scheme="https://wyiyi.github.io/amber/categories/Technology/"/>
    
    
    <category term="ResponseEntity" scheme="https://wyiyi.github.io/amber/tags/ResponseEntity/"/>
    
  </entry>
  
</feed>
